// src/graphics/gui/rapier_debugger/RapierDebuggerUI.js
// HUD for the Rapier debugger view (DOM + input wiring).
const INPUT_HELP = {
    engineForce: 'Engine force (N) is a longitudinal force applied by the Rapier vehicle controller at the tire contact patch (it is not engine torque/RPM).\n\nHow it is applied:\n- This debugger applies engine force per-wheel to the REAR wheels only via setWheelEngineForce().\n- Front wheels get 0.\n\nHow it affects the car:\n- Higher values increase forward acceleration and usually increase the reported forwardImpulse.\n- Actual acceleration is limited by tire traction (frictionSlip / sideFrictionStiffness) and whether the wheel is in contact.\n\nInteractions:\n- If Brake/Handbrake are also non-zero, Rapier applies braking too (the forces fight).\n- Very large forces can cause tire slip, jitter, or wheel-hop, especially with soft suspension or low mass.',
    brakeForce: 'Brake force (N) is the braking strength used by the Rapier vehicle controller via setWheelBrake() (it is not a direct chassis force).\n\nHow it is applied:\n- This debugger applies brake force per-wheel to ALL wheels.\n\nHow it affects the car:\n- Higher values decelerate faster.\n- If brake is too high for available traction, wheels can lock and the vehicle will slide (reduced steering control).\n\nInteractions:\n- Works per-wheel only while that wheel is in contact.\n- If Engine is also non-zero, Rapier applies both; net motion depends on the balance.\n- Braking while steering can strongly affect yaw/understeer/oversteer.',
    handbrakeForce: 'Handbrake force (N) is extra braking applied only to the REAR wheels (useful to lock the rear axle).\n\nHow it is applied:\n- Rear brake = Brake + Handbrake.\n- Front brake = Brake.\n\nHow it affects the car:\n- Locks/slows the rear wheels more than the fronts, which can create oversteer/spins when steering.\n\nInteractions:\n- Strongly depends on tire friction and contact; if rear wheels lose contact, it has no effect.\n- Too much handbrake force will instantly lock the rear and make the car slide rather than turn.',
    steerAngle: 'Sets the steering angle (radians) for the wheel. Typical +/-0.2 to 0.6.',
    bodyType: 'Rigid-body type: dynamic reacts to forces, fixed is immovable, kinematic is user-driven.',
    translation: 'Rigid-body translation in world space (meters).',
    rotation: 'Rigid-body rotation as a unit quaternion.',
    linvel: 'Initial linear velocity (m/s).',
    angvel: 'Initial angular velocity (axis times rad/s).',
    worldGravity: 'World gravity vector (m/s^2). Slider controls gravity scale for this body.',
    gravityScale: 'Scales gravity for this body (0 disables, negative flips). Typical 0.5 to 2.',
    canSleep: 'Allow this body to sleep when it becomes idle. Marker: green=awake, red=sleeping.',
    ccdEnabled: 'Enable continuous collision detection to reduce tunneling.',
    dominanceGroup: 'Dominance group [-127, 127]. Keep small values like -1, 0, 1.',
    lockTranslations: 'Lock translations along all axes.',
    lockRotations: 'Lock rotations along all axes.',
    enabledRotations: 'Enable rotation per axis (X/Y/Z).',
    force: 'Persistent force added in chassis local space (X=right, Y=up, Z=forward). Scale with mass.',
    forcePoint: 'Local point on the chassis box for applying a force (meters).',
    torque: 'Persistent torque in chassis local space. Scale with mass and size.',
    impulse: 'Instantaneous impulse in chassis local space. Scale with mass.',
    impulsePoint: 'Local point on the chassis box for applying an impulse (meters).',
    torqueImpulse: 'Instantaneous torque impulse in chassis local space. Scale with mass and size.',
    forcesPanelForce: 'Force (persistent) adds a continuous push every physics step and changes linear velocity.\n\nAdd force acts at the center of mass (COM), so it does not create torque.\n\nForce @ point applies at a point on the body. If that point is not at the COM, it also creates torque: torque = (point - COM) × force.\n\nReset forces clears the linear component. If you used Force @ point (or the COM is offset), reset torques too to clear the rotational component.',
    forcesPanelTorque: 'Torque (persistent) adds a continuous twist every physics step and changes angular velocity.\n\nTorque does not directly translate the body.\n\nReset torques clears persistent torque inputs (including torque generated by Force @ point).',
    forcesPanelImpulse: 'Impulse is a one-shot change to velocity.\n\nApply impulse changes linear velocity. Impulse @ point can also change angular velocity when the point is not at the COM (same cross-product rule).\n\nImpulses are not persistent; use Reset All Velocities to clear their effect.',
    spawnHeight: 'Initial translation Y when spawning or resetting.',
    groundClearance: 'Ride height before suspension. Often 0.2-0.4 of wheel radius.',
    wheelSideInset: 'Wheel side offset from chassis side. Positive widens track. Zero keeps wheel outer face flush; typical 0-0.2x wheel width.',
    restLength: 'Sets the rest length of the wheel suspension spring. Often 0.3-0.6 of wheel radius.',
    wheelbaseRatio: 'Wheel Z position as a fraction of chassis length. Typical 0.6-0.75.',
    additionalMass: 'Additional chassis mass (kg).\n\nManual/Auto inertia modes:\n- Used only when full mass properties are NOT being provided.\n\nRapier inertia mode:\n- Used only as a fallback target mass (when Mass props mass is not set) to compute collider density.',
    linearDamping: 'Linear damping coefficient. Typical 0 to 1.',
    angularDamping: 'Angular damping coefficient. Typical 0 to 2.',
    massPropsMass: 'Mass (kg) used by the mass-properties system.\n\nManual: sets the rigid-body mass.\nAuto: sets mass and is used to auto-compute inertia from the chassis box size.\nRapier: if collider density is 0/unset, this mass is converted into collider density: density = mass / (width·height·length).',
    massPropsComX: 'Additional mass properties center of mass X (local chassis space).',
    massPropsComY: 'Additional mass properties center of mass Y (local chassis space).',
    massPropsComZ: 'Additional mass properties center of mass Z (local chassis space).',
    massPropsInertiaX: 'Principal inertia X. Roughly mass * size^2.',
    massPropsInertiaY: 'Principal inertia Y. Roughly mass * size^2.',
    massPropsInertiaZ: 'Principal inertia Z. Roughly mass * size^2.',
    massPropsFrameW: 'Inertia frame W. Keep quaternion normalized.',
    massPropsFrameX: 'Inertia frame X. Keep quaternion normalized.',
    massPropsFrameY: 'Inertia frame Y. Keep quaternion normalized.',
    massPropsFrameZ: 'Inertia frame Z. Keep quaternion normalized.',
    massPropsDensity: 'Chassis collider density (kg/m³), used only in Inertia mode = Rapier.\n\nWhen set (>0), Rapier computes chassis mass/COM/inertia from the chassis collider + this density.\nMass = density · (width·height·length).\n\nSet to 0 to disable and fall back to Mass props mass (or Additional mass if mass is missing).',
    inertiaMode: 'Controls how chassis mass + inertia are determined:\n\nManual: you provide mass, center of mass (COM), inertia and inertia-frame.\nAuto: inertia + frame are computed from mass and chassis box size.\nRapier: mass/COM/inertia come from the chassis collider density (inertia/COM inputs are ignored).',
    inertia: 'Principal inertia values define how rotational mass is distributed (moment of inertia).\n\nHigher values = harder to rotate. Lower values = easier to tip/roll.\n\nTip: inertia is independent of throttle/engine; it affects angular acceleration from torque.\n\nUse Auto for a sane baseline, Manual to override, or Rapier to let the collider define inertia.',
    inertiaFrame: 'Quaternion that orients the inertia tensor in body space.',
    locking: 'Locks translations or rotations for this rigid body.',
    suspMaxTravel: 'Sets the maximum distance the suspension can travel before and after its resting length. Typical 0.1-0.3.',
    suspStiffness: 'Sets the wheel suspension stiffness. Typical 0-10000 N/m (start around 500).',
    suspCompression: 'Wheel suspension compression damping. Typical 0.0-5.0 (start around 1.0).',
    suspRelaxation: 'Wheel suspension relaxation damping. Typical 0.0-5.0 (start around 1.0).',
    suspMaxForce: 'Sets the maximum force applied by the wheel suspension. Typical 0-200000 N (start around 80000 for bus scale).',
    tireFrictionSlip: 'Sets the parameter controlling how much traction the tire has. Typical 6-10.',
    tireSideStiffness: 'Multiplier of friction between the tire and the collider it is on top of. Typical 1-2.'
};

const OUTPUT_HELP = {
    status: 'Simulation status from the physics step.',
    speed: 'Controller speed along vehicle forward axis.',
    speedKph: 'Controller speed in km/h.',
    speedProj: 'Projected speed along world forward.',
    yaw: 'Yaw angle in degrees.',
    axes: 'Vehicle controller axis indices.',
    mass: 'Computed rigid-body mass.',
    position: 'Rigid-body position in world space (m).',
    rotation: 'Rigid-body rotation quaternion.',
    linvel: 'Rigid-body linear velocity (m/s).',
    angvel: 'Rigid-body angular velocity (rad/s).',
    contacts: 'wheelIsInContact for each wheel. Dots are FL, FR, RL, RR (front to rear, left to right).',
    rayDown: 'Ray cast down hit and time of impact.',
    counts: 'Rigid-body and collider counts.',
    wheels: 'Per-wheel: contact uses wheelIsInContact, steer uses wheelSteering (rad), suspension length/force use wheelSuspensionLength and wheelSuspensionForce, impulses use wheelForwardImpulse and wheelSideImpulse. eng is the engine force applied in this debugger (rear wheels only) and the orange bar shows eng relative to the Engine slider max. Connect L is wheelChassisConnectionPointCs (chassis space).'
};

function formatNum(value, digits = 2) {
    if (!Number.isFinite(value)) return 'n/a';
    return value.toFixed(digits);
}

function padLeft(str, width) {
    if (str.length >= width) return str;
    return `${' '.repeat(width - str.length)}${str}`;
}

function scalePx(value, factor) {
    if (typeof value === 'number' && Number.isFinite(value)) return `${value * factor}px`;
    if (typeof value === 'string' && value.endsWith('px')) {
        const num = parseFloat(value);
        if (Number.isFinite(num)) return `${num * factor}px`;
    }
    return value;
}

function outNum(value, digits = 2, width = 8) {
    if (!Number.isFinite(value)) return padLeft('n/a', width);
    const normalized = Math.abs(value) < 1e-9 ? 0 : value;
    return padLeft(normalized.toFixed(digits), width);
}

function outVec3(v, digits = 2, width = 8) {
    if (!v) return `${outNum(NaN, digits, width)}, ${outNum(NaN, digits, width)}, ${outNum(NaN, digits, width)}`;
    return `${outNum(v.x, digits, width)}, ${outNum(v.y, digits, width)}, ${outNum(v.z, digits, width)}`;
}

function qNum(value, digits = 3) {
    return Number.isFinite(value) ? Number(value.toFixed(digits)) : null;
}

function packVec3(v, digits = 3) {
    return [qNum(v?.x, digits), qNum(v?.y, digits), qNum(v?.z, digits)];
}

function packQuat(q, digits = 4) {
    return [qNum(q?.x, digits), qNum(q?.y, digits), qNum(q?.z, digits), qNum(q?.w, digits)];
}

function formatVec3(v, digits = 2) {
    if (!v) return 'n/a';
    return `${formatNum(v.x, digits)}, ${formatNum(v.y, digits)}, ${formatNum(v.z, digits)}`;
}

function vecNonZero(v, eps = 1e-4) {
    if (!v) return false;
    return (Math.abs(v.x) > eps) || (Math.abs(v.y) > eps) || (Math.abs(v.z) > eps);
}

function crossVec3(a, b) {
    return {
        x: (a?.y ?? 0) * (b?.z ?? 0) - (a?.z ?? 0) * (b?.y ?? 0),
        y: (a?.z ?? 0) * (b?.x ?? 0) - (a?.x ?? 0) * (b?.z ?? 0),
        z: (a?.x ?? 0) * (b?.y ?? 0) - (a?.y ?? 0) * (b?.x ?? 0)
    };
}

function computeBoxInertia(mass, width, height, length) {
    if (!Number.isFinite(mass) || mass <= 0) return { x: 0, y: 0, z: 0 };
    const round100 = (value) => Math.round(value / 100) * 100;
    const w = Number.isFinite(width) ? width : 0;
    const h = Number.isFinite(height) ? height : 0;
    const l = Number.isFinite(length) ? length : 0;
    const w2 = w * w;
    const h2 = h * h;
    const l2 = l * l;
    const k = mass / 12;
    return {
        x: round100(k * (h2 + l2)),
        y: round100(k * (w2 + l2)),
        z: round100(k * (w2 + h2))
    };
}

function resolveInertiaMode(props) {
    const raw = props?.inertiaMode;
    if (typeof raw === 'string') {
        const mode = raw.toLowerCase();
        if (mode === 'manual' || mode === 'auto' || mode === 'rapier') return mode;
    }
    if (typeof props?.autoInertia === 'boolean') return props.autoInertia ? 'auto' : 'manual';
    return 'auto';
}

function makeHudRoot() {
    const root = document.createElement('div');
    root.className = 'ui-hud-root rapier-hud';
    return root;
}

function stylePanel(el, { interactive = false } = {}) {
    el.classList.add('ui-panel');
    el.classList.add('rapier-panel');
    el.classList.toggle('is-interactive', !!interactive);
}

function makeTitle(text) {
    const t = document.createElement('div');
    t.textContent = text;
    t.className = 'ui-title';
    return t;
}

function makePopupCloseButton(onClose) {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.textContent = 'x';
    btn.className = 'rapier-popup-close';

    btn.addEventListener('pointerdown', (event) => {
        event.stopPropagation();
    });
    if (typeof onClose === 'function') {
        btn.addEventListener('click', (event) => {
            event.preventDefault();
            onClose();
        });
    }

    return btn;
}

function makePopupHeader(text, onClose) {
    const header = document.createElement('div');
    header.className = 'rapier-popup-header';

    const title = makeTitle(text);
    title.classList.add('is-inline');
    title.classList.add('rapier-popup-title');

    const closeBtn = makePopupCloseButton(onClose);

    header.appendChild(title);
    header.appendChild(closeBtn);

    return { header, title, closeBtn };
}

function makePopupDraggable(wrap, handle) {
    if (!wrap || !handle) return;
    handle.classList.add('ui-drag-handle');

    const onPointerDown = (event) => {
        if (event.button !== 0) return;
        event.preventDefault();
        const rect = wrap.getBoundingClientRect();
        const offsetX = event.clientX - rect.left;
        const offsetY = event.clientY - rect.top;
        wrap.style.left = `${rect.left}px`;
        wrap.style.top = `${rect.top}px`;
        wrap.style.bottom = '';
        wrap.style.right = '';
        handle.classList.add('is-dragging');

        const onPointerMove = (moveEvent) => {
            wrap.style.left = `${moveEvent.clientX - offsetX}px`;
            wrap.style.top = `${moveEvent.clientY - offsetY}px`;
        };

        const onPointerUp = () => {
            handle.classList.remove('is-dragging');
            window.removeEventListener('pointermove', onPointerMove);
            window.removeEventListener('pointerup', onPointerUp);
            window.removeEventListener('pointercancel', onPointerUp);
        };

        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
        window.addEventListener('pointercancel', onPointerUp);
    };

    handle.addEventListener('pointerdown', onPointerDown);
}

function makePopupWrap({ title, onClose, interactive = true, classes = [] } = {}) {
    const wrap = document.createElement('div');
    stylePanel(wrap, { interactive });
    wrap.classList.add('rapier-popup');
    for (const cls of classes) {
        if (cls) wrap.classList.add(cls);
    }

    const { header, title: titleEl, closeBtn } = makePopupHeader(title, onClose);
    wrap.appendChild(header);
    makePopupDraggable(wrap, header);

    return { wrap, header, titleEl, closeBtn };
}

function makeLabel(text) {
    const l = document.createElement('div');
    l.textContent = text;
    l.className = 'ui-section-label';
    return l;
}

function makeSeparator() {
    const hr = document.createElement('div');
    hr.className = 'ui-separator';
    return hr;
}

function makeGroup(title, { tightTop = false, showLabel = true } = {}) {
    const wrap = document.createElement('div');
    const body = document.createElement('div');
    if (showLabel) {
        const label = makeLabel(title);
        if (tightTop) {
            label.classList.add('is-tight');
        }
        wrap.appendChild(label);
    }
    wrap.appendChild(body);
    return { wrap, body };
}

function appendHelp(labelEl, helpText, helpSystem) {
    if (!helpText || !helpSystem) return;
    const help = document.createElement('span');
    help.textContent = '?';
    help.className = 'rapier-help';
    help.addEventListener('mouseenter', (e) => helpSystem.show(helpText, e));
    help.addEventListener('mousemove', (e) => helpSystem.move(e));
    help.addEventListener('mouseleave', () => helpSystem.hide());
    labelEl.appendChild(help);
}

function makeRangeControl({
    title,
    min,
    max,
    step,
    value,
    fmt,
    help,
    helpSystem,
    showLabel = true,
    sliderFirst = false,
    showHelp = true
}) {
    const wrap = document.createElement('div');
    wrap.className = 'rapier-range';
    wrap.classList.toggle('is-slider-first', sliderFirst);
    wrap.classList.toggle('is-no-label', !showLabel);

    const head = document.createElement('div');
    head.className = 'rapier-range-head';

    const label = document.createElement('div');
    label.textContent = title;
    label.className = 'rapier-range-label';
    appendHelp(label, help, helpSystem);

    const val = document.createElement('div');
    val.className = 'rapier-range-val';
    val.textContent = fmt(value);

    if (showLabel && !sliderFirst) {
        head.appendChild(label);
        head.appendChild(val);
    }

    const input = document.createElement('input');
    input.type = 'range';
    input.min = String(min);
    input.max = String(max);
    input.step = String(step);
    input.value = String(value);
    input.className = 'rapier-range-input';

    if (sliderFirst) {
        const row = document.createElement('div');
        row.className = 'rapier-range-row';

        const helpWrap = document.createElement('div');
        helpWrap.className = 'rapier-range-helpwrap';
        if (showHelp) {
            appendHelp(helpWrap, help, helpSystem);
        }

        row.appendChild(input);
        if (showHelp) {
            row.appendChild(helpWrap);
        }
        row.appendChild(val);
        wrap.appendChild(row);
    } else {
        if (showLabel) {
            wrap.appendChild(head);
        }
        wrap.appendChild(input);
    }

    return { wrap, input, valEl: showLabel || sliderFirst ? val : null, fmt };
}

function makeInlineRangeNumberControl({
    title,
    min,
    max,
    step,
    value,
    fmt,
    help,
    helpSystem,
    sliderWidth = '140px',
    inputWidth = '110px'
}) {
    const wrap = document.createElement('div');
    wrap.className = 'rapier-inline-range';

    const row = document.createElement('div');
    row.className = 'rapier-inline-range-row';

    const label = document.createElement('div');
    label.textContent = title;
    label.className = 'rapier-inline-range-label';
    appendHelp(label, help, helpSystem);

    const controls = document.createElement('div');
    controls.className = 'rapier-inline-range-controls';

    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = String(min);
    slider.max = String(max);
    slider.step = String(step);
    slider.value = String(value);
    slider.className = 'rapier-inline-range-slider';

    const input = document.createElement('input');
    input.type = 'number';
    input.value = Number.isFinite(value) ? String(value) : '';
    input.inputMode = 'decimal';
    input.min = String(min);
    input.max = String(max);
    input.step = String(step);
    input.className = 'rapier-inline-range-number';

    const clampNum = (v) => Math.min(max, Math.max(min, v));
    const setBoth = (next, { from = null } = {}) => {
        if (!Number.isFinite(next)) return;
        const clamped = clampNum(next);
        if (from !== 'slider') slider.value = String(clamped);
        if (from !== 'input') input.value = String(clamped);
    };

    setBoth(Number(value));

    slider.addEventListener('input', () => {
        const next = parseFloat(slider.value);
        setBoth(next, { from: 'slider' });
        input.dispatchEvent(new Event('input', { bubbles: true }));
    });

    input.addEventListener('input', () => {
        const next = parseFloat(input.value);
        if (!Number.isFinite(next)) return;
        setBoth(next, { from: 'input' });
    });

    controls.appendChild(slider);
    controls.appendChild(input);
    row.appendChild(label);
    row.appendChild(controls);
    wrap.appendChild(row);

    return { wrap, input, slider, valEl: null, fmt };
}

function makeKnobControl({ title, min, max, step, value, fmt, help, helpSystem, inlineValue = false }) {
    const wrap = document.createElement('div');
    wrap.className = 'rapier-knob';

    const head = document.createElement('div');
    head.className = 'rapier-knob-head';
    head.classList.toggle('is-inline-value', inlineValue);

    const label = document.createElement('div');
    label.textContent = title;
    label.className = 'rapier-knob-label';
    let inlineVal = null;
    if (inlineValue) {
        inlineVal = document.createElement('span');
        inlineVal.className = 'rapier-knob-inline-val';
        inlineVal.textContent = fmt(value);
        label.appendChild(inlineVal);
    }
    appendHelp(label, help, helpSystem);

    const val = document.createElement('div');
    val.className = 'rapier-knob-val';
    val.textContent = fmt(value);

    head.appendChild(label);
    if (!inlineValue) {
        head.appendChild(val);
    }

    const track = document.createElement('div');
    track.className = 'rapier-knob-track';

    const line = document.createElement('div');
    line.className = 'rapier-knob-line';
    track.appendChild(line);

    const knob = document.createElement('div');
    knob.className = 'rapier-knob-dot';
    track.appendChild(knob);

    const input = document.createElement('input');
    input.type = 'range';
    input.min = String(min);
    input.max = String(max);
    input.step = String(step);
    input.value = String(value);
    input.className = 'rapier-knob-input';
    track.appendChild(input);

    const update = (next) => {
        const span = max - min;
        const t = span !== 0 ? (next - min) / span : 0;
        const clamped = Math.min(1, Math.max(0, t));
        knob.style.left = `${clamped * 100}%`;
        if (inlineVal) {
            inlineVal.textContent = fmt(next);
        } else {
            val.textContent = fmt(next);
        }
    };

    update(value);

    wrap.appendChild(head);
    wrap.appendChild(track);

    return { wrap, input, valEl: inlineVal ?? val, fmt, update };
}

function makeNumberControl({
    title,
    value,
    help,
    helpSystem,
    width = '120px',
    min = null,
    max = null,
    step = null,
    sliderWidth = null,
    controlsAlignRight = false
}) {
    const wrap = document.createElement('div');
    wrap.className = 'rapier-number';
    const scaledWidth = scalePx(width, 0.5);
    const hasMin = min !== null && min !== undefined && Number.isFinite(Number(min));
    const hasMax = max !== null && max !== undefined && Number.isFinite(Number(max));
    const hasStep = step !== null && step !== undefined && Number.isFinite(Number(step));
    const minValue = hasMin ? Number(min) : null;
    const maxValue = hasMax ? Number(max) : null;
    const stepValue = hasStep ? Math.abs(Number(step)) : 1;
    const valueNum = Number.isFinite(value) ? Number(value) : 0;
    const isForceLike = /\(n/i.test(String(title ?? ''));

    const row = document.createElement('div');
    row.className = 'rapier-number-row';
    row.classList.toggle('is-align-right', controlsAlignRight);

    const label = document.createElement('div');
    label.textContent = title;
    label.className = 'rapier-number-label';
    appendHelp(label, help, helpSystem);

    const slider = document.createElement('input');
    slider.type = 'range';
    slider.className = 'rapier-number-slider';
    slider.classList.toggle('is-fixed', !!sliderWidth);
    slider.step = String(stepValue);

    const autoRange = !(hasMin && hasMax);
    const computeAutoRange = (v) => {
        const base = Math.abs(Number.isFinite(v) ? v : 0);
        const span = isForceLike
            ? Math.max(stepValue * 10000, base * 1.5, 1000)
            : Math.max(stepValue * 200, base * 1.5, stepValue * 10, 1);
        const lo = hasMin ? Number(min) : (base === 0 ? -span : v - span);
        const hi = hasMax ? Number(max) : (base === 0 ? span : v + span);
        return { lo: Math.min(lo, hi), hi: Math.max(lo, hi) };
    };

    const syncSliderRange = (v) => {
        const range = computeAutoRange(v);
        slider.min = String(range.lo);
        slider.max = String(range.hi);
    };

    if (autoRange) syncSliderRange(valueNum);
    else {
        slider.min = String(min);
        slider.max = String(max);
    }

    const input = document.createElement('input');
    input.type = 'number';
    input.value = Number.isFinite(value) ? String(value) : '';
    input.inputMode = 'decimal';
    if (min !== null) input.min = String(min);
    if (max !== null) input.max = String(max);
    if (step !== null) input.step = String(step);
    input.className = 'rapier-number-input';
    if (typeof scaledWidth === 'string' && scaledWidth.endsWith('px')) {
        const px = Math.round(parseFloat(scaledWidth));
        if (Number.isFinite(px)) input.classList.add(`w-${px}`);
    }

    const setBoth = (next, { from = null } = {}) => {
        if (!Number.isFinite(next)) return;
        if (hasMin && next < minValue) next = minValue;
        if (hasMax && next > maxValue) next = maxValue;
        if (autoRange) {
            const currentMin = Number(slider.min);
            const currentMax = Number(slider.max);
            if (!Number.isFinite(currentMin) || !Number.isFinite(currentMax) || next < currentMin || next > currentMax) {
                syncSliderRange(next);
            }
        }
        if (from !== 'slider') slider.value = String(next);
        if (from !== 'input') input.value = String(next);
    };

    setBoth(valueNum);

    slider.addEventListener('input', () => {
        const next = parseFloat(slider.value);
        setBoth(next, { from: 'slider' });
        input.dispatchEvent(new Event('input', { bubbles: true }));
    });

    input.addEventListener('input', () => {
        const next = parseFloat(input.value);
        if (!Number.isFinite(next)) return;
        setBoth(next, { from: 'input' });
    });

    row.appendChild(label);

    if (controlsAlignRight) {
        const controls = document.createElement('div');
        controls.className = 'rapier-number-controls';
        controls.appendChild(slider);
        controls.appendChild(input);
        row.appendChild(controls);
    } else {
        row.appendChild(slider);
        row.appendChild(input);
    }

    wrap.appendChild(row);

    return { wrap, input, slider, valEl: null };
}

function makeInlineVector3Control({
    title,
    values,
    help,
    helpSystem,
    width = '76px',
    min = null,
    max = null,
    step = null
}) {
    const wrap = document.createElement('div');
    const scaledWidth = scalePx(width, 0.5);
    wrap.className = 'rapier-vec rapier-vec--stacked';

    const label = document.createElement('div');
    label.textContent = title;
    label.className = 'rapier-vec-title';
    appendHelp(label, help, helpSystem);
    wrap.appendChild(label);

    const row = document.createElement('div');
    row.className = 'rapier-vec-row';

    const makeAxis = (axis) => {
        const axisWrap = document.createElement('div');
        axisWrap.className = 'rapier-vec-axis';

        const axisLabel = document.createElement('div');
        axisLabel.textContent = axis.toUpperCase();
        axisLabel.className = 'rapier-vec-axis-label';

        const input = document.createElement('input');
        input.type = 'number';
        input.value = Number.isFinite(values?.[axis]) ? String(values[axis]) : '';
        input.inputMode = 'decimal';
        if (min !== null) input.min = String(min);
        if (max !== null) input.max = String(max);
        if (step !== null) input.step = String(step);
        input.className = 'rapier-number-input rapier-vec-input';
        if (typeof scaledWidth === 'string' && scaledWidth.endsWith('px')) {
            const px = Math.round(parseFloat(scaledWidth));
            if (Number.isFinite(px)) input.classList.add(`w-${px}`);
        }

        axisWrap.appendChild(axisLabel);
        axisWrap.appendChild(input);
        row.appendChild(axisWrap);
        return input;
    };

    const inputX = makeAxis('x');
    const inputY = makeAxis('y');
    const inputZ = makeAxis('z');

    wrap.appendChild(row);
    return { wrap, inputs: { x: inputX, y: inputY, z: inputZ } };
}

function makeInlineVector3Row({
    title,
    values,
    help,
    helpSystem,
    width = '76px',
    min = null,
    max = null,
    step = null
}) {
    const wrap = document.createElement('div');
    const scaledWidth = scalePx(width, 0.5);
    wrap.className = 'rapier-vec rapier-vec--inline';

    const row = document.createElement('div');
    row.className = 'rapier-vec-row rapier-vec-row--space';

    const label = document.createElement('div');
    label.textContent = title;
    label.className = 'rapier-vec-title rapier-vec-title--inline';
    appendHelp(label, help, helpSystem);

    const inputsRow = document.createElement('div');
    inputsRow.className = 'rapier-vec-inputs';

    const makeAxis = (axis) => {
        const axisWrap = document.createElement('div');
        axisWrap.className = 'rapier-vec-axis';

        const axisLabel = document.createElement('div');
        axisLabel.textContent = axis.toUpperCase();
        axisLabel.className = 'rapier-vec-axis-label';

        const input = document.createElement('input');
        input.type = 'number';
        input.value = Number.isFinite(values?.[axis]) ? String(values[axis]) : '';
        input.inputMode = 'decimal';
        if (min !== null) input.min = String(min);
        if (max !== null) input.max = String(max);
        if (step !== null) input.step = String(step);
        input.className = 'rapier-number-input rapier-vec-input';
        if (typeof scaledWidth === 'string' && scaledWidth.endsWith('px')) {
            const px = Math.round(parseFloat(scaledWidth));
            if (Number.isFinite(px)) input.classList.add(`w-${px}`);
        }

        axisWrap.appendChild(axisLabel);
        axisWrap.appendChild(input);
        inputsRow.appendChild(axisWrap);
        return input;
    };

    const inputX = makeAxis('x');
    const inputY = makeAxis('y');
    const inputZ = makeAxis('z');

    row.appendChild(label);
    row.appendChild(inputsRow);
    wrap.appendChild(row);

    return { wrap, inputs: { x: inputX, y: inputY, z: inputZ } };
}

function makeInlineValueRowWithButton({
    title,
    valueText,
    help,
    helpSystem,
    buttonLabel = '...'
}) {
    const wrap = document.createElement('div');
    wrap.className = 'rapier-inline-value';

    const row = document.createElement('div');
    row.className = 'rapier-inline-value-row';

    const label = document.createElement('div');
    label.textContent = title;
    label.className = 'rapier-inline-value-label';
    appendHelp(label, help, helpSystem);

    const value = document.createElement('div');
    value.textContent = valueText;
    value.className = 'rapier-inline-value-text';

    const button = document.createElement('button');
    button.type = 'button';
    button.textContent = buttonLabel;
    button.className = 'rapier-button is-small';

    row.appendChild(label);
    row.appendChild(value);
    row.appendChild(button);
    wrap.appendChild(row);

    return { wrap, valueEl: value, button };
}

function makeToggleControl({ title, value, help, helpSystem }) {
    const wrap = document.createElement('div');
    wrap.className = 'rapier-toggle';

    const row = document.createElement('div');
    row.className = 'rapier-toggle-row';

    const label = document.createElement('div');
    label.textContent = title;
    label.className = 'rapier-toggle-label';
    appendHelp(label, help, helpSystem);

    const input = document.createElement('input');
    input.type = 'checkbox';
    input.checked = !!value;
    input.className = 'rapier-toggle-input';

    row.appendChild(label);
    row.appendChild(input);
    wrap.appendChild(row);

    return { wrap, input, valEl: null };
}

function makeSelectControl({ title, value, options = [], help, helpSystem }) {
    const wrap = document.createElement('div');
    wrap.className = 'rapier-select';

    const row = document.createElement('div');
    row.className = 'rapier-select-row';

    const label = document.createElement('div');
    label.textContent = title;
    label.className = 'rapier-select-label';
    appendHelp(label, help, helpSystem);

    const select = document.createElement('select');
    select.className = 'rapier-select-input';

    for (const opt of options) {
        const option = document.createElement('option');
        option.value = String(opt.value);
        option.textContent = String(opt.label);
        select.appendChild(option);
    }
    if (value !== undefined && value !== null) {
        select.value = String(value);
    }

    row.appendChild(label);
    row.appendChild(select);
    wrap.appendChild(row);

    return { wrap, input: select, valEl: null };
}

function makeValueRow(label, { help = null, helpSystem = null, bar = false, arrow = false, dots = 0 } = {}) {
    const row = document.createElement('div');
    row.className = 'rapier-value-row';

    const key = document.createElement('div');
    key.textContent = label;
    key.className = 'rapier-value-key';
    appendHelp(key, help, helpSystem);

    const value = document.createElement('div');
    value.textContent = 'n/a';
    value.className = 'rapier-value-text';

    const valueWrap = document.createElement('div');
    valueWrap.className = 'rapier-value-wrap';

    const valueLine = document.createElement('div');
    valueLine.className = 'rapier-value-line';

    let arrowEl = null;
    if (arrow) {
        arrowEl = makeArrowMarker({ size: 14, color: 'rgba(233, 242, 255, 0.9)' });
        valueLine.appendChild(arrowEl);
    }

    valueLine.appendChild(value);
    valueWrap.appendChild(valueLine);

    let barFill = null;
    if (bar) {
        const barWrap = document.createElement('div');
        barWrap.className = 'rapier-value-bar';

        barFill = document.createElement('div');
        barFill.className = 'rapier-value-bar-fill';
        barWrap.appendChild(barFill);
        valueWrap.appendChild(barWrap);
    }

    let dotEls = null;
    if (dots > 0) {
        const dotWrap = document.createElement('div');
        dotWrap.className = 'rapier-value-dots';

        dotEls = [];
        for (let i = 0; i < dots; i++) {
            const dot = document.createElement('div');
            dot.className = 'rapier-value-dot';
            dotWrap.appendChild(dot);
            dotEls.push(dot);
        }
        valueWrap.appendChild(dotWrap);
    }

    row.appendChild(key);
    row.appendChild(valueWrap);
    return { row, valueEl: value, barEl: barFill, arrowEl, dotEls };
}

function makeArrowMarker({ size = 14 } = {}) {
    const arrow = document.createElement('div');
    arrow.className = 'rapier-arrow';
    if (size <= 12) arrow.classList.add('is-sm');
    if (size >= 18) arrow.classList.add('is-lg');

    const shaft = document.createElement('div');
    shaft.className = 'rapier-arrow-shaft';
    const head = document.createElement('div');
    head.className = 'rapier-arrow-head';

    arrow.appendChild(shaft);
    arrow.appendChild(head);
    return arrow;
}

function makeButton(label, { size = 'normal' } = {}) {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.textContent = label;
    btn.className = 'rapier-button';
    if (size === 'small') {
        btn.classList.add('is-small');
    }
    return btn;
}

function makeAxisLegend() {
    const wrap = document.createElement('div');
    wrap.className = 'rapier-axis-legend';

    const addItem = (label, colorClass) => {
        const row = document.createElement('div');
        row.className = 'rapier-axis-legend-item';

        const dot = document.createElement('span');
        dot.className = `rapier-axis-legend-dot ${colorClass}`;

        const text = document.createElement('span');
        text.textContent = label;

        row.appendChild(dot);
        row.appendChild(text);
        wrap.appendChild(row);
    };

    addItem('X', 'is-x');
    addItem('Y', 'is-y');
    addItem('Z', 'is-z');

    const camWrap = document.createElement('div');
    camWrap.className = 'rapier-axis-legend-camera-wrap';

    const camIcon = document.createElement('div');
    camIcon.className = 'rapier-axis-legend-camera';

    const camTop = document.createElement('div');
    camTop.className = 'rapier-axis-legend-camera-top';

    const camLens = document.createElement('div');
    camLens.className = 'rapier-axis-legend-camera-lens';

    camIcon.appendChild(camTop);
    camIcon.appendChild(camLens);

    const coords = document.createElement('div');
    coords.className = 'rapier-axis-legend-coords';
    coords.textContent = 'X:0.00  Y:0.00  Z:0.00';

    camWrap.appendChild(camIcon);
    camWrap.appendChild(coords);
    wrap.appendChild(camWrap);

    const toast = document.createElement('div');
    toast.className = 'rapier-axis-legend-toast';
    wrap.appendChild(toast);

    return { wrap, coordsEl: coords, camIcon, toastEl: toast };
}

const PRESET_TESTS = [
    {
        id: 'straight_brake',
        label: 'Test 1: Throttle + Brake',
        steps: [
            { duration: 1.2, input: { engineForce: 8000, brakeForce: 0, handbrakeForce: 0, steerAngle: 0 } },
            { duration: 3.6, input: { engineForce: 14000, brakeForce: 0, handbrakeForce: 0, steerAngle: 0 } },
            { duration: 2.0, input: { engineForce: 0, brakeForce: 12000, handbrakeForce: 0, steerAngle: 0 } },
            { duration: 1.2, input: { engineForce: 0, brakeForce: 0, handbrakeForce: 0, steerAngle: 0 } }
        ]
    },
    {
        id: 'steer_sweep',
        label: 'Test 2: Steer Sweep',
        steps: [
            { duration: 1.6, input: { engineForce: 9000, brakeForce: 0, handbrakeForce: 0, steerAngle: 0 } },
            { duration: 2.4, input: { engineForce: 9000, brakeForce: 0, handbrakeForce: 0, steerAngle: 0.35 } },
            { duration: 2.4, input: { engineForce: 9000, brakeForce: 0, handbrakeForce: 0, steerAngle: -0.35 } },
            { duration: 1.6, input: { engineForce: 0, brakeForce: 10000, handbrakeForce: 0, steerAngle: 0 } }
        ]
    },
    {
        id: 'handbrake_turn',
        label: 'Test 3: Handbrake Turn',
        steps: [
            { duration: 1.6, input: { engineForce: 10000, brakeForce: 0, handbrakeForce: 0, steerAngle: 0.25 } },
            { duration: 1.8, input: { engineForce: 10000, brakeForce: 0, handbrakeForce: 0, steerAngle: 0.45 } },
            { duration: 1.6, input: { engineForce: 0, brakeForce: 0, handbrakeForce: 14000, steerAngle: 0.45 } },
            { duration: 1.6, input: { engineForce: 0, brakeForce: 9000, handbrakeForce: 0, steerAngle: 0 } }
        ]
    }
];

export class RapierDebuggerUI {
    constructor({ vehicleConfig = null, tuning = null, worldConfig = null } = {}) {
        this._hudRoot = null;
        this._inputPanel = null;
        this._outputPanel = null;
        if (this._helpTooltip?.parentElement) {
            this._helpTooltip.parentElement.removeChild(this._helpTooltip);
        }
        this._helpTooltip = null;
        this._helpSystem = null;

        this._inputControls = {};
        this._outputRows = {};
        this._wheelCells = null;
        this._testButtons = [];
        this._actionButtons = [];
        this._statusText = null;
        this._copyButton = null;
        this._recordButton = null;
        this._recordLabel = null;
        this._axisLegendCoords = null;
        this._axisLegendCamIcon = null;
        this._axisLegendToast = null;
        this._axisToastTimer = null;
        this._recordDot = null;
        this._recordDotTimer = null;
        this._gravityDisplay = null;
        this._cameraPopup = null;
        this._cameraPopupHandlers = null;
        this._resetButton = null;
        this._resetButtonBorder = null;
        this._sleepMarker = null;
        this._wakeButton = null;
        this._sleepingState = null;
        this._gravityPopup = null;
        this._gravityPopupHandlers = null;
        this._positionPopup = null;
        this._positionPopupHandlers = null;
        this._comPopup = null;
        this._comPopupHandlers = null;
        this._positionPopupLiveEnabled = false;
        this._positionPopupLiveApply = null;
        this._positionPopupLiveNextAt = 0;
        this._positionPopupLiveInterval = null;
        this._positionPopupLiveIntervalMs = 0;
        this._positionPopupLiveShowTimer = null;
        this._positionPopupLiveHideTimer = null;
        this._positionPopupLiveStatus = null;
        this._positionPopupLiveProgressFill = null;
        this._positionPopupLiveProgressInterval = null;
        this._inertiaPopup = null;
        this._inertiaPopupHandlers = null;
        this._inertiaPopupFields = null;
        this._inertiaFramePopup = null;
        this._inertiaFramePopupHandlers = null;
        this._lockingPopup = null;
        this._lockingPopupHandlers = null;
        this._forcesPopup = null;
        this._forcesPopupHandlers = null;
        this._forcePopupControls = null;
        this._forcePopupButtons = null;
        this._forcesPopupGrid = null;
        this._forcesPopupLogCol = null;
        this._forcesPopupLogEl = null;
        this._forceActionLog = [];
        this._forceActionMax = 12;
        this._forceActionSeq = 0;
        this._forceApplyAtPoint = true;
        this._forcesActiveTab = 'force';
        this._testsPopup = null;
        this._testsPopupHandlers = null;
        this._testPopup = null;
        this._testPopupHandlers = null;
        this._testPopupTitle = null;
        this._testPopupButton = null;
        this._testPopupLabel = null;
        this._testPopupDot = null;
        this._testPopupCloseTimer = null;
        this._testPopupEllipsisTimer = null;
        this._liveResetIntervalMs = 3000;
        this._resetLiveDot = null;
        this._resetLiveInterval = null;
        this._resetLiveShowTimer = null;
        this._resetLiveHideTimer = null;
        this._resetLiveNextAt = 0;
        this._resetLiveBlinkTimer = null;
        this._resetLiveBlinkInterval = null;
        this._resetLiveBlinkTimer = null;
        this._resetLiveBlinkInterval = null;

        this._enabled = false;
        this._inputs = {
            engineForce: 0,
            brakeForce: 0,
            handbrakeForce: 0,
            steerAngle: 0
        };

        const baseWorldConfig = worldConfig ?? {};
        const baseGravity = baseWorldConfig.gravity ?? {};
        this._worldConfig = {
            gravity: {
                x: Number.isFinite(baseGravity.x) ? baseGravity.x : 0,
                y: Number.isFinite(baseGravity.y) ? baseGravity.y : -9.81,
                z: Number.isFinite(baseGravity.z) ? baseGravity.z : 0
            }
        };

        this._forces = {
            force: { x: 0, y: 0, z: 0 },
            forcePoint: { x: 0, y: 0, z: 0 },
            torque: { x: 0, y: 0, z: 0 },
            impulse: { x: 0, y: 0, z: 0 },
            impulsePoint: { x: 0, y: 0, z: 0 },
            torqueImpulse: { x: 0, y: 0, z: 0 }
        };

        const baseVehicleConfig = vehicleConfig ?? {};
        this._vehicleConfig = {
            width: Number.isFinite(baseVehicleConfig.width) ? baseVehicleConfig.width : 2.5,
            height: Number.isFinite(baseVehicleConfig.height) ? baseVehicleConfig.height : 3.0,
            length: Number.isFinite(baseVehicleConfig.length) ? baseVehicleConfig.length : 10.0,
            wheelRadius: Number.isFinite(baseVehicleConfig.wheelRadius) ? baseVehicleConfig.wheelRadius : 0.55,
            wheelWidth: Number.isFinite(baseVehicleConfig.wheelWidth) ? baseVehicleConfig.wheelWidth : 0.35,
            spawnHeight: Number.isFinite(baseVehicleConfig.spawnHeight) ? baseVehicleConfig.spawnHeight : 3,
            groundClearance: Number.isFinite(baseVehicleConfig.groundClearance) ? baseVehicleConfig.groundClearance : 0.24,
            restLength: Number.isFinite(baseVehicleConfig.restLength) ? baseVehicleConfig.restLength : 0.35,
            wheelbaseRatio: Number.isFinite(baseVehicleConfig.wheelbaseRatio) ? baseVehicleConfig.wheelbaseRatio : 0.65,
            wheelSideInset: Number.isFinite(baseVehicleConfig.wheelSideInset) ? baseVehicleConfig.wheelSideInset : 0.08
        };

        const baseTuning = tuning ?? {};
        const baseChassis = baseTuning.chassis ?? {};
        const baseProps = baseChassis.additionalMassProperties ?? {};
        const baseCom = baseProps.com ?? {};
        const baseInertia = baseProps.inertia ?? {};
        const baseFrame = baseProps.inertiaFrame ?? {};
        const baseTranslation = baseChassis.translation ?? {};
        const baseRotation = baseChassis.rotation ?? {};
        const baseLinvel = baseChassis.linvel ?? {};
        const baseAngvel = baseChassis.angvel ?? {};
        const baseEnabledRotations = baseChassis.enabledRotations ?? {};
        const spawnHeight = this._vehicleConfig.spawnHeight;
        this._tuning = {
            chassis: {
                bodyType: typeof baseChassis.bodyType === 'string' ? baseChassis.bodyType : 'dynamic',
                translation: {
                    x: Number.isFinite(baseTranslation.x) ? baseTranslation.x : 0,
                    y: Number.isFinite(baseTranslation.y) ? baseTranslation.y : spawnHeight,
                    z: Number.isFinite(baseTranslation.z) ? baseTranslation.z : 0
                },
                rotation: {
                    x: Number.isFinite(baseRotation.x) ? baseRotation.x : 0,
                    y: Number.isFinite(baseRotation.y) ? baseRotation.y : 0,
                    z: Number.isFinite(baseRotation.z) ? baseRotation.z : 0,
                    w: Number.isFinite(baseRotation.w) ? baseRotation.w : 1
                },
                linvel: {
                    x: Number.isFinite(baseLinvel.x) ? baseLinvel.x : 0,
                    y: Number.isFinite(baseLinvel.y) ? baseLinvel.y : 0,
                    z: Number.isFinite(baseLinvel.z) ? baseLinvel.z : 0
                },
                angvel: {
                    x: Number.isFinite(baseAngvel.x) ? baseAngvel.x : 0,
                    y: Number.isFinite(baseAngvel.y) ? baseAngvel.y : 0,
                    z: Number.isFinite(baseAngvel.z) ? baseAngvel.z : 0
                },
                additionalMass: Number.isFinite(baseChassis.additionalMass) ? baseChassis.additionalMass : 0,
                linearDamping: Number.isFinite(baseChassis.linearDamping) ? baseChassis.linearDamping : 0.32,
                angularDamping: Number.isFinite(baseChassis.angularDamping) ? baseChassis.angularDamping : 1.0,
                gravityScale: Number.isFinite(baseChassis.gravityScale) ? baseChassis.gravityScale : 1.0,
                canSleep: typeof baseChassis.canSleep === 'boolean' ? baseChassis.canSleep : true,
                ccdEnabled: typeof baseChassis.ccdEnabled === 'boolean' ? baseChassis.ccdEnabled : true,
                dominanceGroup: Number.isFinite(baseChassis.dominanceGroup) ? baseChassis.dominanceGroup : 0,
                lockTranslations: typeof baseChassis.lockTranslations === 'boolean' ? baseChassis.lockTranslations : false,
                lockRotations: typeof baseChassis.lockRotations === 'boolean' ? baseChassis.lockRotations : false,
                enabledRotations: {
                    x: typeof baseEnabledRotations.x === 'boolean' ? baseEnabledRotations.x : true,
                    y: typeof baseEnabledRotations.y === 'boolean' ? baseEnabledRotations.y : true,
                    z: typeof baseEnabledRotations.z === 'boolean' ? baseEnabledRotations.z : true
                },
                additionalMassProperties: {
                    inertiaMode: resolveInertiaMode(baseProps),
                    mass: Number.isFinite(baseProps.mass) ? baseProps.mass : NaN,
                    density: Number.isFinite(baseProps.density) ? baseProps.density : NaN,
                    com: {
                        x: Number.isFinite(baseCom.x) ? baseCom.x : 0,
                        y: Number.isFinite(baseCom.y) ? baseCom.y : 0,
                        z: Number.isFinite(baseCom.z) ? baseCom.z : 0
                    },
                    inertia: {
                        x: Number.isFinite(baseInertia.x) ? baseInertia.x : 0.3,
                        y: Number.isFinite(baseInertia.y) ? baseInertia.y : 0.2,
                        z: Number.isFinite(baseInertia.z) ? baseInertia.z : 0.1
                    },
                    inertiaFrame: {
                        w: Number.isFinite(baseFrame.w) ? baseFrame.w : 1,
                        x: Number.isFinite(baseFrame.x) ? baseFrame.x : 0,
                        y: Number.isFinite(baseFrame.y) ? baseFrame.y : 0,
                        z: Number.isFinite(baseFrame.z) ? baseFrame.z : 0
                    }
                }
            },
            suspension: {
                maxTravel: Number.isFinite(baseTuning.suspension?.maxTravel) ? baseTuning.suspension.maxTravel : 0.2,
                stiffness: Number.isFinite(baseTuning.suspension?.stiffness) ? baseTuning.suspension.stiffness : 500,
                compression: Number.isFinite(baseTuning.suspension?.compression) ? baseTuning.suspension.compression : 1.0,
                relaxation: Number.isFinite(baseTuning.suspension?.relaxation) ? baseTuning.suspension.relaxation : 1.0,
                maxForce: Number.isFinite(baseTuning.suspension?.maxForce) ? baseTuning.suspension.maxForce : 10000
            },
            tires: {
                frictionSlip: Number.isFinite(baseTuning.tires?.frictionSlip) ? baseTuning.tires.frictionSlip : 8.2,
                sideFrictionStiffness: Number.isFinite(baseTuning.tires?.sideFrictionStiffness) ? baseTuning.tires.sideFrictionStiffness : 1.45
            }
        };

        this._recomputeAutoInertia();

        this.onReset = null;
        this.onResetCamera = null;
        this.onWheelHover = null;
        this.onAddForce = null;
        this.onAddForceAtPoint = null;
        this.onAddTorque = null;
        this.onResetForces = null;
        this.onResetTorques = null;
        this.onApplyImpulse = null;
        this.onApplyImpulseAtPoint = null;
        this.onApplyTorqueImpulse = null;
        this.onResetVelocities = null;
        this.onWakeUp = null;
        this.onSleep = null;
        this.onComPreview = null;

        this._activeTest = null;
        this._testElapsed = 0;
        this._stepElapsed = 0;
        this._testStepIndex = 0;
        this._telemetry = null;
        this._telemetryMeta = null;
        this._sampleRecording = false;
        this._sampleElapsed = 0;
        this._sampleFrames = null;
        this._sampleConfig = null;
    }

    mount() {
        if (this._hudRoot) return;
        this._buildHud();
        this.setEnabled(false);
    }

    unmount() {
        if (this._hudRoot?.parentElement) {
            this._hudRoot.parentElement.removeChild(this._hudRoot);
        }
        this._hudRoot = null;
        this._inputPanel = null;
        this._outputPanel = null;
        this._inputControls = {};
        this._outputRows = {};
        this._wheelCells = null;
        this._testButtons = [];
        this._actionButtons = [];
        this._statusText = null;
        this._copyButton = null;
        this._recordButton = null;
        this._recordLabel = null;
        if (this._helpTooltip?.parentElement) {
            this._helpTooltip.parentElement.removeChild(this._helpTooltip);
        }
        this._helpTooltip = null;
        this._helpSystem = null;
        this._axisLegendCoords = null;
        this._axisLegendToast = null;
        if (this._axisToastTimer) {
            clearTimeout(this._axisToastTimer);
            this._axisToastTimer = null;
        }
        this._recordDot = null;
        if (this._recordDotTimer) {
            clearTimeout(this._recordDotTimer);
            this._recordDotTimer = null;
        }
        this._resetButton = null;
        this._resetButtonBorder = null;
        this._gravityDisplay = null;
        this._closeGravityPopup();
        this._closePositionPopup();
        this._closeCameraPopup();
        this._closeComPopup();
        this._stopLiveReset();
        this._closeInertiaPopup();
        this._closeInertiaFramePopup();
        this._closeLockingPopup();
        this._closeForcesPopup();
        this._closeTestsPopup();
        this._closeTestPopup();
        this._forcePopupControls = null;
        this._forcePopupButtons = null;
        this._forcesPopupGrid = null;
        this._forcesPopupLogCol = null;
        this._forcesPopupLogEl = null;
        this._forceActionLog = [];
        this._forceActionSeq = 0;
        this._forceApplyAtPoint = true;
        this._forcesActiveTab = 'force';
        this._testsPopup = null;
        this._testsPopupHandlers = null;
        this._testPopup = null;
        this._testPopupHandlers = null;
        this._testPopupTitle = null;
        this._testPopupButton = null;
        this._testPopupLabel = null;
        this._testPopupDot = null;
        this._testPopupCloseTimer = null;
        this._testPopupEllipsisTimer = null;
        this._sleepMarker = null;
        this._wakeButton = null;
        this._sleepingState = null;
        this._inertiaAutoPill = null;
        this._inertiaModeNote = null;
        this._comButton = null;
        this._inertiaButton = null;
        this._comPopup = null;
        this._comPopupHandlers = null;
        this._positionPopupLiveEnabled = false;
        this._positionPopupLiveApply = null;
        this._positionPopupLiveNextAt = 0;
        this._positionPopupLiveInterval = null;
        this._positionPopupLiveIntervalMs = 0;
        this._positionPopupLiveShowTimer = null;
        this._positionPopupLiveHideTimer = null;
        this._positionPopupLiveStatus = null;
        this._positionPopupLiveProgressFill = null;
        this._positionPopupLiveProgressInterval = null;
        this._resetLiveDot = null;
        this._resetLiveInterval = null;
        this._resetLiveShowTimer = null;
        this._resetLiveHideTimer = null;
        this._resetLiveNextAt = 0;
        this._activeTest = null;
        this._telemetry = null;
        this._telemetryMeta = null;
        this._sampleRecording = false;
        this._sampleElapsed = 0;
        this._sampleFrames = null;
        this._sampleConfig = null;
    }

    setEnabled(enabled) {
        this._enabled = !!enabled;
        for (const control of Object.values(this._inputControls)) {
            if (control?.input) {
                control.input.disabled = !this._enabled || !!this._activeTest;
            }
        }
        for (const btn of this._testButtons) {
            if (!btn) continue;
            btn.disabled = !this._enabled || !!this._activeTest;
        }
        for (const btn of this._actionButtons) {
            if (!btn) continue;
            btn.disabled = !this._enabled || !!this._activeTest;
        }
        if (this._recordButton) {
            this._recordButton.disabled = !this._enabled || !!this._activeTest || this._sampleRecording;
        }
        if (this._statusText && !this._activeTest) {
            this._statusText.textContent = '';
        }
    }

    setCameraCoords(pos) {
        if (!this._axisLegendCoords) return;
        if (!pos || !Number.isFinite(pos.x) || !Number.isFinite(pos.y) || !Number.isFinite(pos.z)) {
            this._axisLegendCoords.textContent = 'X:n/a  Y:n/a  Z:n/a';
            return;
        }
        this._axisLegendCoords.textContent = `X:${formatNum(pos.x, 2)}  Y:${formatNum(pos.y, 2)}  Z:${formatNum(pos.z, 2)}`;
    }

    _showAxisToast(message, duration = 2000) {
        if (!this._axisLegendToast) return;
        this._axisLegendToast.textContent = message;
        this._axisLegendToast.classList.add('is-visible');
        if (this._axisToastTimer) {
            clearTimeout(this._axisToastTimer);
        }
        this._axisToastTimer = window.setTimeout(() => {
            if (this._axisLegendToast) {
                this._axisLegendToast.classList.remove('is-visible');
            }
            this._axisToastTimer = null;
        }, duration);
    }

    _openCameraPopup(anchor) {
        this._closeCameraPopup();
        if (!this._hudRoot || !anchor) return;

        const { wrap } = makePopupWrap({ title: 'Camera', onClose: () => this._closeCameraPopup() });

        const topSeparator = makeSeparator();
        topSeparator.classList.add('rapier-separator-tight');
        wrap.appendChild(topSeparator);

        const resetCameraButton = makeButton('Reset camera');
        resetCameraButton.classList.add('is-popup');
        resetCameraButton.addEventListener('click', () => {
            this.onResetCamera?.();
            this._closeCameraPopup();
        });
        wrap.appendChild(resetCameraButton);

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const left = Math.min(window.innerWidth - 200, Math.max(pad, rect.left - 80));
        const top = Math.min(window.innerHeight - 120, Math.max(pad, rect.top - 50));
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closeCameraPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeCameraPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._cameraPopup = wrap;
        this._cameraPopupHandlers = { onPointerDown, onKeyDown };
    }

    _closeCameraPopup() {
        if (this._cameraPopup?.parentElement) {
            this._cameraPopup.parentElement.removeChild(this._cameraPopup);
        }
        if (this._cameraPopupHandlers) {
            document.removeEventListener('pointerdown', this._cameraPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._cameraPopupHandlers.onKeyDown);
        }
        this._cameraPopup = null;
        this._cameraPopupHandlers = null;
    }

    _openGravityPopup(anchor) {
        this._closeGravityPopup();
        if (!this._hudRoot || !anchor) return;

        const { wrap } = makePopupWrap({ title: 'Gravity', onClose: () => this._closeGravityPopup(), classes: ['is-narrow'] });

        const topSeparator = makeSeparator();
        topSeparator.classList.add('rapier-separator-tight');
        wrap.appendChild(topSeparator);

        const makeField = (axis, value) => {
            const row = document.createElement('div');
            row.className = 'rapier-popup-field-row';

            const label = document.createElement('div');
            label.textContent = axis;
            label.className = 'rapier-popup-field-axis';

            const input = document.createElement('input');
            input.type = 'number';
            input.inputMode = 'decimal';
            input.step = '0.1';
            input.value = Number.isFinite(value) ? String(value) : '';
            input.className = 'rapier-popup-number-input';

            row.appendChild(label);
            row.appendChild(input);
            wrap.appendChild(row);
            return input;
        };

        const initialGravity = {
            x: this._worldConfig.gravity?.x ?? 0,
            y: this._worldConfig.gravity?.y ?? -9.81,
            z: this._worldConfig.gravity?.z ?? 0
        };

        const inputs = {
            x: makeField('X', initialGravity.x),
            y: makeField('Y', initialGravity.y),
            z: makeField('Z', initialGravity.z)
        };

        const wireLive = (inputEl, key) => {
            inputEl.addEventListener('input', () => {
                const value = parseFloat(inputEl.value);
                if (Number.isFinite(value)) this._setInputValue(key, value);
            });
        };
        wireLive(inputs.x, 'worldGravityX');
        wireLive(inputs.y, 'worldGravityY');
        wireLive(inputs.z, 'worldGravityZ');

        const actions = document.createElement('div');
        actions.className = 'rapier-popup-actions';

        const separator = makeSeparator();
        separator.classList.add('rapier-separator-tight');
        wrap.appendChild(separator);

        const reset = makeButton('Reset');
        reset.classList.add('is-popup');
        reset.addEventListener('click', () => {
            inputs.x.value = String(initialGravity.x);
            inputs.y.value = String(initialGravity.y);
            inputs.z.value = String(initialGravity.z);
            this._setInputValue('worldGravityX', initialGravity.x);
            this._setInputValue('worldGravityY', initialGravity.y);
            this._setInputValue('worldGravityZ', initialGravity.z);
        });

        actions.appendChild(reset);
        wrap.appendChild(actions);

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const popupWidth = 210;
        const left = Math.min(window.innerWidth - popupWidth - pad, Math.max(pad, rect.right + pad));
        const top = Math.min(window.innerHeight - 180, Math.max(pad, rect.top - 8));
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closeGravityPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeGravityPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._gravityPopup = wrap;
        this._gravityPopupHandlers = { onPointerDown, onKeyDown };
    }

    _closeGravityPopup() {
        if (this._gravityPopup?.parentElement) {
            this._gravityPopup.parentElement.removeChild(this._gravityPopup);
        }
        if (this._gravityPopupHandlers) {
            document.removeEventListener('pointerdown', this._gravityPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._gravityPopupHandlers.onKeyDown);
        }
        this._gravityPopup = null;
        this._gravityPopupHandlers = null;
    }

    _updateGravityDisplay() {
        if (!this._gravityDisplay) return;
        const g = this._worldConfig.gravity ?? {};
        const gx = Number.isFinite(g.x) ? formatNum(g.x, 2) : 'n/a';
        const gy = Number.isFinite(g.y) ? formatNum(g.y, 2) : 'n/a';
        const gz = Number.isFinite(g.z) ? formatNum(g.z, 2) : 'n/a';
        this._gravityDisplay.textContent = `${gx}  ${gy}  ${gz}`;
    }

    _openPositionPopup(anchor, { resetOnApply = false } = {}) {
        this._closePositionPopup();
        if (!this._hudRoot || !anchor) return;

        const { wrap } = makePopupWrap({ title: 'Reset', onClose: () => this._closePositionPopup(), classes: ['is-wide'] });

        const topSeparator = makeSeparator();
        topSeparator.classList.add('rapier-separator-tight');
        wrap.appendChild(topSeparator);

        const helpSystem = this._helpSystem;

        const makeTableInput = (value, step = 0.1) => {
            const input = document.createElement('input');
            input.type = 'number';
            input.inputMode = 'decimal';
            input.step = String(step);
            input.value = Number.isFinite(value) ? String(value) : '';
            input.className = 'rapier-popup-table-input';
            return input;
        };

        const makeTableSlider = (value, { min, max, step }) => {
            const slider = document.createElement('input');
            slider.type = 'range';
            slider.min = String(min);
            slider.max = String(max);
            slider.step = String(step);
            const startValue = Number.isFinite(value) ? Math.min(max, Math.max(min, value)) : 0;
            slider.value = String(startValue);
            slider.className = 'rapier-popup-table-slider';
            return slider;
        };

        const makeHeaderCell = (text) => {
            const cell = document.createElement('div');
            cell.textContent = text;
            cell.className = 'rapier-popup-table-header';
            return cell;
        };

        const makeLabelCell = (text, help) => {
            const cell = document.createElement('div');
            cell.className = 'rapier-popup-table-label';
            const textSpan = document.createElement('div');
            textSpan.textContent = text;
            textSpan.className = 'rapier-popup-table-label-text';
            cell.appendChild(textSpan);
            if (help && helpSystem) {
                appendHelp(cell, help, helpSystem);
            }
            return cell;
        };

        const makeEmptyCell = () => {
            const cell = document.createElement('div');
            cell.className = 'rapier-popup-table-empty';
            return cell;
        };

        const makeInputCell = (value, { min, max, step }) => {
            const cell = document.createElement('div');
            cell.className = 'rapier-popup-table-inputcell';
            const input = makeTableInput(value, step);
            const slider = makeTableSlider(value, { min, max, step });
            input.addEventListener('input', () => {
                const next = parseFloat(input.value);
                if (!Number.isFinite(next)) return;
                const clamped = Math.min(max, Math.max(min, next));
                slider.value = String(clamped);
            });
            slider.addEventListener('input', () => {
                input.value = slider.value;
            });
            cell.appendChild(input);
            cell.appendChild(slider);
            return { cell, input, slider };
        };

        const table = document.createElement('div');
        table.className = 'rapier-position-table';

        table.appendChild(makeHeaderCell(''));
        table.appendChild(makeHeaderCell('W'));
        table.appendChild(makeHeaderCell('X'));
        table.appendChild(makeHeaderCell('Y'));
        table.appendChild(makeHeaderCell('Z'));

        const rot = this._tuning?.chassis?.rotation ?? {};
        const rotInputs = {
            w: makeInputCell(rot.w, { min: -1, max: 1, step: 0.01 }),
            x: makeInputCell(rot.x, { min: -1, max: 1, step: 0.01 }),
            y: makeInputCell(rot.y, { min: -1, max: 1, step: 0.01 }),
            z: makeInputCell(rot.z, { min: -1, max: 1, step: 0.01 })
        };
        table.appendChild(makeLabelCell('Rotation', INPUT_HELP.rotation));
        table.appendChild(rotInputs.w.cell);
        table.appendChild(rotInputs.x.cell);
        table.appendChild(rotInputs.y.cell);
        table.appendChild(rotInputs.z.cell);

        const pos = this._tuning?.chassis?.translation ?? {};
        const posInputs = {
            x: makeInputCell(pos.x, { min: -50, max: 50, step: 0.1 }),
            y: makeInputCell(pos.y, { min: -50, max: 50, step: 0.1 }),
            z: makeInputCell(pos.z, { min: -50, max: 50, step: 0.1 })
        };
        table.appendChild(makeLabelCell('Position', INPUT_HELP.translation));
        table.appendChild(makeEmptyCell());
        table.appendChild(posInputs.x.cell);
        table.appendChild(posInputs.y.cell);
        table.appendChild(posInputs.z.cell);

        const linvel = this._tuning?.chassis?.linvel ?? {};
        const linvelInputs = {
            x: makeInputCell(linvel.x, { min: -50, max: 50, step: 0.1 }),
            y: makeInputCell(linvel.y, { min: -50, max: 50, step: 0.1 }),
            z: makeInputCell(linvel.z, { min: -50, max: 50, step: 0.1 })
        };
        table.appendChild(makeLabelCell('Linear velocity (m/s)', INPUT_HELP.linvel));
        table.appendChild(makeEmptyCell());
        table.appendChild(linvelInputs.x.cell);
        table.appendChild(linvelInputs.y.cell);
        table.appendChild(linvelInputs.z.cell);

        const angvel = this._tuning?.chassis?.angvel ?? {};
        const angvelInputs = {
            x: makeInputCell(angvel.x, { min: -20, max: 20, step: 0.1 }),
            y: makeInputCell(angvel.y, { min: -20, max: 20, step: 0.1 }),
            z: makeInputCell(angvel.z, { min: -20, max: 20, step: 0.1 })
        };
        table.appendChild(makeLabelCell('Angular velocity (rad/s)', INPUT_HELP.angvel));
        table.appendChild(makeEmptyCell());
        table.appendChild(angvelInputs.x.cell);
        table.appendChild(angvelInputs.y.cell);
        table.appendChild(angvelInputs.z.cell);

        wrap.appendChild(table);

        const applyValues = ({ reset = false, close = false } = {}) => {
            const resolveVelocityInput = (cell) => {
                const raw = parseFloat(cell.input.value);
                const min = Number.parseFloat(cell.slider.min);
                const max = Number.parseFloat(cell.slider.max);
                const next = Number.isFinite(raw) ? raw : 0;
                const clamped = Math.min(max, Math.max(min, next));
                cell.input.value = String(clamped);
                cell.slider.value = String(clamped);
                return clamped;
            };
            const px = parseFloat(posInputs.x.input.value);
            const py = parseFloat(posInputs.y.input.value);
            const pz = parseFloat(posInputs.z.input.value);
            if (Number.isFinite(px)) this._setInputValue('translationX', px);
            if (Number.isFinite(py)) this._setInputValue('spawnHeight', py);
            if (Number.isFinite(pz)) this._setInputValue('translationZ', pz);
            const rw = parseFloat(rotInputs.w.input.value);
            const rx = parseFloat(rotInputs.x.input.value);
            const ry = parseFloat(rotInputs.y.input.value);
            const rz = parseFloat(rotInputs.z.input.value);
            if (Number.isFinite(rw)) this._setInputValue('rotationW', rw);
            if (Number.isFinite(rx)) this._setInputValue('rotationX', rx);
            if (Number.isFinite(ry)) this._setInputValue('rotationY', ry);
            if (Number.isFinite(rz)) this._setInputValue('rotationZ', rz);
            const lvx = resolveVelocityInput(linvelInputs.x);
            const lvy = resolveVelocityInput(linvelInputs.y);
            const lvz = resolveVelocityInput(linvelInputs.z);
            this._setInputValue('linvelX', lvx);
            this._setInputValue('linvelY', lvy);
            this._setInputValue('linvelZ', lvz);
            const avx = resolveVelocityInput(angvelInputs.x);
            const avy = resolveVelocityInput(angvelInputs.y);
            const avz = resolveVelocityInput(angvelInputs.z);
            this._setInputValue('angvelX', avx);
            this._setInputValue('angvelY', avy);
            this._setInputValue('angvelZ', avz);
            if (reset) this._resetInitialPosition();
            if (close) this._closePositionPopup();
        };

        const actions = document.createElement('div');
        actions.className = 'rapier-position-actions';

        const liveWrap = document.createElement('label');
        liveWrap.className = 'rapier-live-toggle';

        const liveCheckbox = document.createElement('input');
        liveCheckbox.type = 'checkbox';
        liveCheckbox.className = 'rapier-live-checkbox';

        const liveTrack = document.createElement('span');
        liveTrack.className = 'rapier-live-track';

        const liveKnob = document.createElement('span');
        liveKnob.className = 'rapier-live-knob';

        liveTrack.appendChild(liveKnob);

        const liveIntervalMs = this._liveResetIntervalMs;
        const liveIntervalSeconds = formatNum(liveIntervalMs / 1000, liveIntervalMs % 1000 === 0 ? 0 : 1);

        const liveLabel = document.createElement('span');
        liveLabel.textContent = 'Live';
        liveLabel.className = 'rapier-live-label';
        appendHelp(
            liveLabel,
            `Auto-reset the vehicle using the current reset configuration every ${liveIntervalSeconds}s. Live stays active after closing this panel; the Reset button shows a green border while active.`,
            this._helpSystem
        );

        const syncLiveToggle = () => {
            liveWrap.classList.toggle('is-on', liveCheckbox.checked);
        };

        liveCheckbox.checked = this._positionPopupLiveEnabled;
        syncLiveToggle();
        liveWrap.appendChild(liveCheckbox);
        liveWrap.appendChild(liveTrack);
        liveWrap.appendChild(liveLabel);

        const liveStatus = document.createElement('span');
        liveStatus.className = 'rapier-live-status hidden';

        const liveStatusFill = document.createElement('span');
        liveStatusFill.className = 'rapier-live-status-fill';
        liveStatus.appendChild(liveStatusFill);

        this._positionPopupLiveStatus = liveStatus;
        this._positionPopupLiveProgressFill = liveStatusFill;

        const intervalWrap = document.createElement('div');
        intervalWrap.className = 'rapier-live-interval';

        const intervalLabel = document.createElement('span');
        intervalLabel.textContent = 'Interval';

        const intervalSlider = document.createElement('input');
        intervalSlider.type = 'range';
        intervalSlider.min = '1';
        intervalSlider.max = '30';
        intervalSlider.step = '1';
        intervalSlider.value = String(Math.min(30, Math.max(1, Math.round(liveIntervalMs / 1000))));
        intervalSlider.className = 'rapier-live-interval-slider';

        const intervalValue = document.createElement('span');
        intervalValue.textContent = `${intervalSlider.value}s`;

        intervalSlider.addEventListener('input', () => {
            const seconds = parseFloat(intervalSlider.value);
            if (!Number.isFinite(seconds)) return;
            this._liveResetIntervalMs = Math.max(1, seconds) * 1000;
            intervalValue.textContent = `${intervalSlider.value}s`;
            if (this._positionPopupLiveEnabled) {
                this._rescheduleLiveReset();
            }
        });

        intervalWrap.appendChild(intervalLabel);
        intervalWrap.appendChild(intervalSlider);
        intervalWrap.appendChild(intervalValue);

        const liveGroup = document.createElement('div');
        liveGroup.className = 'rapier-live-group';
        liveGroup.appendChild(liveWrap);
        liveGroup.appendChild(intervalWrap);
        liveGroup.appendChild(liveStatus);

        liveCheckbox.addEventListener('change', () => {
            syncLiveToggle();
            if (liveCheckbox.checked) {
                this._startLiveReset(applyValues, { showToast: true });
            } else {
                this._stopLiveReset();
            }
        });

        if (this._positionPopupLiveEnabled) {
            this._positionPopupLiveApply = applyValues;
            if (!this._positionPopupLiveInterval) {
                this._startLiveReset(applyValues);
            } else {
                this._setResetLiveActive(true);
                this._startLiveProgressTicker();
            }
        }

        const cancel = makeButton('Cancel');
        cancel.classList.add('is-popup');
        cancel.addEventListener('click', () => {
            liveCheckbox.checked = false;
            syncLiveToggle();
            this._stopLiveReset();
            this._closePositionPopup();
        });

        const apply = makeButton('Apply');
        apply.classList.add('is-popup');
        apply.addEventListener('click', () => {
            applyValues({ reset: resetOnApply, close: true });
        });

        const buttonsSeparator = makeSeparator();
        buttonsSeparator.classList.add('rapier-separator-tight');
        wrap.appendChild(buttonsSeparator);

        const buttons = document.createElement('div');
        buttons.className = 'rapier-popup-buttons';
        buttons.appendChild(cancel);
        buttons.appendChild(apply);

        actions.appendChild(liveGroup);
        actions.appendChild(buttons);
        wrap.appendChild(actions);

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const left = Math.min(window.innerWidth - 560, Math.max(pad, rect.right + pad));
        const top = Math.min(window.innerHeight - 360, Math.max(pad, rect.top - 8));
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closePositionPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closePositionPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._positionPopup = wrap;
        this._positionPopupHandlers = { onPointerDown, onKeyDown };
    }

    _closePositionPopup() {
        if (this._positionPopup?.parentElement) {
            this._positionPopup.parentElement.removeChild(this._positionPopup);
        }
        if (this._positionPopupHandlers) {
            document.removeEventListener('pointerdown', this._positionPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._positionPopupHandlers.onKeyDown);
        }
        if (this._positionPopupLiveShowTimer) {
            clearTimeout(this._positionPopupLiveShowTimer);
            this._positionPopupLiveShowTimer = null;
        }
        if (this._positionPopupLiveHideTimer) {
            clearTimeout(this._positionPopupLiveHideTimer);
            this._positionPopupLiveHideTimer = null;
        }
        if (this._positionPopupLiveProgressInterval) {
            clearInterval(this._positionPopupLiveProgressInterval);
            this._positionPopupLiveProgressInterval = null;
        }
        if (this._positionPopupLiveStatus) {
            this._positionPopupLiveStatus.classList.add('hidden');
        }
        if (!this._positionPopupLiveEnabled) {
            this._stopLiveReset();
        }
        this._positionPopup = null;
        this._positionPopupHandlers = null;
        this._positionPopupLiveStatus = null;
        this._positionPopupLiveProgressFill = null;
    }

    _getLiveResetIntervalMs() {
        return this._liveResetIntervalMs ?? 3000;
    }

    _rescheduleLiveReset({ showToast = false } = {}) {
        if (!this._positionPopupLiveEnabled || !this._positionPopupLiveApply) return;
        const intervalMs = this._getLiveResetIntervalMs();
        if (intervalMs <= 0) return;

        if (this._positionPopupLiveInterval) {
            clearInterval(this._positionPopupLiveInterval);
            this._positionPopupLiveInterval = null;
        }
        if (this._positionPopupLiveShowTimer) {
            clearTimeout(this._positionPopupLiveShowTimer);
            this._positionPopupLiveShowTimer = null;
        }
        if (this._positionPopupLiveHideTimer) {
            clearTimeout(this._positionPopupLiveHideTimer);
            this._positionPopupLiveHideTimer = null;
        }

        this._positionPopupLiveIntervalMs = intervalMs;
        this._positionPopupLiveNextAt = performance.now() + intervalMs;
        this._startLiveProgressTicker();
        this._updateLiveProgress();
        this._startResetLiveIndicator();

        if (showToast) {
            const seconds = formatNum(intervalMs / 1000, intervalMs % 1000 === 0 ? 0 : 1);
            this._showAxisToast(`Live reset enabled: reset in ${seconds}s`);
        }

        this._positionPopupLiveInterval = window.setInterval(() => {
            this._positionPopupLiveApply?.({ reset: true, close: false });
            const nextIntervalMs = this._getLiveResetIntervalMs();
            if (nextIntervalMs !== this._positionPopupLiveIntervalMs) {
                this._rescheduleLiveReset();
                return;
            }
            this._positionPopupLiveNextAt = performance.now() + nextIntervalMs;
            this._updateLiveProgress();
            this._startResetLiveIndicator();
        }, intervalMs);
    }

    _startLiveReset(applyValues, { showToast = false } = {}) {
        this._positionPopupLiveEnabled = true;
        this._positionPopupLiveApply = applyValues ?? this._positionPopupLiveApply;

        this._setResetLiveActive(true);
        if (this._resetLiveDot) {
            this._resetLiveDot.classList.add('is-visible');
        }

        this._rescheduleLiveReset({ showToast });
    }

    _stopLiveReset() {
        this._positionPopupLiveEnabled = false;
        this._positionPopupLiveApply = null;
        this._positionPopupLiveNextAt = 0;
        this._positionPopupLiveIntervalMs = 0;
        this._setResetLiveActive(false);
        if (this._positionPopupLiveInterval) {
            clearInterval(this._positionPopupLiveInterval);
            this._positionPopupLiveInterval = null;
        }
        if (this._positionPopupLiveShowTimer) {
            clearTimeout(this._positionPopupLiveShowTimer);
            this._positionPopupLiveShowTimer = null;
        }
        if (this._positionPopupLiveHideTimer) {
            clearTimeout(this._positionPopupLiveHideTimer);
            this._positionPopupLiveHideTimer = null;
        }
        if (this._positionPopupLiveProgressInterval) {
            clearInterval(this._positionPopupLiveProgressInterval);
            this._positionPopupLiveProgressInterval = null;
        }
        if (this._positionPopupLiveStatus) {
            this._positionPopupLiveStatus.classList.add('hidden');
        }
        if (this._positionPopupLiveProgressFill) {
            this._positionPopupLiveProgressFill.style.width = '0%';
            this._positionPopupLiveProgressFill.style.backgroundPosition = '100% 50%';
        }
        this._stopResetLiveIndicator();
    }

    _startLiveProgressTicker() {
        if (this._positionPopupLiveProgressInterval) {
            clearInterval(this._positionPopupLiveProgressInterval);
            this._positionPopupLiveProgressInterval = null;
        }
        if (!this._positionPopupLiveStatus || !this._positionPopupLiveProgressFill) return;
        this._positionPopupLiveStatus.classList.remove('hidden');
        this._updateLiveProgress();
        this._positionPopupLiveProgressInterval = window.setInterval(() => {
            if (!this._positionPopupLiveEnabled) return;
            this._updateLiveProgress();
        }, 80);
    }

    _updateLiveProgress() {
        if (!this._positionPopupLiveProgressFill) return;
        const intervalMs = this._positionPopupLiveIntervalMs || this._getLiveResetIntervalMs();
        const now = performance.now();
        if (!Number.isFinite(intervalMs) || intervalMs <= 0 || !Number.isFinite(this._positionPopupLiveNextAt)) {
            this._positionPopupLiveProgressFill.style.width = '0%';
            return;
        }
        const remaining = Math.max(0, this._positionPopupLiveNextAt - now);
        const t = Math.max(0, Math.min(1, remaining / intervalMs));
        const percent = Math.round(t * 100);
        this._positionPopupLiveProgressFill.style.width = `${percent}%`;
        const phase = Math.round(now / 40) % 200;
        this._positionPopupLiveProgressFill.style.backgroundPosition = `${100 - phase}% 50%`;
    }

    _startResetLiveIndicator() {
        if (!this._resetLiveDot) return;
        this._resetLiveDot.classList.add('is-visible');
        if (this._resetLiveBlinkTimer) {
            clearTimeout(this._resetLiveBlinkTimer);
            this._resetLiveBlinkTimer = null;
        }
        if (this._resetLiveBlinkInterval) {
            clearInterval(this._resetLiveBlinkInterval);
            this._resetLiveBlinkInterval = null;
        }
    }

    _setResetLiveActive(active) {
        if (!this._resetButton) return;
        this._resetButton.classList.toggle('is-live', active);
    }

    _stopResetLiveIndicator() {
        if (this._resetLiveInterval) {
            clearInterval(this._resetLiveInterval);
            this._resetLiveInterval = null;
        }
        if (this._resetLiveShowTimer) {
            clearTimeout(this._resetLiveShowTimer);
            this._resetLiveShowTimer = null;
        }
        if (this._resetLiveHideTimer) {
            clearTimeout(this._resetLiveHideTimer);
            this._resetLiveHideTimer = null;
        }
        if (this._resetLiveBlinkTimer) {
            clearTimeout(this._resetLiveBlinkTimer);
            this._resetLiveBlinkTimer = null;
        }
        if (this._resetLiveBlinkInterval) {
            clearInterval(this._resetLiveBlinkInterval);
            this._resetLiveBlinkInterval = null;
        }
        if (this._resetLiveDot) {
            this._resetLiveDot.classList.remove('is-visible');
        }
        this._resetLiveNextAt = 0;
    }

    _openComPopup(anchor) {
        this._closeComPopup();
        if (!this._hudRoot || !anchor) return;

        const { wrap } = makePopupWrap({
            title: 'Center of mass',
            onClose: () => this._closeComPopup(),
            classes: ['is-narrow']
        });

        const topSeparator = makeSeparator();
        topSeparator.classList.add('rapier-separator-tight');
        wrap.appendChild(topSeparator);

        const note = document.createElement('div');
        note.className = 'rapier-popup-note hidden';
        wrap.appendChild(note);

        const mode = resolveInertiaMode(this._tuning?.chassis?.additionalMassProperties);
        const disabled = mode === 'rapier';

        const makeField = (axis, value, key, { disabled = false } = {}) => {
            const row = document.createElement('div');
            row.className = 'rapier-popup-field-row';

            const label = document.createElement('div');
            label.textContent = axis;
            label.className = 'rapier-popup-field-axis is-strong';
            appendHelp(label, INPUT_HELP[key], this._helpSystem);

            const input = document.createElement('input');
            input.type = 'number';
            input.inputMode = 'decimal';
            input.step = '0.01';
            input.value = Number.isFinite(value) ? String(value) : '';
            input.className = 'rapier-popup-number-input';
            input.disabled = disabled;
            input.addEventListener('input', () => {
                const next = parseFloat(input.value);
                if (!Number.isFinite(next)) return;
                this._setInputValue(key, next);
            });

            row.appendChild(label);
            row.appendChild(input);
            wrap.appendChild(row);
            return input;
        };

        const com = this._tuning?.chassis?.additionalMassProperties?.com ?? {};
        const inputs = {
            x: makeField('X', com.x, 'massPropsComX', { disabled }),
            y: makeField('Y', com.y, 'massPropsComY', { disabled }),
            z: makeField('Z', com.z, 'massPropsComZ', { disabled })
        };

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const left = Math.min(window.innerWidth - 230, Math.max(pad, rect.right + pad));
        const top = Math.min(window.innerHeight - 200, Math.max(pad, rect.top - 8));
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closeComPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeComPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._comPopup = wrap;
        this._comPopupHandlers = { onPointerDown, onKeyDown };
        this._comPopupFields = { noteEl: note, inputs };
        this._syncComPopupState();
        this._emitComPreview();
    }

    _closeComPopup() {
        if (this._comPopup?.parentElement) {
            this._comPopup.parentElement.removeChild(this._comPopup);
        }
        if (this._comPopupHandlers) {
            document.removeEventListener('pointerdown', this._comPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._comPopupHandlers.onKeyDown);
        }
        this._comPopup = null;
        this._comPopupHandlers = null;
        this._comPopupFields = null;
        this.onComPreview?.(false, null);
    }

    _emitComPreview() {
        if (!this._comPopup) return;
        const mode = resolveInertiaMode(this._tuning?.chassis?.additionalMassProperties);
        if (mode === 'rapier') {
            this.onComPreview?.(false, null);
            return;
        }
        const com = this._tuning?.chassis?.additionalMassProperties?.com ?? {};
        this.onComPreview?.(true, { x: com.x ?? 0, y: com.y ?? 0, z: com.z ?? 0 });
    }

    _syncComPopupState() {
        const fields = this._comPopupFields;
        if (!fields) return;
        const mode = resolveInertiaMode(this._tuning?.chassis?.additionalMassProperties);
        const disabled = mode === 'rapier';
        const com = this._tuning?.chassis?.additionalMassProperties?.com ?? {};

        if (fields.noteEl) {
            fields.noteEl.textContent = disabled
                ? 'Rapier mode: center of mass comes from colliders (COM override disabled).'
                : '';
            fields.noteEl.classList.toggle('hidden', !disabled);
        }

        const apply = (input, value) => {
            if (!input) return;
            input.disabled = disabled;
            if (disabled) {
                input.value = '';
                input.placeholder = '-';
                return;
            }
            input.placeholder = '';
            input.value = Number.isFinite(value) ? String(value) : '';
        };
        apply(fields.inputs?.x, com.x);
        apply(fields.inputs?.y, com.y);
        apply(fields.inputs?.z, com.z);
    }

    _openInertiaPopup(anchor) {
        this._closeInertiaPopup();
        if (!this._hudRoot || !anchor) return;

        const { wrap } = makePopupWrap({ title: 'Inertia', onClose: () => this._closeInertiaPopup(), classes: ['is-medium'] });

        const props = this._tuning?.chassis?.additionalMassProperties ?? {};
        props.inertiaMode = resolveInertiaMode(props);

        const topSeparator = makeSeparator();
        topSeparator.classList.add('rapier-separator-tight');
        wrap.appendChild(topSeparator);

        const modeRow = document.createElement('div');
        modeRow.className = 'rapier-popup-row';

        const modeLabel = document.createElement('div');
        modeLabel.textContent = 'Mode';
        modeLabel.className = 'rapier-popup-row-label';
        appendHelp(modeLabel, INPUT_HELP.inertiaMode, this._helpSystem);

        const modeValue = document.createElement('div');
        modeValue.textContent = '—';
        modeValue.className = 'rapier-popup-row-value';

        modeRow.appendChild(modeLabel);
        modeRow.appendChild(modeValue);
        wrap.appendChild(modeRow);

        const note = document.createElement('div');
        note.className = 'rapier-popup-note hidden';
        wrap.appendChild(note);

        const sepA = makeSeparator();
        sepA.classList.add('rapier-separator-tight');
        wrap.appendChild(sepA);

        const sectionTitle = (text) => {
            const el = document.createElement('div');
            el.textContent = text;
            el.className = 'rapier-popup-section-title';
            return el;
        };
        wrap.appendChild(sectionTitle('Principal inertia'));

        const makeField = (title, value, key, { disabled = false, step = 0.01, integer = false } = {}) => {
            const row = document.createElement('div');
            row.className = 'rapier-popup-field-row';

            const label = document.createElement('div');
            label.textContent = title;
            label.className = 'rapier-popup-field-label';
            appendHelp(label, INPUT_HELP[key], this._helpSystem);

            const input = document.createElement('input');
            input.type = 'number';
            input.inputMode = 'decimal';
            input.step = String(Number.isFinite(step) && step > 0 ? step : 0.01);
            input.value = Number.isFinite(value) ? String(integer ? Math.round(value) : value) : '';
            input.className = 'rapier-popup-number-input w-90';
            input.disabled = disabled;
            input.addEventListener('input', () => {
                let next = parseFloat(input.value);
                if (!Number.isFinite(next)) return;
                if (integer) next = Math.round(next);
                this._setInputValue(key, next);
            });

            row.appendChild(label);
            row.appendChild(input);
            wrap.appendChild(row);
            return input;
        };

        const inertia = props.inertia ?? {};
        const frame = props.inertiaFrame ?? {};
        const initial = {
            mode: resolveInertiaMode(props),
            inertia: { x: inertia.x ?? 0, y: inertia.y ?? 0, z: inertia.z ?? 0 },
            frame: { w: frame.w ?? 1, x: frame.x ?? 0, y: frame.y ?? 0, z: frame.z ?? 0 }
        };
        const readOnly = resolveInertiaMode(props) !== 'manual';
        const inputs = {
            x: makeField('Inertia X', initial.inertia.x, 'massPropsInertiaX', { disabled: readOnly, step: 100, integer: true }),
            y: makeField('Inertia Y', initial.inertia.y, 'massPropsInertiaY', { disabled: readOnly, step: 100, integer: true }),
            z: makeField('Inertia Z', initial.inertia.z, 'massPropsInertiaZ', { disabled: readOnly, step: 100, integer: true })
        };

        const sepB = makeSeparator();
        sepB.classList.add('rapier-separator-tight');
        wrap.appendChild(sepB);

        wrap.appendChild(sectionTitle('Inertia frame (quat)'));
        const frameInputs = {
            w: makeField('W', initial.frame.w, 'massPropsFrameW', { disabled: readOnly, step: 0.01 }),
            x: makeField('X', initial.frame.x, 'massPropsFrameX', { disabled: readOnly, step: 0.01 }),
            y: makeField('Y', initial.frame.y, 'massPropsFrameY', { disabled: readOnly, step: 0.01 }),
            z: makeField('Z', initial.frame.z, 'massPropsFrameZ', { disabled: readOnly, step: 0.01 })
        };

        const separator = makeSeparator();
        separator.classList.add('rapier-separator-tight');
        wrap.appendChild(separator);

        const actions = document.createElement('div');
        actions.className = 'rapier-popup-actions';

        const reset = makeButton('Reset');
        reset.classList.add('is-popup');
        reset.addEventListener('click', () => {
            const mode = resolveInertiaMode(this._tuning?.chassis?.additionalMassProperties);
            if (mode === 'auto') {
                this._recomputeAutoInertia();
                this._syncInertiaPopupState();
                return;
            }
            if (mode !== 'manual') return;
            this._setInputValue('massPropsInertiaX', initial.inertia.x);
            this._setInputValue('massPropsInertiaY', initial.inertia.y);
            this._setInputValue('massPropsInertiaZ', initial.inertia.z);
            this._setInputValue('massPropsFrameW', initial.frame.w);
            this._setInputValue('massPropsFrameX', initial.frame.x);
            this._setInputValue('massPropsFrameY', initial.frame.y);
            this._setInputValue('massPropsFrameZ', initial.frame.z);
            this._syncInertiaPopupState();
        });

        actions.appendChild(reset);
        wrap.appendChild(actions);

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const left = Math.min(window.innerWidth - 260, Math.max(pad, rect.right + pad));
        const top = Math.min(window.innerHeight - 220, Math.max(pad, rect.top - 8));
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closeInertiaPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeInertiaPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._inertiaPopup = wrap;
        this._inertiaPopupHandlers = { onPointerDown, onKeyDown };
        this._inertiaPopupFields = { modeValueEl: modeValue, noteEl: note, resetButton: reset, inertiaInputs: inputs, frameInputs };
        this._syncInertiaPopupState();
    }

    _closeInertiaPopup() {
        if (this._inertiaPopup?.parentElement) {
            this._inertiaPopup.parentElement.removeChild(this._inertiaPopup);
        }
        if (this._inertiaPopupHandlers) {
            document.removeEventListener('pointerdown', this._inertiaPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._inertiaPopupHandlers.onKeyDown);
        }
        this._inertiaPopup = null;
        this._inertiaPopupHandlers = null;
        this._inertiaPopupFields = null;
    }

    _openInertiaFramePopup(anchor) {
        this._closeInertiaFramePopup();
        if (!this._hudRoot || !anchor) return;

        const { wrap } = makePopupWrap({
            title: 'Inertia frame',
            onClose: () => this._closeInertiaFramePopup(),
            classes: ['is-small']
        });

        const topSeparator = makeSeparator();
        topSeparator.classList.add('rapier-separator-tight');
        wrap.appendChild(topSeparator);

        const makeField = (title, value, key) => {
            const row = document.createElement('div');
            row.className = 'rapier-popup-field-row';

            const label = document.createElement('div');
            label.textContent = title;
            label.className = 'rapier-popup-field-label';
            appendHelp(label, INPUT_HELP[key], this._helpSystem);

            const input = document.createElement('input');
            input.type = 'number';
            input.inputMode = 'decimal';
            input.step = '0.01';
            input.value = Number.isFinite(value) ? String(value) : '';
            input.className = 'rapier-popup-number-input w-90';
            input.addEventListener('input', () => {
                const next = parseFloat(input.value);
                if (!Number.isFinite(next)) return;
                this._setInputValue(key, next);
            });

            row.appendChild(label);
            row.appendChild(input);
            wrap.appendChild(row);
            return input;
        };

        const frame = this._tuning?.chassis?.additionalMassProperties?.inertiaFrame ?? {};
        const initial = {
            w: frame.w ?? 1,
            x: frame.x ?? 0,
            y: frame.y ?? 0,
            z: frame.z ?? 0
        };
        const inputs = {
            w: makeField('Frame W', initial.w, 'massPropsFrameW'),
            x: makeField('Frame X', initial.x, 'massPropsFrameX'),
            y: makeField('Frame Y', initial.y, 'massPropsFrameY'),
            z: makeField('Frame Z', initial.z, 'massPropsFrameZ')
        };

        const separator = makeSeparator();
        separator.classList.add('rapier-separator-tight');
        wrap.appendChild(separator);

        const actions = document.createElement('div');
        actions.className = 'rapier-popup-actions';

        const reset = makeButton('Reset');
        reset.classList.add('is-popup');
        reset.addEventListener('click', () => {
            inputs.w.value = String(initial.w);
            inputs.x.value = String(initial.x);
            inputs.y.value = String(initial.y);
            inputs.z.value = String(initial.z);
            this._setInputValue('massPropsFrameW', initial.w);
            this._setInputValue('massPropsFrameX', initial.x);
            this._setInputValue('massPropsFrameY', initial.y);
            this._setInputValue('massPropsFrameZ', initial.z);
        });

        actions.appendChild(reset);
        wrap.appendChild(actions);

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const left = Math.min(window.innerWidth - 260, Math.max(pad, rect.right + pad));
        const top = Math.min(window.innerHeight - 240, Math.max(pad, rect.top - 8));
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closeInertiaFramePopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeInertiaFramePopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._inertiaFramePopup = wrap;
        this._inertiaFramePopupHandlers = { onPointerDown, onKeyDown };
    }

    _closeInertiaFramePopup() {
        if (this._inertiaFramePopup?.parentElement) {
            this._inertiaFramePopup.parentElement.removeChild(this._inertiaFramePopup);
        }
        if (this._inertiaFramePopupHandlers) {
            document.removeEventListener('pointerdown', this._inertiaFramePopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._inertiaFramePopupHandlers.onKeyDown);
        }
        this._inertiaFramePopup = null;
        this._inertiaFramePopupHandlers = null;
    }

    _openLockingPopup(anchor) {
        this._closeLockingPopup();
        if (!this._hudRoot || !anchor) return;

        const { wrap } = makePopupWrap({ title: 'Locking', onClose: () => this._closeLockingPopup(), classes: ['is-small'] });

        const topSeparator = makeSeparator();
        topSeparator.classList.add('rapier-separator-tight');
        wrap.appendChild(topSeparator);

        const attach = (control) => {
            if (!control?.wrap) return;
            if (control.wrap.parentElement) {
                control.wrap.parentElement.removeChild(control.wrap);
            }
            control.wrap.classList.add('rapier-popup-control');
            wrap.appendChild(control.wrap);
        };

        const initial = {
            lockTranslations: !!this._tuning?.chassis?.lockTranslations,
            lockRotations: !!this._tuning?.chassis?.lockRotations,
            enabledRotX: !!this._tuning?.chassis?.enabledRotations?.x,
            enabledRotY: !!this._tuning?.chassis?.enabledRotations?.y,
            enabledRotZ: !!this._tuning?.chassis?.enabledRotations?.z
        };

        attach(this._inputControls.lockTranslations);
        attach(this._inputControls.lockRotations);
        attach(this._inputControls.enabledRotX);
        attach(this._inputControls.enabledRotY);
        attach(this._inputControls.enabledRotZ);

        const separator = makeSeparator();
        separator.classList.add('rapier-separator-tight');
        wrap.appendChild(separator);

        const actions = document.createElement('div');
        actions.className = 'rapier-popup-actions';

        const reset = makeButton('Reset');
        reset.classList.add('is-popup');
        reset.addEventListener('click', () => {
            this._setInputValue('lockTranslations', initial.lockTranslations);
            this._setInputValue('lockRotations', initial.lockRotations);
            this._setInputValue('enabledRotX', initial.enabledRotX);
            this._setInputValue('enabledRotY', initial.enabledRotY);
            this._setInputValue('enabledRotZ', initial.enabledRotZ);
        });

        actions.appendChild(reset);
        wrap.appendChild(actions);

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const left = Math.min(window.innerWidth - 260, Math.max(pad, rect.right + pad));
        const top = Math.min(window.innerHeight - 240, Math.max(pad, rect.top - 8));
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closeLockingPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeLockingPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._lockingPopup = wrap;
        this._lockingPopupHandlers = { onPointerDown, onKeyDown };
    }

    _closeLockingPopup() {
        if (this._lockingPopup?.parentElement) {
            this._lockingPopup.parentElement.removeChild(this._lockingPopup);
        }
        if (this._lockingPopupHandlers) {
            document.removeEventListener('pointerdown', this._lockingPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._lockingPopupHandlers.onKeyDown);
        }
        this._lockingPopup = null;
        this._lockingPopupHandlers = null;
    }

    _openForcesPopup(anchor) {
        if (this._forcesPopup) {
            this._closeForcesPopup();
            return;
        }
        if (!this._hudRoot || !anchor) return;

        const helpSystem = this._helpSystem;

        const { wrap } = makePopupWrap({
            title: 'Forces and impulses',
            onClose: () => this._closeForcesPopup(),
            classes: ['rapier-forces-popup']
        });

        const topSeparator = makeSeparator();
        topSeparator.classList.add('rapier-separator-tight');
        wrap.appendChild(topSeparator);

        const contentRow = document.createElement('div');
        contentRow.className = 'rapier-forces-content';

        const controlsWrap = document.createElement('div');
        controlsWrap.className = 'rapier-forces-controls';

        const applyModeRow = document.createElement('div');
        applyModeRow.className = 'rapier-forces-apply-row';

        const applyModeLabel = document.createElement('div');
        applyModeLabel.textContent = 'Apply at point';
        applyModeLabel.className = 'rapier-forces-apply-label';

        const applyModeWrap = document.createElement('label');
        applyModeWrap.className = 'rapier-forces-apply-toggle';

        const applyModeToggle = document.createElement('input');
        applyModeToggle.type = 'checkbox';
        applyModeToggle.className = 'rapier-forces-apply-checkbox';

        const applyModeTrack = document.createElement('span');
        applyModeTrack.className = 'rapier-forces-apply-track';

        const applyModeKnob = document.createElement('span');
        applyModeKnob.className = 'rapier-forces-apply-knob';

        applyModeTrack.appendChild(applyModeKnob);

        applyModeWrap.appendChild(applyModeToggle);
        applyModeWrap.appendChild(applyModeTrack);

        applyModeRow.appendChild(applyModeLabel);
        applyModeRow.appendChild(applyModeWrap);
        controlsWrap.appendChild(applyModeRow);

        const modeSeparator = makeSeparator();
        modeSeparator.classList.add('rapier-separator-slim');
        controlsWrap.appendChild(modeSeparator);

        const grid = document.createElement('div');
        grid.className = 'rapier-forces-grid';

        const tabs = document.createElement('div');
        tabs.className = 'rapier-forces-tabs';

        const makeTabButton = (label, key) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.textContent = label;
            btn.className = 'rapier-forces-tab';
            btn.addEventListener('click', () => setActiveTab(key));
            return btn;
        };

        const tabButtons = {
            force: makeTabButton('Forces', 'force'),
            torque: makeTabButton('Torques', 'torque'),
            impulse: makeTabButton('Impulses', 'impulse')
        };

        tabs.appendChild(tabButtons.force);
        tabs.appendChild(tabButtons.torque);
        tabs.appendChild(tabButtons.impulse);
        controlsWrap.appendChild(tabs);

        const attachWraps = (wraps, container) => {
            for (const item of wraps) {
                if (!item) continue;
                if (item.parentElement) item.parentElement.removeChild(item);
                container.appendChild(item);
            }
        };

        const attachButtons = (buttons, container) => {
            for (const btn of buttons) {
                if (!btn) continue;
                if (btn.parentElement) btn.parentElement.removeChild(btn);
                container.appendChild(btn);
            }
        };

        const makeColumn = (title, help, wraps, buttons) => {
            const col = document.createElement('div');
            col.className = 'rapier-forces-column';

            const label = makeLabel(title);
            label.classList.add('rapier-forces-column-label');
            appendHelp(label, help, helpSystem);
            col.appendChild(label);

            attachWraps(wraps, col);

            const divider = makeSeparator();
            divider.classList.add('rapier-separator-tight');
            col.appendChild(divider);

            const buttonRow = document.createElement('div');
            buttonRow.className = 'rapier-forces-button-row';
            attachButtons(buttons, buttonRow);
            col.appendChild(buttonRow);

            return col;
        };

        const controls = this._forcePopupControls ?? {};
        const buttons = this._forcePopupButtons ?? {};

        const forceCol = makeColumn(
            'Force',
            INPUT_HELP.forcesPanelForce,
            [
                controls.forceX,
                controls.forceY,
                controls.forceZ,
                controls.forcePointX,
                controls.forcePointY,
                controls.forcePointZ
            ],
            [
                buttons.applyForce,
                buttons.applyForceAtPoint,
                buttons.resetForces
            ]
        );

        const torqueCol = makeColumn(
            'Torque',
            INPUT_HELP.forcesPanelTorque,
            [
                controls.torqueX,
                controls.torqueY,
                controls.torqueZ,
                controls.torqueImpulseX,
                controls.torqueImpulseY,
                controls.torqueImpulseZ
            ],
            [
                buttons.applyTorque,
                buttons.applyTorqueImpulse,
                buttons.resetTorques
            ]
        );

        const impulseCol = makeColumn(
            'Impulse',
            INPUT_HELP.forcesPanelImpulse,
            [
                controls.impulseX,
                controls.impulseY,
                controls.impulseZ,
                controls.impulsePointX,
                controls.impulsePointY,
                controls.impulsePointZ
            ],
            [
                buttons.applyImpulse,
                buttons.applyImpulseAtPoint
            ]
        );

        grid.appendChild(forceCol);
        grid.appendChild(torqueCol);
        grid.appendChild(impulseCol);
        controlsWrap.appendChild(grid);

        const bottomSeparator = makeSeparator();
        bottomSeparator.classList.add('rapier-separator-bottom');
        controlsWrap.appendChild(bottomSeparator);

        const velocityRow = document.createElement('div');
        velocityRow.className = 'rapier-forces-velocity-row';

        const resetAllButton = makeButton('Reset all');
        resetAllButton.classList.add('rapier-forces-velocity-btn', 'rapier-forces-reset-all');
        resetAllButton.addEventListener('click', () => {
            this.onResetForces?.();
            this.onResetTorques?.();
            this.onResetVelocities?.();
            this._setForceLogEntry('const-force', null);
            this._setForceLogEntry('const-torque', null);
            this._clearForceEventLog({ category: 'force', keepConstants: true });
            this._clearForceEventLog({ category: 'torque', keepConstants: true });
            this._setInputValue('linvelX', 0);
            this._setInputValue('linvelY', 0);
            this._setInputValue('linvelZ', 0);
            this._setInputValue('angvelX', 0);
            this._setInputValue('angvelY', 0);
            this._setInputValue('angvelZ', 0);
        });

        velocityRow.appendChild(resetAllButton);

        const resetVel = buttons.resetVelocities;
        if (resetVel) {
            if (resetVel.parentElement) resetVel.parentElement.removeChild(resetVel);
            resetVel.classList.add('rapier-forces-velocity-btn');
            velocityRow.appendChild(resetVel);
        }
        controlsWrap.appendChild(velocityRow);

        const logCol = document.createElement('div');
        logCol.className = 'rapier-forces-log-col hidden';

        const logLabel = makeLabel('Applied');
        logLabel.classList.add('rapier-forces-log-label');
        logCol.appendChild(logLabel);

        const logList = document.createElement('div');
        logList.className = 'rapier-forces-log-list';
        logCol.appendChild(logList);

        contentRow.appendChild(controlsWrap);
        contentRow.appendChild(logCol);
        wrap.appendChild(contentRow);

        const setActiveTab = (key) => {
            this._forcesActiveTab = key;
            forceCol.classList.toggle('hidden', key !== 'force');
            impulseCol.classList.toggle('hidden', key !== 'impulse');
            torqueCol.classList.toggle('hidden', key !== 'torque');
            for (const [tabKey, btn] of Object.entries(tabButtons)) {
                if (!btn) continue;
                btn.classList.toggle('is-active', tabKey === key);
            }
            this._refreshForcesPopupLog();
        };

        const updateApplyMode = (enabled) => {
            this._forceApplyAtPoint = !!enabled;
            applyModeWrap.classList.toggle('is-on', this._forceApplyAtPoint);
            const pointControls = [
                controls.forcePointX,
                controls.forcePointY,
                controls.forcePointZ,
                controls.impulsePointX,
                controls.impulsePointY,
                controls.impulsePointZ
            ];
            for (const ctrl of pointControls) {
                if (!ctrl) continue;
                ctrl.classList.add('rapier-forces-point-control');
                ctrl.classList.toggle('is-disabled', !this._forceApplyAtPoint);
                const inputs = ctrl.querySelectorAll?.('input') ?? [];
                for (const input of inputs) {
                    input.disabled = !this._forceApplyAtPoint;
                }
            }
            if (buttons.applyForce) {
                buttons.applyForce.classList.toggle('hidden', this._forceApplyAtPoint);
            }
            if (buttons.applyForceAtPoint) {
                buttons.applyForceAtPoint.classList.toggle('hidden', !this._forceApplyAtPoint);
            }
            if (buttons.applyImpulse) {
                buttons.applyImpulse.classList.toggle('hidden', this._forceApplyAtPoint);
            }
            if (buttons.applyImpulseAtPoint) {
                buttons.applyImpulseAtPoint.classList.toggle('hidden', !this._forceApplyAtPoint);
            }
            if (this._forcesActiveTab === 'force') {
                forceCol.classList.remove('hidden');
            } else if (this._forcesActiveTab === 'impulse') {
                impulseCol.classList.remove('hidden');
            }
        };

        applyModeToggle.checked = this._forceApplyAtPoint;
        updateApplyMode(this._forceApplyAtPoint);
        applyModeToggle.addEventListener('change', () => {
            updateApplyMode(applyModeToggle.checked);
        });

        setActiveTab(this._forcesActiveTab ?? 'force');

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const left = Math.min(window.innerWidth - 640, Math.max(pad, rect.right + pad));
        const top = Math.max(pad, rect.top - 320);
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closeForcesPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeForcesPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._forcesPopup = wrap;
        this._forcesPopupHandlers = { onPointerDown, onKeyDown };
        this._forcesPopupGrid = grid;
        this._forcesPopupLogCol = logCol;
        this._forcesPopupLogEl = logList;
        this._refreshForcesPopupLog();
    }

    _closeForcesPopup() {
        if (this._forcesPopup?.parentElement) {
            this._forcesPopup.parentElement.removeChild(this._forcesPopup);
        }
        if (this._forcesPopupHandlers) {
            document.removeEventListener('pointerdown', this._forcesPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._forcesPopupHandlers.onKeyDown);
        }
        this._forcesPopup = null;
        this._forcesPopupHandlers = null;
        this._forcesPopupGrid = null;
        this._forcesPopupLogCol = null;
        this._forcesPopupLogEl = null;
    }

    _openTestsPopup(anchor) {
        if (this._testsPopup) {
            this._closeTestsPopup();
            return;
        }
        if (!this._hudRoot || !anchor) return;

        const { wrap } = makePopupWrap({
            title: 'Automated tests',
            onClose: () => this._closeTestsPopup(),
            classes: ['is-small', 'rapier-tests-popup']
        });

        const topSeparator = makeSeparator();
        topSeparator.classList.add('rapier-separator-tight');
        wrap.appendChild(topSeparator);

        for (const test of PRESET_TESTS) {
            const btn = makeButton(test.label);
            btn.classList.add('rapier-tests-popup-button');
            btn.addEventListener('click', () => {
                this._startTest(test);
                this._closeTestsPopup();
            });
            wrap.appendChild(btn);
        }

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const left = Math.min(window.innerWidth - 260, Math.max(pad, rect.right + pad));
        const top = Math.min(window.innerHeight - 220, Math.max(pad, rect.top - 8));
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closeTestsPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeTestsPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._testsPopup = wrap;
        this._testsPopupHandlers = { onPointerDown, onKeyDown };
    }

    _closeTestsPopup() {
        if (this._testsPopup?.parentElement) {
            this._testsPopup.parentElement.removeChild(this._testsPopup);
        }
        if (this._testsPopupHandlers) {
            document.removeEventListener('pointerdown', this._testsPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._testsPopupHandlers.onKeyDown);
        }
        this._testsPopup = null;
        this._testsPopupHandlers = null;
    }

    _openTestPopup(test) {
        this._closeTestPopup();
        if (!this._outputPanel) return;

        const wrap = document.createElement('div');
        stylePanel(wrap, { interactive: true });
        wrap.classList.add('rapier-test-popup');

        const header = document.createElement('div');
        header.className = 'rapier-test-popup-header';

        const title = document.createElement('div');
        title.textContent = test?.label ?? 'Automated Test';
        title.className = 'rapier-test-popup-title';

        const closeBtn = makePopupCloseButton(() => this._closeTestPopup());

        header.appendChild(title);
        header.appendChild(closeBtn);
        wrap.appendChild(header);
        makePopupDraggable(wrap, header);

        const topSeparator = makeSeparator();
        topSeparator.classList.add('rapier-test-popup-separator');
        wrap.appendChild(topSeparator);

        const button = makeButton('');
        button.classList.add('rapier-test-popup-button');
        button.disabled = true;

        const label = document.createElement('span');
        label.textContent = 'Recording';
        label.className = 'rapier-test-popup-button-label';
        button.appendChild(label);

        const dot = document.createElement('span');
        dot.className = 'rapier-test-popup-dot is-visible';
        button.appendChild(dot);

        wrap.appendChild(button);

        const rect = this._outputPanel.getBoundingClientRect();
        const pad = 10;
        const left = Math.max(pad, rect.left - 260 - pad);
        wrap.style.left = `${left}px`;
        wrap.style.bottom = `${pad}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target)) return;
            this._closeTestPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeTestPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._testPopup = wrap;
        this._testPopupHandlers = { onPointerDown, onKeyDown };
        this._testPopupTitle = title;
        this._testPopupButton = button;
        this._testPopupLabel = label;
        this._testPopupDot = dot;
        this._setTestPopupState('recording');
    }

    _setTestPopupState(state) {
        if (!this._testPopupButton || !this._testPopupLabel || !this._testPopupDot) return;
        if (this._testPopupCloseTimer) {
            clearTimeout(this._testPopupCloseTimer);
            this._testPopupCloseTimer = null;
        }
        if (this._testPopupEllipsisTimer) {
            clearInterval(this._testPopupEllipsisTimer);
            this._testPopupEllipsisTimer = null;
        }
        if (state === 'recording') {
            const dots = ['.', '..', '...'];
            let idx = 0;
            this._testPopupLabel.textContent = `Recording${dots[idx]}`;
            this._testPopupDot.classList.add('is-visible');
            this._testPopupButton.disabled = true;
            this._testPopupButton.onclick = null;
            this._testPopupEllipsisTimer = window.setInterval(() => {
                idx = (idx + 1) % dots.length;
                if (this._testPopupLabel) {
                    this._testPopupLabel.textContent = `Recording${dots[idx]}`;
                }
            }, 400);
        } else if (state === 'done') {
            this._testPopupLabel.textContent = 'Copy telemetry';
            this._testPopupDot.classList.remove('is-visible');
            this._testPopupButton.disabled = false;
            this._testPopupButton.onclick = () => {
                this._copyTelemetry().then(() => {
                    this._showAxisToast('Telemetry copied to clipboard');
                    this._closeTestPopup();
                });
            };
            this._testPopupCloseTimer = window.setTimeout(() => {
                this._closeTestPopup();
            }, 5000);
        }
    }

    _closeTestPopup() {
        if (this._testPopup?.parentElement) {
            this._testPopup.parentElement.removeChild(this._testPopup);
        }
        if (this._testPopupHandlers) {
            document.removeEventListener('pointerdown', this._testPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._testPopupHandlers.onKeyDown);
        }
        if (this._testPopupCloseTimer) {
            clearTimeout(this._testPopupCloseTimer);
        }
        if (this._testPopupEllipsisTimer) {
            clearInterval(this._testPopupEllipsisTimer);
        }
        this._testPopup = null;
        this._testPopupHandlers = null;
        this._testPopupTitle = null;
        this._testPopupButton = null;
        this._testPopupLabel = null;
        this._testPopupDot = null;
        this._testPopupCloseTimer = null;
        this._testPopupEllipsisTimer = null;
        this._testPopupEllipsisTimer = null;
    }

    _recordForceEvent(label, vec, point = null) {
        const now = Date.now();
        const fmt = (v) => `${formatNum(v?.x, 2)}, ${formatNum(v?.y, 2)}, ${formatNum(v?.z, 2)}`;
        let text = `${label}: ${fmt(vec)}`;
        if (point) text += ` @ ${fmt(point)}`;
        const lower = String(label ?? '').toLowerCase();
        const category = lower.includes('torque') ? 'torque'
            : lower.includes('force') ? 'force'
                : lower.includes('impulse') ? 'impulse'
                    : 'other';
        const persistent = (lower === 'force' || lower === 'torque');
        const expiresAt = persistent ? null : (now + 4000);
        const key = `event-${category}-${now}-${this._forceActionSeq++}`;
        this._setForceLogEntry(key, text, expiresAt);
    }

    _clearForceEventLog({ category = null, keepConstants = true } = {}) {
        if (!this._forceActionLog?.length) return;
        const prefix = category ? `event-${category}-` : 'event-';
        this._forceActionLog = this._forceActionLog.filter((entry) => {
            const key = entry?.key ?? '';
            if (keepConstants && String(key).startsWith('const-')) return true;
            return !String(key).startsWith(prefix);
        });
        this._refreshForcesPopupLog();
    }

    _setForceLogEntry(key, text, expiresAt = null) {
        if (!this._forceActionLog) this._forceActionLog = [];
        const idx = this._forceActionLog.findIndex((entry) => entry.key === key);
        const isConstant = key.startsWith('const-');
        if (!text) {
            if (idx >= 0) this._forceActionLog.splice(idx, 1);
        } else if (idx >= 0) {
            const entry = { key, text, expiresAt };
            if (isConstant && idx > 0) {
                this._forceActionLog.splice(idx, 1);
                this._forceActionLog.unshift(entry);
            } else {
                this._forceActionLog[idx] = entry;
            }
        } else {
            this._forceActionLog.unshift({ key, text, expiresAt });
        }
        this._pruneForceEvents();
        if (this._forceActionLog.length > this._forceActionMax) {
            this._forceActionLog.length = this._forceActionMax;
        }
        this._refreshForcesPopupLog();
    }

    _pruneForceEvents(now = Date.now()) {
        if (!this._forceActionLog?.length) return;
        const next = this._forceActionLog.filter((entry) => !entry.expiresAt || entry.expiresAt > now);
        if (next.length !== this._forceActionLog.length) {
            this._forceActionLog = next;
        }
    }

    _updateForceLogFromSnapshot(snapshot) {
        const force = snapshot?.body?.force;
        const torque = snapshot?.body?.torque;
        if (vecNonZero(force)) {
            this._setForceLogEntry('const-force', `Force: ${formatVec3(force, 2)}`, null);
        } else {
            this._setForceLogEntry('const-force', null);
        }
        if (vecNonZero(torque)) {
            this._setForceLogEntry('const-torque', `Torque: ${formatVec3(torque, 2)}`, null);
        } else {
            this._setForceLogEntry('const-torque', null);
        }
    }

    _refreshForcesPopupLog() {
        if (!this._forcesPopupLogEl || !this._forcesPopupGrid || !this._forcesPopupLogCol) return;
        const log = this._forceActionLog ?? [];
        const show = log.length > 0;
        this._forcesPopupLogCol.classList.toggle('hidden', !show);
        this._forcesPopupLogEl.textContent = '';
        if (!show) return;
        for (const entry of log) {
            const row = document.createElement('div');
            row.textContent = entry.text;
            row.className = 'rapier-forces-log-entry';
            this._forcesPopupLogEl.appendChild(row);
        }
    }

    getInputs() {
        return { ...this._inputs };
    }

    getVehicleConfig() {
        return { ...this._vehicleConfig };
    }

    getTuning() {
        return {
            chassis: {
                ...this._tuning.chassis,
                translation: { ...(this._tuning.chassis.translation ?? {}) },
                rotation: { ...(this._tuning.chassis.rotation ?? {}) },
                linvel: { ...(this._tuning.chassis.linvel ?? {}) },
                angvel: { ...(this._tuning.chassis.angvel ?? {}) },
                enabledRotations: { ...(this._tuning.chassis.enabledRotations ?? {}) },
                additionalMassProperties: {
                    inertiaMode: resolveInertiaMode(this._tuning.chassis.additionalMassProperties),
                    mass: this._tuning.chassis.additionalMassProperties?.mass ?? NaN,
                    density: this._tuning.chassis.additionalMassProperties?.density ?? NaN,
                    com: { ...(this._tuning.chassis.additionalMassProperties?.com ?? {}) },
                    inertia: { ...(this._tuning.chassis.additionalMassProperties?.inertia ?? {}) },
                    inertiaFrame: { ...(this._tuning.chassis.additionalMassProperties?.inertiaFrame ?? {}) }
                }
            },
            suspension: { ...this._tuning.suspension },
            tires: { ...this._tuning.tires }
        };
    }

    getWorldConfig() {
        return {
            gravity: {
                x: this._worldConfig.gravity?.x ?? 0,
                y: this._worldConfig.gravity?.y ?? -9.81,
                z: this._worldConfig.gravity?.z ?? 0
            }
        };
    }

    getForcePreview() {
        if (!this._forcesPopup) return null;
        const com = this._tuning?.chassis?.additionalMassProperties?.com ?? {};
        const tab = this._forcesActiveTab ?? 'force';
        const colorByTab = {
            force: 0x7a4cff,
            torque: 0xff8a3d,
            impulse: 0x32d0ff
        };
        let vec = this._forces.force ?? { x: 0, y: 0, z: 0 };
        let point = this._forces.forcePoint ?? { x: 0, y: 0, z: 0 };
        let atPoint = !!this._forceApplyAtPoint;
        if (tab === 'impulse') {
            vec = this._forces.impulse ?? { x: 0, y: 0, z: 0 };
            point = this._forces.impulsePoint ?? { x: 0, y: 0, z: 0 };
        } else if (tab === 'torque') {
            vec = this._forces.torque ?? { x: 0, y: 0, z: 0 };
            atPoint = false;
        }
        return {
            tab,
            color: colorByTab[tab] ?? colorByTab.force,
            atPoint,
            force: {
                x: vec?.x ?? 0,
                y: vec?.y ?? 0,
                z: vec?.z ?? 0
            },
            point: {
                x: point?.x ?? 0,
                y: point?.y ?? 0,
                z: point?.z ?? 0
            },
            com: {
                x: com.x ?? 0,
                y: com.y ?? 0,
                z: com.z ?? 0
            }
        };
    }

    update(dt, snapshot) {
        const clampedDt = Math.min(Math.max(dt ?? 0, 0), 0.05);
        if (this._activeTest) {
            this._advanceTest(clampedDt);
            if (snapshot) this._recordTelemetry(snapshot);
        }
        if (this._sampleRecording) {
            if (clampedDt > 0) this._sampleElapsed += clampedDt;
            if (snapshot) {
                this._recordSampleFrame(snapshot);
                if (this._sampleElapsed >= 0.5) this._finishSampleRecord();
            }
        }
    }

    setOutputs(snapshot) {
        if (!snapshot || !this._outputRows.status) return;

        this._outputRows.status.valueEl.textContent = snapshot.status ?? '—';

        const body = snapshot.body;
        const pos = body?.position;
        const rot = body?.rotation;
        const linvel = body?.linvel;
        const angvel = body?.angvel;

        const speedMps = snapshot.speedMps ?? 0;
        const speedMax = 40;
        this._outputRows.speed.valueEl.textContent = `${outNum(speedMps, 2, 8)} m/s`;
        if (this._outputRows.speed.barEl) {
            const t = Math.min(1, Math.max(0, speedMps / speedMax));
            this._outputRows.speed.barEl.style.width = `${Math.round(t * 100)}%`;
        }
        this._outputRows.speedKph.valueEl.textContent = `${outNum(speedMps * 3.6, 1, 8)} km/h`;
        if (this._outputRows.speedProj) {
            const sp = snapshot.speedProjMps ?? 0;
            this._outputRows.speedProj.valueEl.textContent = `${outNum(sp, 2, 8)} m/s (${outNum(sp * 3.6, 1, 8)} km/h)`;
            if (this._outputRows.speedProj.barEl) {
                const t = Math.min(1, Math.max(0, sp / speedMax));
                this._outputRows.speedProj.barEl.style.width = `${Math.round(t * 100)}%`;
            }
        }
        const yawDeg = (snapshot.yawRad ?? 0) * (180 / Math.PI);
        this._outputRows.yaw.valueEl.textContent = `${outNum(yawDeg, 1, 8)} deg`;
        if (this._outputRows.yaw.arrowEl) {
            this._outputRows.yaw.arrowEl.style.transform = `rotate(${yawDeg}deg)`;
        }
        if (this._outputRows.axes) {
            const axes = snapshot.controllerAxes ?? {};
            const up = Number.isFinite(axes.up) ? axes.up : 'n/a';
            const fwd = Number.isFinite(axes.forward) ? axes.forward : 'n/a';
            this._outputRows.axes.valueEl.textContent = `up:${padLeft(String(up), 2)}  fwd:${padLeft(String(fwd), 2)}`;
        }
        if (this._outputRows.mass) {
            this._outputRows.mass.valueEl.textContent = Number.isFinite(snapshot.massKg) ? `${outNum(snapshot.massKg, 0, 8)} kg` : `${outNum(NaN, 0, 8)} kg`;
        }
        this._outputRows.position.valueEl.textContent = outVec3(pos, 2, 8);
        this._outputRows.linvel.valueEl.textContent = outVec3(linvel, 2, 8);
        this._outputRows.angvel.valueEl.textContent = outVec3(angvel, 2, 8);
        this._outputRows.rotation.valueEl.textContent = rot ? `${outNum(rot.x, 3, 8)}, ${outNum(rot.y, 3, 8)}, ${outNum(rot.z, 3, 8)}` : outVec3(null, 3, 8);

        this._pruneForceEvents();
        this._updateForceLogFromSnapshot(snapshot);

        const contacts = snapshot.contacts ?? { count: 0, total: 0 };
        this._outputRows.contacts.valueEl.textContent = `${padLeft(String(contacts.count ?? 0), 2)}/${padLeft(String(contacts.total ?? 0), 2)}`;
        if (this._outputRows.contacts.dotEls) {
            const dots = this._outputRows.contacts.dotEls;
            const wheels = snapshot.wheelStates ?? [];
            const order = ['FL', 'FR', 'RL', 'RR'];
            for (let i = 0; i < dots.length; i++) {
                const label = order[i];
                const wheel = wheels.find((w) => w?.label === label);
                const on = !!wheel?.inContact;
                dots[i].classList.toggle('is-on', on);
            }
        }

        if (this._outputRows.rayDown) {
            const rd = snapshot.rayDown;
            if (!rd) this._outputRows.rayDown.valueEl.textContent = '—';
            else if (rd.hit) this._outputRows.rayDown.valueEl.textContent = `hit:Y  toi:${outNum(rd.toi, 2, 7)}`;
            else this._outputRows.rayDown.valueEl.textContent = `hit:N  toi:${outNum(NaN, 2, 7)}`;
        }

        if (this._outputRows.counts) {
            const world = snapshot.world ?? {};
            this._outputRows.counts.valueEl.textContent = `bodies:${padLeft(String(world.bodies ?? '—'), 4)}  coll:${padLeft(String(world.colliders ?? '—'), 4)}`;
        }

        const sleeping = snapshot.body?.sleeping;
        const canForceSleep = snapshot.body?.canForceSleep;
        this._sleepingState = sleeping;
        if (this._sleepMarker) {
            this._sleepMarker.classList.toggle('is-sleeping', sleeping === true);
            this._sleepMarker.classList.toggle('is-awake', sleeping === false);
        }
        if (this._wakeButton) {
            if (canForceSleep) {
                this._wakeButton.classList.remove('hidden');
                if (sleeping === false) {
                    this._wakeButton.textContent = 'Sleep';
                } else {
                    this._wakeButton.textContent = 'Wake up';
                }
            } else {
                this._wakeButton.classList.add('hidden');
            }
        }

        const wheelCells = this._wheelCells;
        const wheels = snapshot.wheelStates ?? [];
        const suspRest = this._vehicleConfig?.restLength ?? 0;
        const suspTravel = this._tuning?.suspension?.maxTravel ?? 0;
        const suspMin = Math.max(0, suspRest - suspTravel);
        const suspMax = suspRest + suspTravel;
        const engineForceMax = Math.max(1, parseFloat(this._inputControls.engineForce?.input?.max) || 60000);
        if (wheelCells && wheels.length) {
            const find = (label) => wheels.find((w) => w?.label === label);
            const toText = (w, fallbackLabel) => {
                if (!w) return '—';
                const contact = w.inContact ? 'Y' : 'N';
                const steerDeg = Number.isFinite(w.steering) ? -w.steering * (180 / Math.PI) : NaN;
                const centerLocal = w.centerLocal ?? null;
                const connectionLocal = w.connectionPointLocal ?? null;
                return (
                    `${padLeft(String(w.label ?? fallbackLabel), 2)}  contact:${contact}\n` +
                    `eng:${outNum(w.engineForceApplied, 0, 5)} N\n` +
                    `steer:${outNum(steerDeg, 1, 5)} deg\n` +
                    `susp len:${outNum(w.suspensionLength, 3, 5)} m\n` +
                    `susp force:${outNum(w.suspensionForce, 0, 5)} N\n` +
                    `imp fwd:${outNum(w.forwardImpulse, 2, 5)}\n` +
                    `imp side:${outNum(w.sideImpulse, 2, 5)}\n` +
                    `centerL:${outNum(centerLocal?.x, 1, 5)} ${outNum(centerLocal?.y, 1, 5)} ${outNum(centerLocal?.z, 1, 5)}\n` +
                    `connectL:${outNum(connectionLocal?.x, 1, 5)} ${outNum(connectionLocal?.y, 1, 5)} ${outNum(connectionLocal?.z, 1, 5)}`
                );
            };

            const apply = (cell, wheel) => {
                if (!cell) return;
                if (cell.textEl) {
                    cell.textEl.textContent = toText(wheel, cell.label ?? '—');
                }
                if (cell.knobEl) {
                    const inContact = !!wheel?.inContact;
                    cell.knobEl.classList.toggle('is-contact', inContact);
                }
                if (cell.arrowEl) {
                    const steerDeg = Number.isFinite(wheel?.steering) ? -wheel.steering * (180 / Math.PI) : 0;
                    cell.arrowEl.style.transform = `rotate(${steerDeg}deg)`;
                    cell.arrowEl.classList.toggle('is-active', Number.isFinite(wheel?.steering));
                }
                if (cell.barEl) {
                    const len = Number.isFinite(wheel?.suspensionLength) ? wheel.suspensionLength : suspRest;
                    const span = Math.max(1e-6, suspMax - suspMin);
                    const t = Math.min(1, Math.max(0, (len - suspMin) / span));
                    cell.barEl.style.height = `${Math.round(t * 100)}%`;
                }
                if (cell.driveEl) {
                    const driveForce = Number.isFinite(wheel?.engineForceApplied) ? wheel.engineForceApplied : 0;
                    const t = Math.min(1, Math.max(0, driveForce / engineForceMax));
                    cell.driveEl.style.width = `${Math.round(t * 100)}%`;
                    cell.driveEl.classList.toggle('is-active', driveForce > 0.01);
                }
            };

            apply(wheelCells.fl, find('FL'));
            apply(wheelCells.fr, find('FR'));
            apply(wheelCells.rl, find('RL'));
            apply(wheelCells.rr, find('RR'));
        }
    }

    _buildHud() {
        const root = makeHudRoot();
        const helpSystem = this._createHelpSystem(root);
        this._helpSystem = helpSystem;

        const inputPanel = document.createElement('div');
        stylePanel(inputPanel, { interactive: true });
        inputPanel.classList.add('rapier-input-panel');
        const inputHeader = document.createElement('div');
        inputHeader.className = 'rapier-input-header';

        const inputTitle = makeTitle('Rapier Input');
        inputTitle.classList.add('is-inline');
        inputHeader.appendChild(inputTitle);

        inputPanel.appendChild(inputHeader);

        const columns = document.createElement('div');
        columns.className = 'rapier-input-columns';

        const leftCol = document.createElement('div');
        leftCol.className = 'rapier-input-col';

        const middleCol = document.createElement('div');
        middleCol.className = 'rapier-input-col';

        const internalGroups = {
            vehicle: makeGroup('Vehicle', { tightTop: true }),
            suspension: makeGroup('Suspension'),
            tires: makeGroup('Tires'),
            bodyType: makeGroup('Rigid-body Type', { tightTop: true, showLabel: false }),
            mass: makeGroup('Mass Properties'),
            damping: makeGroup('Damping'),
            dominance: makeGroup('Dominance', { showLabel: false }),
            ccd: makeGroup('Continuous Collision Detection', { showLabel: false }),
            sleeping: makeGroup('Sleeping', { showLabel: false })
        };

        middleCol.appendChild(internalGroups.vehicle.wrap);
        middleCol.appendChild(internalGroups.suspension.wrap);
        middleCol.appendChild(internalGroups.tires.wrap);

        middleCol.appendChild(internalGroups.mass.wrap);
        middleCol.appendChild(internalGroups.damping.wrap);

        columns.appendChild(leftCol);
        columns.appendChild(middleCol);
        inputPanel.appendChild(columns);

        this._inputControls.bodyType = makeSelectControl({
            title: 'Type',
            value: this._tuning.chassis.bodyType,
            options: [
                { value: 'dynamic', label: 'Dynamic' },
                { value: 'fixed', label: 'Fixed' },
                { value: 'kinematicPositionBased', label: 'Kinematic (Position)' },
                { value: 'kinematicVelocityBased', label: 'Kinematic (Velocity)' }
            ],
            help: INPUT_HELP.bodyType,
            helpSystem
        });
        internalGroups.bodyType.body.appendChild(this._inputControls.bodyType.wrap);

        this._inputControls.translationX = { input: null, valEl: null };
        this._inputControls.spawnHeight = { input: null, valEl: null };
        this._inputControls.translationZ = { input: null, valEl: null };
        this._inputControls.linvelX = { input: null, valEl: null };
        this._inputControls.linvelY = { input: null, valEl: null };
        this._inputControls.linvelZ = { input: null, valEl: null };
        this._inputControls.angvelX = { input: null, valEl: null };
        this._inputControls.angvelY = { input: null, valEl: null };
        this._inputControls.angvelZ = { input: null, valEl: null };

        this._inputControls.forceX = makeNumberControl({
            title: 'Force X (N)',
            value: this._forces.force.x,
            help: INPUT_HELP.force,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.forceY = makeNumberControl({
            title: 'Force Y (N)',
            value: this._forces.force.y,
            help: INPUT_HELP.force,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.forceZ = makeNumberControl({
            title: 'Force Z (N)',
            value: this._forces.force.z,
            help: INPUT_HELP.force,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.forcePointX = makeNumberControl({
            title: 'Force point X (m)',
            value: this._forces.forcePoint.x,
            help: INPUT_HELP.forcePoint,
            helpSystem,
            step: 0.1,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.forcePointY = makeNumberControl({
            title: 'Force point Y (m)',
            value: this._forces.forcePoint.y,
            help: INPUT_HELP.forcePoint,
            helpSystem,
            step: 0.1,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.forcePointZ = makeNumberControl({
            title: 'Force point Z (m)',
            value: this._forces.forcePoint.z,
            help: INPUT_HELP.forcePoint,
            helpSystem,
            step: 0.1,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.torqueX = makeNumberControl({
            title: 'Torque X (N*m)',
            value: this._forces.torque.x,
            help: INPUT_HELP.torque,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.torqueY = makeNumberControl({
            title: 'Torque Y (N*m)',
            value: this._forces.torque.y,
            help: INPUT_HELP.torque,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.torqueZ = makeNumberControl({
            title: 'Torque Z (N*m)',
            value: this._forces.torque.z,
            help: INPUT_HELP.torque,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        const addForceButton = makeButton('Add force');
        addForceButton.addEventListener('click', () => {
            if (this.onAddForce) {
                this.onAddForce(this._forces.force);
                this._recordForceEvent('Force', this._forces.force);
            }
        });
        this._actionButtons.push(addForceButton);

        const addForcePointButton = makeButton('Add force @ point');
        addForcePointButton.addEventListener('click', () => {
            if (this.onAddForceAtPoint) {
                this.onAddForceAtPoint(this._forces.force, this._forces.forcePoint);
                this._recordForceEvent('Force', this._forces.force, this._forces.forcePoint);
                const induced = crossVec3(this._forces.forcePoint, this._forces.force);
                this._recordForceEvent('Torque (from force @ point)', induced);
            }
        });
        this._actionButtons.push(addForcePointButton);

        const addTorqueButton = makeButton('Add torque');
        addTorqueButton.addEventListener('click', () => {
            if (this.onAddTorque) {
                this.onAddTorque(this._forces.torque);
                this._recordForceEvent('Torque', this._forces.torque);
            }
        });
        this._actionButtons.push(addTorqueButton);

        const resetForcesButton = makeButton('Reset forces');
        resetForcesButton.addEventListener('click', () => {
            this.onResetForces?.();
            this._setForceLogEntry('const-force', null);
            this._clearForceEventLog({ category: 'force', keepConstants: true });
        });
        this._actionButtons.push(resetForcesButton);

        const resetTorquesButton = makeButton('Reset torques');
        resetTorquesButton.addEventListener('click', () => {
            this.onResetTorques?.();
            this._setForceLogEntry('const-torque', null);
            this._clearForceEventLog({ category: 'torque', keepConstants: true });
        });
        this._actionButtons.push(resetTorquesButton);

        this._inputControls.impulseX = makeNumberControl({
            title: 'Impulse X (N*s)',
            value: this._forces.impulse.x,
            help: INPUT_HELP.impulse,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.impulseY = makeNumberControl({
            title: 'Impulse Y (N*s)',
            value: this._forces.impulse.y,
            help: INPUT_HELP.impulse,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.impulseZ = makeNumberControl({
            title: 'Impulse Z (N*s)',
            value: this._forces.impulse.z,
            help: INPUT_HELP.impulse,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.impulsePointX = makeNumberControl({
            title: 'Impulse point X (m)',
            value: this._forces.impulsePoint.x,
            help: INPUT_HELP.impulsePoint,
            helpSystem,
            step: 0.1,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.impulsePointY = makeNumberControl({
            title: 'Impulse point Y (m)',
            value: this._forces.impulsePoint.y,
            help: INPUT_HELP.impulsePoint,
            helpSystem,
            step: 0.1,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.impulsePointZ = makeNumberControl({
            title: 'Impulse point Z (m)',
            value: this._forces.impulsePoint.z,
            help: INPUT_HELP.impulsePoint,
            helpSystem,
            step: 0.1,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.torqueImpulseX = makeNumberControl({
            title: 'Torque impulse X (N*m*s)',
            value: this._forces.torqueImpulse.x,
            help: INPUT_HELP.torqueImpulse,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.torqueImpulseY = makeNumberControl({
            title: 'Torque impulse Y (N*m*s)',
            value: this._forces.torqueImpulse.y,
            help: INPUT_HELP.torqueImpulse,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.torqueImpulseZ = makeNumberControl({
            title: 'Torque impulse Z (N*m*s)',
            value: this._forces.torqueImpulse.z,
            help: INPUT_HELP.torqueImpulse,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        const applyImpulseButton = makeButton('Apply impulse');
        applyImpulseButton.addEventListener('click', () => {
            if (this.onApplyImpulse) {
                this.onApplyImpulse(this._forces.impulse);
                this._recordForceEvent('Impulse', this._forces.impulse);
            }
        });
        this._actionButtons.push(applyImpulseButton);

        const applyImpulsePointButton = makeButton('Apply impulse @ point');
        applyImpulsePointButton.addEventListener('click', () => {
            if (this.onApplyImpulseAtPoint) {
                this.onApplyImpulseAtPoint(this._forces.impulse, this._forces.impulsePoint);
                this._recordForceEvent('Impulse', this._forces.impulse, this._forces.impulsePoint);
            }
        });
        this._actionButtons.push(applyImpulsePointButton);

        const applyTorqueImpulseButton = makeButton('Apply torque impulse');
        applyTorqueImpulseButton.addEventListener('click', () => {
            if (this.onApplyTorqueImpulse) {
                this.onApplyTorqueImpulse(this._forces.torqueImpulse);
                this._recordForceEvent('Torque impulse', this._forces.torqueImpulse);
            }
        });
        this._actionButtons.push(applyTorqueImpulseButton);

        const resetAllVelocitiesButton = makeButton('Reset velocities');
        resetAllVelocitiesButton.addEventListener('click', () => {
            this.onResetVelocities?.();
        });
        this._actionButtons.push(resetAllVelocitiesButton);

        this._forcePopupControls = {
            forceX: this._inputControls.forceX.wrap,
            forceY: this._inputControls.forceY.wrap,
            forceZ: this._inputControls.forceZ.wrap,
            forcePointX: this._inputControls.forcePointX.wrap,
            forcePointY: this._inputControls.forcePointY.wrap,
            forcePointZ: this._inputControls.forcePointZ.wrap,
            torqueX: this._inputControls.torqueX.wrap,
            torqueY: this._inputControls.torqueY.wrap,
            torqueZ: this._inputControls.torqueZ.wrap,
            impulseX: this._inputControls.impulseX.wrap,
            impulseY: this._inputControls.impulseY.wrap,
            impulseZ: this._inputControls.impulseZ.wrap,
            impulsePointX: this._inputControls.impulsePointX.wrap,
            impulsePointY: this._inputControls.impulsePointY.wrap,
            impulsePointZ: this._inputControls.impulsePointZ.wrap,
            torqueImpulseX: this._inputControls.torqueImpulseX.wrap,
            torqueImpulseY: this._inputControls.torqueImpulseY.wrap,
            torqueImpulseZ: this._inputControls.torqueImpulseZ.wrap
        };

        this._forcePopupButtons = {
            applyForce: addForceButton,
            applyForceAtPoint: addForcePointButton,
            resetForces: resetForcesButton,
            applyImpulse: applyImpulseButton,
            applyImpulseAtPoint: applyImpulsePointButton,
            applyTorque: addTorqueButton,
            applyTorqueImpulse: applyTorqueImpulseButton,
            resetTorques: resetTorquesButton,
            resetVelocities: resetAllVelocitiesButton
        };

        const inertiaBlock = document.createElement('div');
        inertiaBlock.className = 'rapier-inertia-block';
        internalGroups.mass.body.appendChild(inertiaBlock);

        this._inputControls.inertiaMode = makeSelectControl({
            title: 'Inertia mode',
            value: resolveInertiaMode(this._tuning.chassis.additionalMassProperties),
            options: [
                { value: 'manual', label: 'Manual' },
                { value: 'auto', label: 'Auto' },
                { value: 'rapier', label: 'Rapier' }
            ],
            help: INPUT_HELP.inertiaMode,
            helpSystem
        });
        inertiaBlock.appendChild(this._inputControls.inertiaMode.wrap);

        const inertiaModeNote = document.createElement('div');
        inertiaModeNote.className = 'rapier-inertia-note';
        inertiaBlock.appendChild(inertiaModeNote);
        this._inertiaModeNote = inertiaModeNote;

        this._inputControls.massPropsMass = makeNumberControl({
            title: 'Mass props mass (kg)',
            value: this._tuning.chassis.additionalMassProperties.mass,
            help: INPUT_HELP.massPropsMass,
            helpSystem,
            min: 0,
            max: 100000,
            step: 10,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        inertiaBlock.appendChild(this._inputControls.massPropsMass.wrap);

        this._inputControls.additionalMass = makeNumberControl({
            title: 'Additional mass (kg)',
            value: this._tuning.chassis.additionalMass,
            help: INPUT_HELP.additionalMass,
            helpSystem,
            min: 0,
            max: 100000,
            step: 10,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        inertiaBlock.appendChild(this._inputControls.additionalMass.wrap);

        this._inputControls.massPropsDensity = makeNumberControl({
            title: 'Collider density (kg/m³)',
            value: this._tuning.chassis.additionalMassProperties.density,
            help: INPUT_HELP.massPropsDensity,
            helpSystem,
            min: 0,
            max: 5000,
            step: 1,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        inertiaBlock.appendChild(this._inputControls.massPropsDensity.wrap);

        this._inputControls.massPropsComX = { input: null, valEl: null };
        this._inputControls.massPropsComY = { input: null, valEl: null };
        this._inputControls.massPropsComZ = { input: null, valEl: null };

        const comRow = document.createElement('div');
        comRow.className = 'rapier-inline-row';

        const comLabel = document.createElement('div');
        comLabel.textContent = 'Center of mass';
        comLabel.className = 'rapier-inline-row-label';

        const comButton = makeButton('...', { size: 'small' });
        comButton.addEventListener('click', (event) => {
            event.preventDefault();
            this._openComPopup(comButton);
        });

        comRow.appendChild(comLabel);
        comRow.appendChild(comButton);
        inertiaBlock.appendChild(comRow);
        this._comButton = comButton;

        const inertiaRow = document.createElement('div');
        inertiaRow.className = 'rapier-inline-row';

        const inertiaLabel = document.createElement('div');
        inertiaLabel.className = 'rapier-inline-row-label';

        const inertiaText = document.createElement('div');
        inertiaText.textContent = 'Inertia';
        inertiaText.className = 'rapier-inline-row-label-text';
        appendHelp(inertiaText, INPUT_HELP.inertia, helpSystem);

        const inertiaAuto = document.createElement('div');
        inertiaAuto.textContent = 'AUTO';
        inertiaAuto.className = 'rapier-pill hidden';
        this._inertiaAutoPill = inertiaAuto;

        inertiaLabel.appendChild(inertiaText);
        inertiaLabel.appendChild(inertiaAuto);

        const inertiaButton = makeButton('...', { size: 'small' });
        inertiaButton.addEventListener('click', (event) => {
            event.preventDefault();
            this._openInertiaPopup(inertiaButton);
        });

        inertiaRow.appendChild(inertiaLabel);
        inertiaRow.appendChild(inertiaButton);
        inertiaBlock.appendChild(inertiaRow);
        this._inertiaButton = inertiaButton;

        this._inputControls.lockTranslations = makeToggleControl({
            title: 'Lock translations',
            value: this._tuning.chassis.lockTranslations,
            help: INPUT_HELP.lockTranslations,
            helpSystem
        });

        this._inputControls.lockRotations = makeToggleControl({
            title: 'Lock rotations',
            value: this._tuning.chassis.lockRotations,
            help: INPUT_HELP.lockRotations,
            helpSystem
        });

        this._inputControls.enabledRotX = makeToggleControl({
            title: 'Enable rotation X',
            value: this._tuning.chassis.enabledRotations.x,
            help: INPUT_HELP.enabledRotations,
            helpSystem
        });

        this._inputControls.enabledRotY = makeToggleControl({
            title: 'Enable rotation Y',
            value: this._tuning.chassis.enabledRotations.y,
            help: INPUT_HELP.enabledRotations,
            helpSystem
        });

        this._inputControls.enabledRotZ = makeToggleControl({
            title: 'Enable rotation Z',
            value: this._tuning.chassis.enabledRotations.z,
            help: INPUT_HELP.enabledRotations,
            helpSystem
        });

        const lockingRow = document.createElement('div');
        lockingRow.className = 'rapier-inline-row';

        const lockingLabel = document.createElement('div');
        lockingLabel.textContent = 'Locking';
        lockingLabel.className = 'rapier-inline-row-label-text';
        appendHelp(lockingLabel, INPUT_HELP.locking, helpSystem);

        const lockingButton = makeButton('...', { size: 'small' });
        lockingButton.addEventListener('click', (event) => {
            event.preventDefault();
            this._openLockingPopup(lockingButton);
        });

        lockingRow.appendChild(lockingLabel);
        lockingRow.appendChild(lockingButton);

        this._inputControls.linearDamping = makeNumberControl({
            title: 'Linear damping',
            value: this._tuning.chassis.linearDamping,
            help: INPUT_HELP.linearDamping,
            helpSystem,
            step: 0.01,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.damping.body.appendChild(this._inputControls.linearDamping.wrap);

        this._inputControls.angularDamping = makeNumberControl({
            title: 'Angular damping',
            value: this._tuning.chassis.angularDamping,
            help: INPUT_HELP.angularDamping,
            helpSystem,
            step: 0.01,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.damping.body.appendChild(this._inputControls.angularDamping.wrap);

        this._inputControls.dominanceGroup = makeNumberControl({
            title: 'Dominance group',
            value: this._tuning.chassis.dominanceGroup,
            help: INPUT_HELP.dominanceGroup,
            helpSystem,
            min: -127,
            max: 127,
            step: 1,
            width: '100px'
        });
        internalGroups.dominance.body.appendChild(this._inputControls.dominanceGroup.wrap);

        this._inputControls.ccdEnabled = makeToggleControl({
            title: 'CCD enabled',
            value: this._tuning.chassis.ccdEnabled,
            help: INPUT_HELP.ccdEnabled,
            helpSystem
        });
        internalGroups.ccd.body.appendChild(this._inputControls.ccdEnabled.wrap);

        const sleepRow = document.createElement('div');
        sleepRow.className = 'rapier-sleep-row';

        const sleepLabel = document.createElement('div');
        sleepLabel.textContent = 'Can sleep';
        sleepLabel.className = 'rapier-inline-row-label-text';
        appendHelp(sleepLabel, INPUT_HELP.canSleep, helpSystem);

        const sleepToggle = document.createElement('input');
        sleepToggle.type = 'checkbox';
        sleepToggle.checked = !!this._tuning.chassis.canSleep;
        sleepToggle.className = 'rapier-toggle-input';

        const sleepMarker = document.createElement('div');
        sleepMarker.className = 'rapier-sleep-marker';
        if (helpSystem) {
            const statusText = () => {
                if (this._sleepingState === true) return 'Sleeping';
                if (this._sleepingState === false) return 'Awake';
                return 'Sleep status: n/a';
            };
            sleepMarker.addEventListener('mouseenter', (e) => helpSystem.show(statusText(), e));
            sleepMarker.addEventListener('mousemove', (e) => helpSystem.move(e));
            sleepMarker.addEventListener('mouseleave', () => helpSystem.hide());
        }
        this._sleepMarker = sleepMarker;

        const wakeButton = makeButton('Wake up');
        wakeButton.classList.add('is-compact');
        wakeButton.addEventListener('click', () => {
            if (this._sleepingState === false) {
                this.onSleep?.();
            } else {
                this.onWakeUp?.();
            }
        });
        this._actionButtons.push(wakeButton);
        this._wakeButton = wakeButton;

        const sleepControls = document.createElement('div');
        sleepControls.className = 'rapier-sleep-controls';
        sleepControls.appendChild(sleepToggle);
        sleepControls.appendChild(sleepMarker);
        sleepControls.appendChild(wakeButton);

        sleepRow.appendChild(sleepLabel);
        sleepRow.appendChild(sleepControls);
        internalGroups.sleeping.body.appendChild(sleepRow);
        this._inputControls.canSleep = { input: sleepToggle, valEl: null, wrap: sleepRow };

        leftCol.appendChild(makeLabel('Wheel Forces'));

        this._inputControls.engineForce = makeRangeControl({
            title: 'Engine (N)',
            min: 0,
            max: 60000,
            step: 100,
            value: this._inputs.engineForce,
            fmt: (v) => formatNum(v, 0),
            help: INPUT_HELP.engineForce,
            helpSystem
        });
        leftCol.appendChild(this._inputControls.engineForce.wrap);

        this._inputControls.brakeForce = makeRangeControl({
            title: 'Brake (N)',
            min: 0,
            max: 25000,
            step: 100,
            value: this._inputs.brakeForce,
            fmt: (v) => formatNum(v, 0),
            help: INPUT_HELP.brakeForce,
            helpSystem
        });
        leftCol.appendChild(this._inputControls.brakeForce.wrap);

        this._inputControls.handbrakeForce = makeRangeControl({
            title: 'Handbrake (N)',
            min: 0,
            max: 25000,
            step: 100,
            value: this._inputs.handbrakeForce,
            fmt: (v) => formatNum(v, 0),
            help: INPUT_HELP.handbrakeForce,
            helpSystem
        });
        leftCol.appendChild(this._inputControls.handbrakeForce.wrap);

        this._inputControls.steerAngle = makeKnobControl({
            title: 'Steering',
            min: -0.8,
            max: 0.8,
            step: 0.01,
            value: this._inputs.steerAngle,
            fmt: (v) => formatNum(v, 2),
            help: INPUT_HELP.steerAngle,
            helpSystem
        });
        leftCol.appendChild(this._inputControls.steerAngle.wrap);

        this._inputControls.groundClearance = makeNumberControl({
            title: 'Ground clearance (m)',
            value: this._vehicleConfig.groundClearance,
            help: INPUT_HELP.groundClearance,
            helpSystem,
            step: 0.01,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.vehicle.body.appendChild(this._inputControls.groundClearance.wrap);

        internalGroups.vehicle.body.appendChild(makeLabel('Wheel placement'));

        this._inputControls.wheelSideInset = makeInlineRangeNumberControl({
            title: 'Side offset (m)',
            min: -0.5,
            max: 0.66,
            step: 0.01,
            value: this._vehicleConfig.wheelSideInset,
            fmt: (v) => formatNum(v, 2),
            help: INPUT_HELP.wheelSideInset,
            helpSystem,
            sliderWidth: '140px',
            inputWidth: '110px'
        });
        internalGroups.vehicle.body.appendChild(this._inputControls.wheelSideInset.wrap);

        this._inputControls.wheelbaseRatio = makeInlineRangeNumberControl({
            title: 'Base ratio',
            min: 0.0,
            max: 1.3,
            step: 0.01,
            value: this._vehicleConfig.wheelbaseRatio,
            fmt: (v) => formatNum(v, 2),
            help: INPUT_HELP.wheelbaseRatio,
            helpSystem,
            sliderWidth: '140px',
            inputWidth: '110px'
        });
        internalGroups.vehicle.body.appendChild(this._inputControls.wheelbaseRatio.wrap);

        this._inputControls.restLength = makeNumberControl({
            title: 'Suspension rest length (m)',
            value: this._vehicleConfig.restLength,
            help: INPUT_HELP.restLength,
            helpSystem,
            step: 0.01,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.suspension.body.appendChild(this._inputControls.restLength.wrap);

        this._inputControls.suspMaxTravel = makeNumberControl({
            title: 'Max travel (m)',
            value: this._tuning.suspension.maxTravel,
            help: INPUT_HELP.suspMaxTravel,
            helpSystem,
            step: 0.01,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.suspension.body.appendChild(this._inputControls.suspMaxTravel.wrap);

        this._inputControls.suspStiffness = makeNumberControl({
            title: 'Stiffness',
            value: this._tuning.suspension.stiffness,
            help: INPUT_HELP.suspStiffness,
            helpSystem,
            min: 0,
            max: 10000,
            step: 10,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.suspension.body.appendChild(this._inputControls.suspStiffness.wrap);

        this._inputControls.suspCompression = makeNumberControl({
            title: 'Compression',
            value: this._tuning.suspension.compression,
            help: INPUT_HELP.suspCompression,
            helpSystem,
            min: 0,
            max: 5,
            step: 0.1,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.suspension.body.appendChild(this._inputControls.suspCompression.wrap);

        this._inputControls.suspRelaxation = makeNumberControl({
            title: 'Relaxation',
            value: this._tuning.suspension.relaxation,
            help: INPUT_HELP.suspRelaxation,
            helpSystem,
            min: 0,
            max: 5,
            step: 0.1,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.suspension.body.appendChild(this._inputControls.suspRelaxation.wrap);

        this._inputControls.suspMaxForce = makeNumberControl({
            title: 'Max force',
            value: this._tuning.suspension.maxForce,
            help: INPUT_HELP.suspMaxForce,
            helpSystem,
            min: 0,
            max: 200000,
            step: 500,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.suspension.body.appendChild(this._inputControls.suspMaxForce.wrap);

        this._inputControls.tireFrictionSlip = makeNumberControl({
            title: 'Friction slip',
            value: this._tuning.tires.frictionSlip,
            help: INPUT_HELP.tireFrictionSlip,
            helpSystem,
            step: 0.1,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.tires.body.appendChild(this._inputControls.tireFrictionSlip.wrap);

        this._inputControls.tireSideStiffness = makeNumberControl({
            title: 'Side friction stiffness',
            value: this._tuning.tires.sideFrictionStiffness,
            help: INPUT_HELP.tireSideStiffness,
            helpSystem,
            step: 0.05,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.tires.body.appendChild(this._inputControls.tireSideStiffness.wrap);

        const resetButton = makeButton('Reset');
        resetButton.classList.add('is-block', 'is-large', 'rapier-reset-button');
        resetButton.title = [
            'Reset: configure and apply a reset to the vehicle body.',
            'Options include position/rotation, linear/angular velocity, plus Live auto-reset scheduling.',
            'Use Apply to reset once; enable Live to repeat the reset automatically.'
        ].join('\n');
        resetButton.addEventListener('click', (event) => {
            event.preventDefault();
            this._openPositionPopup(resetButton, { resetOnApply: true });
        });
        this._resetButton = resetButton;

        const resetDot = document.createElement('span');
        resetDot.className = 'rapier-reset-dot';
        resetButton.appendChild(resetDot);
        this._resetLiveDot = resetDot;
        const forcesManageButton = makeButton('Forces and Impulses');
        forcesManageButton.classList.add('is-block', 'is-large');
        forcesManageButton.title = [
            'Forces and Impulses: apply external inputs to the vehicle body.',
            'Force/Torque are persistent (until reset); Impulse/Torque impulse are instantaneous.',
            '“@ point” applies at a world-space point and can induce rotation.',
            'Use Reset forces/torques to clear persistent effects and the applied log.'
        ].join('\n');
        forcesManageButton.addEventListener('click', (event) => {
            event.preventDefault();
            this._openForcesPopup(forcesManageButton);
        });

        leftCol.appendChild(makeSeparator());

        const gravityRow = document.createElement('div');
        gravityRow.className = 'rapier-gravity-row';

        const gravityLabel = document.createElement('div');
        gravityLabel.textContent = 'Gravity';
        gravityLabel.className = 'rapier-inline-row-label-text rapier-gravity-label';
        appendHelp(gravityLabel, INPUT_HELP.worldGravity, helpSystem);

        const gravityScale = document.createElement('input');
        gravityScale.type = 'range';
        gravityScale.min = '0';
        gravityScale.max = '3';
        gravityScale.step = '0.05';
        gravityScale.value = String(this._tuning.chassis.gravityScale ?? 1);
        gravityScale.className = 'rapier-gravity-slider';

        const gravityScaleOut = document.createElement('div');
        gravityScaleOut.className = 'rapier-gravity-out';
        gravityScaleOut.textContent = `${formatNum(parseFloat(gravityScale.value), 2)}`;

        const gravityButton = makeButton('...', { size: 'small' });
        gravityButton.classList.add('rapier-gravity-button');

        gravityRow.appendChild(gravityLabel);
        gravityRow.appendChild(gravityScale);
        gravityRow.appendChild(gravityScaleOut);
        gravityRow.appendChild(gravityButton);
        leftCol.appendChild(gravityRow);

        this._inputControls.worldGravityX = { input: null, valEl: null };
        this._inputControls.worldGravityY = { input: null, valEl: null };
        this._inputControls.worldGravityZ = { input: null, valEl: null };
        this._inputControls.gravityScale = {
            input: gravityScale,
            valEl: gravityScaleOut,
            wrap: gravityRow,
            fmt: (v) => `${formatNum(v, 2)}`
        };
        this._gravityDisplay = null;
        gravityScale.addEventListener('input', () => {
            const v = parseFloat(gravityScale.value);
            gravityScaleOut.textContent = `${formatNum(v, 2)}`;
        });
        gravityButton.addEventListener('click', (event) => {
            event.preventDefault();
            this._openGravityPopup(gravityButton);
        });

        leftCol.appendChild(internalGroups.ccd.wrap);
        leftCol.appendChild(internalGroups.sleeping.wrap);

        leftCol.appendChild(internalGroups.bodyType.wrap);
        leftCol.appendChild(lockingRow);
        leftCol.appendChild(internalGroups.dominance.wrap);

        const bottomActions = document.createElement('div');
        bottomActions.className = 'rapier-bottom-actions';

        const forcesSeparator = makeSeparator();
        forcesSeparator.classList.add('rapier-separator-tight');
        bottomActions.appendChild(forcesSeparator);
        bottomActions.appendChild(forcesManageButton);
        bottomActions.appendChild(resetButton);
        leftCol.appendChild(bottomActions);

        leftCol.appendChild(makeSeparator());

        const testsButton = makeButton('Run Automated Tests');
        testsButton.classList.add('is-block', 'is-large', 'rapier-tests-button');
        testsButton.addEventListener('click', (event) => {
            event.preventDefault();
            this._openTestsPopup(testsButton);
        });
        leftCol.appendChild(testsButton);
        this._testButtons.push(testsButton);

        const sampleWrap = document.createElement('div');
        sampleWrap.className = 'rapier-sample-wrap';

        const recordButton = makeButton('');
        recordButton.classList.add('is-block', 'is-large', 'rapier-record-button');

        const recordLabel = document.createElement('span');
        recordLabel.textContent = 'Record sample';
        recordLabel.className = 'rapier-record-label';
        recordButton.appendChild(recordLabel);
        this._recordLabel = recordLabel;

        const recordDot = document.createElement('span');
        recordDot.className = 'rapier-record-dot';
        recordButton.appendChild(recordDot);
        this._recordDot = recordDot;

        recordButton.addEventListener('click', () => {
            if (!this._enabled || this._activeTest || this._sampleRecording) return;
            if (this._recordDot) {
                this._recordDot.classList.add('is-visible');
            }
            if (this._recordDotTimer) {
                clearTimeout(this._recordDotTimer);
            }
            this._recordDotTimer = window.setTimeout(() => {
                if (this._recordDot) {
                    this._recordDot.classList.remove('is-visible');
                }
                if (this._recordLabel) {
                    this._recordLabel.textContent = 'Record sample';
                }
                this._showAxisToast('Sample copied to clipboard');
                this._recordDotTimer = null;
            }, 1000);
            this._startSampleRecord();
        });
        sampleWrap.appendChild(recordButton);
        this._recordButton = recordButton;

        leftCol.appendChild(sampleWrap);

        const status = document.createElement('div');
        status.className = 'rapier-status-text';
        status.textContent = '';
        leftCol.appendChild(status);
        this._statusText = status;

        const copyButton = makeButton('Copy Telemetry');
        copyButton.classList.add('is-block', 'is-large', 'hidden');
        copyButton.addEventListener('click', () => {
            this._copyTelemetry().then(() => {
                this._showAxisToast('Telemetry copied to clipboard');
            });
        });
        leftCol.appendChild(copyButton);
        this._copyButton = copyButton;

        const outputPanel = document.createElement('div');
        stylePanel(outputPanel, { interactive: true });
        outputPanel.classList.add('rapier-output-panel');
        outputPanel.appendChild(makeTitle('Rapier Output'));

        this._outputRows.status = makeValueRow('Status', { help: OUTPUT_HELP.status, helpSystem });
        outputPanel.appendChild(this._outputRows.status.row);

        this._outputRows.speed = makeValueRow('Speed (controller)', { help: OUTPUT_HELP.speed, helpSystem, bar: true });
        this._outputRows.speedKph = makeValueRow('Speed (controller)\nkm/h', { help: OUTPUT_HELP.speedKph, helpSystem });
        this._outputRows.speedProj = makeValueRow('Speed (projected)\nforward', { help: OUTPUT_HELP.speedProj, helpSystem, bar: true });
        this._outputRows.yaw = makeValueRow('Yaw (deg)', { help: OUTPUT_HELP.yaw, helpSystem, arrow: true });
        this._outputRows.axes = makeValueRow('Controller axes\nup/forward', { help: OUTPUT_HELP.axes, helpSystem });
        this._outputRows.mass = makeValueRow('Mass (kg)', { help: OUTPUT_HELP.mass, helpSystem });
        this._outputRows.position = makeValueRow('Position (m)', { help: OUTPUT_HELP.position, helpSystem });
        this._outputRows.rotation = makeValueRow('Rotation (quat)', { help: OUTPUT_HELP.rotation, helpSystem });
        this._outputRows.linvel = makeValueRow('Linear velocity (m/s)', { help: OUTPUT_HELP.linvel, helpSystem });
        this._outputRows.angvel = makeValueRow('Angular velocity (rad/s)', { help: OUTPUT_HELP.angvel, helpSystem });
        this._outputRows.contacts = makeValueRow('Wheel contacts', { help: OUTPUT_HELP.contacts, helpSystem, dots: 4 });
        this._outputRows.rayDown = makeValueRow('Ray down hit', { help: OUTPUT_HELP.rayDown, helpSystem });
        this._outputRows.counts = makeValueRow('World counts', { help: OUTPUT_HELP.counts, helpSystem });

        outputPanel.appendChild(this._outputRows.speed.row);
        outputPanel.appendChild(this._outputRows.speedKph.row);
        outputPanel.appendChild(this._outputRows.speedProj.row);
        outputPanel.appendChild(this._outputRows.yaw.row);
        outputPanel.appendChild(this._outputRows.axes.row);
        outputPanel.appendChild(this._outputRows.mass.row);
        outputPanel.appendChild(this._outputRows.position.row);
        outputPanel.appendChild(this._outputRows.rotation.row);
        outputPanel.appendChild(this._outputRows.linvel.row);
        outputPanel.appendChild(this._outputRows.angvel.row);
        outputPanel.appendChild(this._outputRows.contacts.row);
        outputPanel.appendChild(this._outputRows.rayDown.row);
        outputPanel.appendChild(this._outputRows.counts.row);

        outputPanel.appendChild(makeSeparator());
        const wheelsLabel = makeLabel('Wheels');
        appendHelp(wheelsLabel, OUTPUT_HELP.wheels, helpSystem);
        outputPanel.appendChild(wheelsLabel);

        const wheelTable = document.createElement('div');
        wheelTable.className = 'rapier-wheel-table';

        const headerLeft = document.createElement('div');
        headerLeft.textContent = 'Left wheels';
        headerLeft.className = 'rapier-wheel-header';

        const headerRight = headerLeft.cloneNode(true);
        headerRight.textContent = 'Right wheels';

        const makeWheelCell = (wheelLabel) => {
            const cell = document.createElement('div');
            cell.className = 'rapier-wheel-cell';

            const arrow = makeArrowMarker({ size: 14, color: 'rgba(233, 242, 255, 0.9)' });
            arrow.classList.add('rapier-wheel-arrow');
            cell.appendChild(arrow);

            const knob = document.createElement('div');
            knob.className = 'rapier-wheel-knob';
            cell.appendChild(knob);

            const text = document.createElement('div');
            text.className = 'rapier-wheel-text';
            text.textContent = '—';
            cell.appendChild(text);

            const barWrap = document.createElement('div');
            barWrap.className = 'rapier-wheel-bar';

            const barFill = document.createElement('div');
            barFill.className = 'rapier-wheel-bar-fill';
            barWrap.appendChild(barFill);
            cell.appendChild(barWrap);

            const driveBar = document.createElement('div');
            driveBar.className = 'rapier-wheel-drive-bar';

            const driveFill = document.createElement('div');
            driveFill.className = 'rapier-wheel-drive-fill';
            driveBar.appendChild(driveFill);
            cell.appendChild(driveBar);

            cell.addEventListener('mouseenter', () => {
                this.onWheelHover?.(wheelLabel);
            });
            cell.addEventListener('mouseleave', () => {
                this.onWheelHover?.(null);
            });
            return { root: cell, textEl: text, knobEl: knob, arrowEl: arrow, barEl: barFill, driveEl: driveFill, label: wheelLabel };
        };

        wheelTable.appendChild(headerLeft);
        wheelTable.appendChild(headerRight);

        const fl = makeWheelCell('FL');
        const fr = makeWheelCell('FR');
        const rl = makeWheelCell('RL');
        const rr = makeWheelCell('RR');
        this._wheelCells = { fl, fr, rl, rr };

        wheelTable.appendChild(fl.root);
        wheelTable.appendChild(fr.root);
        wheelTable.appendChild(rl.root);
        wheelTable.appendChild(rr.root);

        outputPanel.appendChild(wheelTable);

        const axisLegend = makeAxisLegend();
        root.appendChild(inputPanel);
        root.appendChild(outputPanel);
        root.appendChild(axisLegend.wrap);
        document.body.appendChild(root);

        this._hudRoot = root;
        this._inputPanel = inputPanel;
        this._outputPanel = outputPanel;
        this._axisLegendCoords = axisLegend.coordsEl;
        this._axisLegendCamIcon = axisLegend.camIcon;
        this._axisLegendToast = axisLegend.toastEl;

        if (this._axisLegendCamIcon) {
            this._axisLegendCamIcon.addEventListener('mouseenter', () => {
                this._openCameraPopup(this._axisLegendCamIcon);
            });
        }

        this._refreshInertiaModeBadge();
        this._syncInertiaModeControls();
        this._wireControls();
    }

    _createHelpSystem(root) {
        const tooltip = document.createElement('div');
        tooltip.className = 'rapier-help-tooltip hidden';
        document.body.appendChild(tooltip);
        this._helpTooltip = tooltip;

        const move = (event) => {
            if (!this._helpTooltip || this._helpTooltip.classList.contains('hidden')) return;
            const pad = 12;
            const rect = this._helpTooltip.getBoundingClientRect();
            const x = Math.min(window.innerWidth - rect.width - pad, event.clientX + pad);
            const y = Math.min(window.innerHeight - rect.height - pad, event.clientY + pad);
            this._helpTooltip.style.left = `${Math.max(pad, x)}px`;
            this._helpTooltip.style.top = `${Math.max(pad, y)}px`;
        };

        return {
            show: (text, event) => {
                if (!this._helpTooltip) return;
                this._helpTooltip.textContent = text;
                this._helpTooltip.classList.remove('hidden');
                move(event);
            },
            move,
            hide: () => {
                if (!this._helpTooltip) return;
                this._helpTooltip.classList.add('hidden');
            }
        };
    }

    _wireControls() {
        const wire = (control, key) => {
            if (!control?.input) return;
            const input = control.input;
            const isSelect = input.tagName === 'SELECT';
            const isCheckbox = input.type === 'checkbox';
            const readValue = () => {
                if (isCheckbox) return input.checked;
                if (isSelect) return input.value;
                const value = parseFloat(input.value);
                if (!Number.isFinite(value)) return null;
                return value;
            };
            const eventName = (isCheckbox || isSelect) ? 'change' : 'input';
            input.addEventListener(eventName, () => {
                const value = readValue();
                if (value === null) return;
                this._setInputValue(key, value);
            });
        };

        wire(this._inputControls.bodyType, 'bodyType');
        wire(this._inputControls.translationX, 'translationX');
        wire(this._inputControls.spawnHeight, 'spawnHeight');
        wire(this._inputControls.translationZ, 'translationZ');
        wire(this._inputControls.rotationW, 'rotationW');
        wire(this._inputControls.rotationX, 'rotationX');
        wire(this._inputControls.rotationY, 'rotationY');
        wire(this._inputControls.rotationZ, 'rotationZ');
        wire(this._inputControls.linvelX, 'linvelX');
        wire(this._inputControls.linvelY, 'linvelY');
        wire(this._inputControls.linvelZ, 'linvelZ');
        wire(this._inputControls.angvelX, 'angvelX');
        wire(this._inputControls.angvelY, 'angvelY');
        wire(this._inputControls.angvelZ, 'angvelZ');
        wire(this._inputControls.worldGravityX, 'worldGravityX');
        wire(this._inputControls.worldGravityY, 'worldGravityY');
        wire(this._inputControls.worldGravityZ, 'worldGravityZ');
        wire(this._inputControls.gravityScale, 'gravityScale');
        wire(this._inputControls.forceX, 'forceX');
        wire(this._inputControls.forceY, 'forceY');
        wire(this._inputControls.forceZ, 'forceZ');
        wire(this._inputControls.forcePointX, 'forcePointX');
        wire(this._inputControls.forcePointY, 'forcePointY');
        wire(this._inputControls.forcePointZ, 'forcePointZ');
        wire(this._inputControls.torqueX, 'torqueX');
        wire(this._inputControls.torqueY, 'torqueY');
        wire(this._inputControls.torqueZ, 'torqueZ');
        wire(this._inputControls.impulseX, 'impulseX');
        wire(this._inputControls.impulseY, 'impulseY');
        wire(this._inputControls.impulseZ, 'impulseZ');
        wire(this._inputControls.impulsePointX, 'impulsePointX');
        wire(this._inputControls.impulsePointY, 'impulsePointY');
        wire(this._inputControls.impulsePointZ, 'impulsePointZ');
        wire(this._inputControls.torqueImpulseX, 'torqueImpulseX');
        wire(this._inputControls.torqueImpulseY, 'torqueImpulseY');
        wire(this._inputControls.torqueImpulseZ, 'torqueImpulseZ');
        wire(this._inputControls.additionalMass, 'additionalMass');
        wire(this._inputControls.massPropsMass, 'massPropsMass');
        wire(this._inputControls.massPropsDensity, 'massPropsDensity');
        wire(this._inputControls.inertiaMode, 'inertiaMode');
        wire(this._inputControls.massPropsComX, 'massPropsComX');
        wire(this._inputControls.massPropsComY, 'massPropsComY');
        wire(this._inputControls.massPropsComZ, 'massPropsComZ');
        wire(this._inputControls.massPropsInertiaX, 'massPropsInertiaX');
        wire(this._inputControls.massPropsInertiaY, 'massPropsInertiaY');
        wire(this._inputControls.massPropsInertiaZ, 'massPropsInertiaZ');
        wire(this._inputControls.massPropsFrameW, 'massPropsFrameW');
        wire(this._inputControls.massPropsFrameX, 'massPropsFrameX');
        wire(this._inputControls.massPropsFrameY, 'massPropsFrameY');
        wire(this._inputControls.massPropsFrameZ, 'massPropsFrameZ');
        wire(this._inputControls.lockTranslations, 'lockTranslations');
        wire(this._inputControls.lockRotations, 'lockRotations');
        wire(this._inputControls.enabledRotX, 'enabledRotX');
        wire(this._inputControls.enabledRotY, 'enabledRotY');
        wire(this._inputControls.enabledRotZ, 'enabledRotZ');
        wire(this._inputControls.linearDamping, 'linearDamping');
        wire(this._inputControls.angularDamping, 'angularDamping');
        wire(this._inputControls.dominanceGroup, 'dominanceGroup');
        wire(this._inputControls.ccdEnabled, 'ccdEnabled');
        wire(this._inputControls.canSleep, 'canSleep');
        wire(this._inputControls.engineForce, 'engineForce');
        wire(this._inputControls.brakeForce, 'brakeForce');
        wire(this._inputControls.handbrakeForce, 'handbrakeForce');
        wire(this._inputControls.steerAngle, 'steerAngle');
        wire(this._inputControls.groundClearance, 'groundClearance');
        wire(this._inputControls.wheelSideInset, 'wheelSideInset');
        wire(this._inputControls.restLength, 'restLength');
        wire(this._inputControls.wheelbaseRatio, 'wheelbaseRatio');
        wire(this._inputControls.suspMaxTravel, 'suspMaxTravel');
        wire(this._inputControls.suspStiffness, 'suspStiffness');
        wire(this._inputControls.suspCompression, 'suspCompression');
        wire(this._inputControls.suspRelaxation, 'suspRelaxation');
        wire(this._inputControls.suspMaxForce, 'suspMaxForce');
        wire(this._inputControls.tireFrictionSlip, 'tireFrictionSlip');
        wire(this._inputControls.tireSideStiffness, 'tireSideStiffness');
    }

    _setInputValue(key, value) {
        let next = value;
        if (key === 'bodyType') {
            this._tuning.chassis.bodyType = String(next);
        } else if (key === 'translationX') {
            this._tuning.chassis.translation.x = next;
        } else if (key === 'spawnHeight') {
            this._vehicleConfig.spawnHeight = next;
            this._tuning.chassis.translation.y = next;
        } else if (key === 'translationZ') {
            this._tuning.chassis.translation.z = next;
        } else if (key === 'rotationW') {
            this._tuning.chassis.rotation.w = next;
        } else if (key === 'rotationX') {
            this._tuning.chassis.rotation.x = next;
        } else if (key === 'rotationY') {
            this._tuning.chassis.rotation.y = next;
        } else if (key === 'rotationZ') {
            this._tuning.chassis.rotation.z = next;
        } else if (key === 'linvelX') {
            this._tuning.chassis.linvel.x = next;
        } else if (key === 'linvelY') {
            this._tuning.chassis.linvel.y = next;
        } else if (key === 'linvelZ') {
            this._tuning.chassis.linvel.z = next;
        } else if (key === 'angvelX') {
            this._tuning.chassis.angvel.x = next;
        } else if (key === 'angvelY') {
            this._tuning.chassis.angvel.y = next;
        } else if (key === 'angvelZ') {
            this._tuning.chassis.angvel.z = next;
        } else if (key === 'worldGravityX') {
            this._worldConfig.gravity.x = next;
        } else if (key === 'worldGravityY') {
            this._worldConfig.gravity.y = next;
        } else if (key === 'worldGravityZ') {
            this._worldConfig.gravity.z = next;
        } else if (key === 'forceX') {
            this._forces.force.x = next;
        } else if (key === 'forceY') {
            this._forces.force.y = next;
        } else if (key === 'forceZ') {
            this._forces.force.z = next;
        } else if (key === 'forcePointX') {
            this._forces.forcePoint.x = next;
        } else if (key === 'forcePointY') {
            this._forces.forcePoint.y = next;
        } else if (key === 'forcePointZ') {
            this._forces.forcePoint.z = next;
        } else if (key === 'torqueX') {
            this._forces.torque.x = next;
        } else if (key === 'torqueY') {
            this._forces.torque.y = next;
        } else if (key === 'torqueZ') {
            this._forces.torque.z = next;
        } else if (key === 'impulseX') {
            this._forces.impulse.x = next;
        } else if (key === 'impulseY') {
            this._forces.impulse.y = next;
        } else if (key === 'impulseZ') {
            this._forces.impulse.z = next;
        } else if (key === 'impulsePointX') {
            this._forces.impulsePoint.x = next;
        } else if (key === 'impulsePointY') {
            this._forces.impulsePoint.y = next;
        } else if (key === 'impulsePointZ') {
            this._forces.impulsePoint.z = next;
        } else if (key === 'torqueImpulseX') {
            this._forces.torqueImpulse.x = next;
        } else if (key === 'torqueImpulseY') {
            this._forces.torqueImpulse.y = next;
        } else if (key === 'torqueImpulseZ') {
            this._forces.torqueImpulse.z = next;
        } else if (key === 'lockTranslations') {
            this._tuning.chassis.lockTranslations = !!next;
        } else if (key === 'lockRotations') {
            this._tuning.chassis.lockRotations = !!next;
        } else if (key === 'enabledRotX') {
            this._tuning.chassis.enabledRotations.x = !!next;
        } else if (key === 'enabledRotY') {
            this._tuning.chassis.enabledRotations.y = !!next;
        } else if (key === 'enabledRotZ') {
            this._tuning.chassis.enabledRotations.z = !!next;
        } else if (key === 'dominanceGroup') {
            this._tuning.chassis.dominanceGroup = next;
        } else if (key === 'ccdEnabled') {
            this._tuning.chassis.ccdEnabled = !!next;
        } else if (key === 'canSleep') {
            this._tuning.chassis.canSleep = !!next;
        } else if (key === 'engineForce') {
            this._inputs.engineForce = next;
        } else if (key === 'brakeForce') {
            this._inputs.brakeForce = next;
        } else if (key === 'handbrakeForce') {
            this._inputs.handbrakeForce = next;
        } else if (key === 'steerAngle') {
            this._inputs.steerAngle = next;
        } else if (key === 'groundClearance') {
            this._vehicleConfig.groundClearance = next;
        } else if (key === 'wheelSideInset') {
            this._vehicleConfig.wheelSideInset = next;
        } else if (key === 'restLength') {
            this._vehicleConfig.restLength = next;
        } else if (key === 'wheelbaseRatio') {
            this._vehicleConfig.wheelbaseRatio = next;
        } else if (key === 'additionalMass') {
            this._tuning.chassis.additionalMass = next;
            this._syncInertiaModeControls();
        } else if (key === 'autoInertia') {
            this._tuning.chassis.additionalMassProperties.inertiaMode = !!next ? 'auto' : 'manual';
            this._recomputeAutoInertia();
            this._refreshInertiaModeBadge();
            this._syncInertiaPopupState();
            this._syncComPopupState();
            this._syncInertiaModeControls();
            this._emitComPreview();
        } else if (key === 'inertiaMode') {
            const mode = String(next).toLowerCase();
            if (mode === 'manual' || mode === 'auto' || mode === 'rapier') {
                this._tuning.chassis.additionalMassProperties.inertiaMode = mode;
                next = mode;
            }
            this._recomputeAutoInertia();
            this._refreshInertiaModeBadge();
            this._syncInertiaPopupState();
            this._syncComPopupState();
            this._syncInertiaModeControls();
            this._emitComPreview();
        } else if (key === 'massPropsMass') {
            this._tuning.chassis.additionalMassProperties.mass = next;
            this._recomputeAutoInertia();
            this._syncInertiaModeControls();
        } else if (key === 'massPropsDensity') {
            this._tuning.chassis.additionalMassProperties.density = next;
            this._syncInertiaModeControls();
        } else if (key === 'massPropsComX') {
            this._tuning.chassis.additionalMassProperties.com.x = next;
            this._emitComPreview();
        } else if (key === 'massPropsComY') {
            this._tuning.chassis.additionalMassProperties.com.y = next;
            this._emitComPreview();
        } else if (key === 'massPropsComZ') {
            this._tuning.chassis.additionalMassProperties.com.z = next;
            this._emitComPreview();
        } else if (key === 'massPropsInertiaX') {
            if (resolveInertiaMode(this._tuning.chassis.additionalMassProperties) === 'manual') {
                this._tuning.chassis.additionalMassProperties.inertia.x = Math.round(next);
            }
        } else if (key === 'massPropsInertiaY') {
            if (resolveInertiaMode(this._tuning.chassis.additionalMassProperties) === 'manual') {
                this._tuning.chassis.additionalMassProperties.inertia.y = Math.round(next);
            }
        } else if (key === 'massPropsInertiaZ') {
            if (resolveInertiaMode(this._tuning.chassis.additionalMassProperties) === 'manual') {
                this._tuning.chassis.additionalMassProperties.inertia.z = Math.round(next);
            }
        } else if (key === 'massPropsFrameW') {
            if (resolveInertiaMode(this._tuning.chassis.additionalMassProperties) === 'manual') {
                this._tuning.chassis.additionalMassProperties.inertiaFrame.w = next;
            }
        } else if (key === 'massPropsFrameX') {
            if (resolveInertiaMode(this._tuning.chassis.additionalMassProperties) === 'manual') {
                this._tuning.chassis.additionalMassProperties.inertiaFrame.x = next;
            }
        } else if (key === 'massPropsFrameY') {
            if (resolveInertiaMode(this._tuning.chassis.additionalMassProperties) === 'manual') {
                this._tuning.chassis.additionalMassProperties.inertiaFrame.y = next;
            }
        } else if (key === 'massPropsFrameZ') {
            if (resolveInertiaMode(this._tuning.chassis.additionalMassProperties) === 'manual') {
                this._tuning.chassis.additionalMassProperties.inertiaFrame.z = next;
            }
        } else if (key === 'linearDamping') {
            this._tuning.chassis.linearDamping = next;
        } else if (key === 'angularDamping') {
            this._tuning.chassis.angularDamping = next;
        } else if (key === 'gravityScale') {
            this._tuning.chassis.gravityScale = next;
        } else if (key === 'suspMaxTravel') {
            this._tuning.suspension.maxTravel = next;
        } else if (key === 'suspStiffness') {
            this._tuning.suspension.stiffness = next;
        } else if (key === 'suspCompression') {
            this._tuning.suspension.compression = next;
        } else if (key === 'suspRelaxation') {
            this._tuning.suspension.relaxation = next;
        } else if (key === 'suspMaxForce') {
            this._tuning.suspension.maxForce = next;
        } else if (key === 'tireFrictionSlip') {
            this._tuning.tires.frictionSlip = next;
        } else if (key === 'tireSideStiffness') {
            this._tuning.tires.sideFrictionStiffness = next;
        }

        const control = this._inputControls[key];
        if (control?.input) {
            if (control.input.type === 'checkbox') {
                control.input.checked = !!next;
            } else {
                control.input.value = String(next);
            }
            if (typeof control.update === 'function') {
                control.update(next);
            } else if (control.valEl) {
                control.valEl.textContent = control.fmt(next);
            }
        }
        if (key === 'worldGravityX' || key === 'worldGravityY' || key === 'worldGravityZ') {
            this._updateGravityDisplay();
        }
        if (key === 'autoInertia' || key === 'inertiaMode' || key === 'massPropsMass') {
            this._syncInertiaPopupState();
        }
    }

    _refreshInertiaModeBadge() {
        if (!this._inertiaAutoPill) return;
        const mode = resolveInertiaMode(this._tuning?.chassis?.additionalMassProperties);
        if (mode === 'auto') {
            this._inertiaAutoPill.textContent = 'AUTO';
            this._inertiaAutoPill.classList.remove('hidden');
            this._inertiaAutoPill.classList.add('is-auto');
            this._inertiaAutoPill.classList.remove('is-rapier');
            return;
        }
        if (mode === 'rapier') {
            this._inertiaAutoPill.textContent = 'RAPIER';
            this._inertiaAutoPill.classList.remove('hidden');
            this._inertiaAutoPill.classList.add('is-rapier');
            this._inertiaAutoPill.classList.remove('is-auto');
            return;
        }
        this._inertiaAutoPill.classList.add('hidden');
        this._inertiaAutoPill.classList.remove('is-auto');
        this._inertiaAutoPill.classList.remove('is-rapier');
    }

    _syncInertiaModeControls() {
        const mode = resolveInertiaMode(this._tuning?.chassis?.additionalMassProperties);
        const props = this._tuning?.chassis?.additionalMassProperties ?? {};
        const cfg = this._vehicleConfig ?? {};
        const width = Number.isFinite(cfg.width) ? cfg.width : null;
        const height = Number.isFinite(cfg.height) ? cfg.height : null;
        const length = Number.isFinite(cfg.length) ? cfg.length : null;
        const volume = (width && height && length) ? (width * height * length) : null;

        const densityRaw = props.density;
        const densityOverride = (Number.isFinite(densityRaw) && densityRaw > 0) ? densityRaw : null;
        const massRaw = props.mass;
        const fallbackMassRaw = this._tuning?.chassis?.additionalMass;
        const targetMass = (Number.isFinite(massRaw) && massRaw > 0)
            ? massRaw
            : ((Number.isFinite(fallbackMassRaw) && fallbackMassRaw > 0) ? fallbackMassRaw : null);
        const densityFromMass = (volume && targetMass) ? (targetMass / volume) : null;
        const resolvedDensity = densityOverride ?? (Number.isFinite(densityFromMass) && densityFromMass > 0 ? densityFromMass : 1);
        const resolvedMass = volume ? resolvedDensity * volume : null;

        if (this._inputControls.massPropsDensity?.wrap) {
            this._inputControls.massPropsDensity.wrap.classList.toggle('hidden', mode !== 'rapier');
        }

        if (this._comButton) {
            this._comButton.disabled = mode === 'rapier';
            this._comButton.textContent = mode === 'rapier' ? '-' : '...';
        }
        if (this._inertiaButton) {
            this._inertiaButton.disabled = mode === 'rapier';
            this._inertiaButton.textContent = mode === 'rapier' ? '-' : '...';
        }

        if (this._inertiaModeNote) {
            if (mode === 'manual') {
                this._inertiaModeNote.textContent = 'Manual: uses Mass props mass + COM + inertia values.';
            } else if (mode === 'auto') {
                this._inertiaModeNote.textContent = 'Auto: inertia is computed from Mass props mass and chassis box size.';
            } else if (mode === 'rapier') {
                const densityLine = densityOverride
                    ? `${formatNum(densityOverride, 2)} kg/m³ (manual)`
                    : (Number.isFinite(densityFromMass) ? `${formatNum(densityFromMass, 2)} kg/m³ (from mass)` : '1.00 kg/m³ (default)');
                const volumeLine = Number.isFinite(volume) ? `${formatNum(volume, 2)} m³` : 'n/a';
                const massLine = Number.isFinite(resolvedMass) ? `${formatNum(resolvedMass, 0)} kg` : 'n/a';
                this._inertiaModeNote.textContent =
                    `Rapier: mass/COM/inertia come from chassis collider density.\n` +
                    `Density: ${densityLine}  •  Volume: ${volumeLine}\n` +
                    `Resulting mass: ${massLine} (from density)`;
            } else {
                this._inertiaModeNote.textContent = '';
            }
        }
    }

    _recomputeAutoInertia() {
        const props = this._tuning?.chassis?.additionalMassProperties ?? null;
        if (!props || resolveInertiaMode(props) !== 'auto') return;
        if (!Number.isFinite(props.mass) || props.mass <= 0) return;

        const cfg = this._vehicleConfig ?? {};
        const inertia = computeBoxInertia(props.mass, cfg.width, cfg.height, cfg.length);
        const target = props.inertia ?? (props.inertia = { x: 0, y: 0, z: 0 });
        target.x = inertia.x;
        target.y = inertia.y;
        target.z = inertia.z;

        const frame = props.inertiaFrame ?? (props.inertiaFrame = { w: 1, x: 0, y: 0, z: 0 });
        frame.w = 1;
        frame.x = 0;
        frame.y = 0;
        frame.z = 0;

        this._syncInertiaPopupState();
    }

    _syncInertiaPopupState() {
        const fields = this._inertiaPopupFields;
        if (!fields) return;
        const props = this._tuning?.chassis?.additionalMassProperties ?? {};
        const mode = resolveInertiaMode(props);
        const readOnly = mode !== 'manual';

        if (fields.modeValueEl) {
            fields.modeValueEl.textContent = mode === 'rapier'
                ? 'Rapier'
                : (mode === 'auto' ? 'Auto' : 'Manual');
        }
        if (fields.noteEl) {
            const note = mode === 'auto'
                ? 'Auto mode: inertia and inertia-frame are computed from mass and chassis box size.'
                : (mode === 'rapier'
                    ? 'Rapier mode: inertia comes from the chassis collider density (inertia inputs are ignored).'
                    : '');
            fields.noteEl.textContent = note;
            fields.noteEl.classList.toggle('hidden', !note);
        }
        if (fields.resetButton) {
            fields.resetButton.disabled = mode === 'rapier';
        }

        const inertia = props.inertia ?? {};
        const frame = props.inertiaFrame ?? {};
        const apply = (input, value, { disabled = false, integer = false } = {}) => {
            if (!input) return;
            input.disabled = disabled;
            if (mode === 'rapier') {
                input.value = '';
                input.placeholder = '-';
                return;
            }
            input.placeholder = '';
            if (integer) {
                input.value = Number.isFinite(value) ? String(Math.round(value)) : '';
            } else {
                input.value = Number.isFinite(value) ? String(value) : '';
            }
        };

        apply(fields.inertiaInputs?.x, inertia.x, { disabled: readOnly, integer: true });
        apply(fields.inertiaInputs?.y, inertia.y, { disabled: readOnly, integer: true });
        apply(fields.inertiaInputs?.z, inertia.z, { disabled: readOnly, integer: true });

        apply(fields.frameInputs?.w, frame.w, { disabled: readOnly });
        apply(fields.frameInputs?.x, frame.x, { disabled: readOnly });
        apply(fields.frameInputs?.y, frame.y, { disabled: readOnly });
        apply(fields.frameInputs?.z, frame.z, { disabled: readOnly });
    }

    _startSampleRecord() {
        if (!this._enabled || this._activeTest || this._sampleRecording) return;
        this._sampleRecording = true;
        this._sampleElapsed = 0;
        this._sampleFrames = [];
        this._sampleConfig = this._buildSampleConfig();
        if (this._statusText) this._statusText.textContent = '';
        if (this._recordButton) this._recordButton.disabled = true;
        if (this._recordLabel) this._recordLabel.textContent = 'Recording';
    }

    _recordSampleFrame(snapshot) {
        if (!this._sampleRecording || !this._sampleFrames) return;
        this._sampleFrames.push(this._packSampleFrame(snapshot, this._sampleElapsed));
    }

    _finishSampleRecord() {
        if (!this._sampleRecording) return;
        this._sampleRecording = false;
        const payload = JSON.stringify({ c: this._sampleConfig ?? null, f: this._sampleFrames ?? [] });
        const done = (ok) => {
            if (this._statusText) this._statusText.textContent = '';
            this._sampleFrames = null;
            this._sampleConfig = null;
            this._sampleElapsed = 0;
            if (this._recordButton) {
                this._recordButton.disabled = !this._enabled || !!this._activeTest || this._sampleRecording;
            }
            if (this._recordLabel && !this._recordDotTimer) {
                this._recordLabel.textContent = 'Record sample';
            }
        };
        try {
            navigator.clipboard.writeText(payload).then(() => done(true)).catch(() => done(false));
        } catch {
            done(false);
        }
    }

    _buildSampleConfig() {
        const inputs = this._inputs ?? {};
        const vehicle = this._vehicleConfig ?? {};
        const tuning = this._tuning ?? {};
        const chassis = tuning.chassis ?? {};
        const massProps = chassis.additionalMassProperties ?? {};
        const suspension = tuning.suspension ?? {};
        const tires = tuning.tires ?? {};
        const world = this._worldConfig ?? {};
        const gravity = world.gravity ?? {};
        return {
            i: {
                e: qNum(inputs.engineForce, 0),
                b: qNum(inputs.brakeForce, 0),
                h: qNum(inputs.handbrakeForce, 0),
                s: qNum(inputs.steerAngle, 3)
            },
            v: {
                sh: qNum(vehicle.spawnHeight, 3),
                gc: qNum(vehicle.groundClearance, 3),
                rl: qNum(vehicle.restLength, 3),
                wbr: qNum(vehicle.wheelbaseRatio, 3),
                wso: qNum(vehicle.wheelSideInset, 3)
            },
            t: {
                bt: chassis.bodyType ?? null,
                tr: packVec3(chassis.translation, 3),
                rot: packQuat(chassis.rotation, 4),
                lv: packVec3(chassis.linvel, 3),
                av: packVec3(chassis.angvel, 3),
                am: qNum(chassis.additionalMass, 1),
                ld: qNum(chassis.linearDamping, 3),
                ad: qNum(chassis.angularDamping, 3),
                gs: qNum(chassis.gravityScale, 3),
                cs: typeof chassis.canSleep === 'boolean' ? (chassis.canSleep ? 1 : 0) : null,
                ccd: typeof chassis.ccdEnabled === 'boolean' ? (chassis.ccdEnabled ? 1 : 0) : null,
                dg: Number.isFinite(chassis.dominanceGroup) ? chassis.dominanceGroup : null,
                lt: typeof chassis.lockTranslations === 'boolean' ? (chassis.lockTranslations ? 1 : 0) : null,
                lr: typeof chassis.lockRotations === 'boolean' ? (chassis.lockRotations ? 1 : 0) : null,
                er: [
                    chassis.enabledRotations?.x ? 1 : 0,
                    chassis.enabledRotations?.y ? 1 : 0,
                    chassis.enabledRotations?.z ? 1 : 0
                ],
                mp: {
                    im: (() => {
                        const mode = resolveInertiaMode(massProps);
                        if (mode === 'manual') return 0;
                        if (mode === 'auto') return 1;
                        if (mode === 'rapier') return 2;
                        return null;
                    })(),
                    m: qNum(massProps.mass, 1),
                    d: qNum(massProps.density, 3),
                    com: packVec3(massProps.com, 3),
                    in: packVec3(massProps.inertia, 3),
                    fr: packQuat(massProps.inertiaFrame, 4)
                }
            },
            s: {
                mt: qNum(suspension.maxTravel, 3),
                st: qNum(suspension.stiffness, 1),
                cp: qNum(suspension.compression, 1),
                rl: qNum(suspension.relaxation, 1),
                mf: qNum(suspension.maxForce, 1)
            },
            ti: {
                fs: qNum(tires.frictionSlip, 3),
                ss: qNum(tires.sideFrictionStiffness, 3)
            },
            w: {
                g: packVec3(gravity, 3)
            }
        };
    }

    _packSampleFrame(snapshot, elapsed) {
        const body = snapshot?.body ?? {};
        const contacts = snapshot?.contacts ?? {};
        const wheels = snapshot?.wheelStates ?? [];
        return {
            t: Math.round((elapsed ?? 0) * 1000),
            st: snapshot?.status ?? null,
            p: packVec3(body.position, 3),
            r: packQuat(body.rotation, 4),
            lv: packVec3(body.linvel, 3),
            av: packVec3(body.angvel, 3),
            sp: qNum(snapshot?.speedMps, 3),
            sp2: qNum(snapshot?.speedProjMps, 3),
            y: qNum(snapshot?.yawRad, 4),
            c: [contacts.count ?? 0, contacts.total ?? 0],
            w: wheels.map((w) => [
                w?.index ?? null,
                w?.inContact ? 1 : 0,
                qNum(w?.suspensionLength, 3),
                qNum(w?.suspensionForce, 1),
                qNum(w?.forwardImpulse, 2),
                qNum(w?.sideImpulse, 2),
                qNum(Number.isFinite(w?.steering) ? -w.steering : w?.steering, 3)
            ])
        };
    }

    _startTest(test) {
        if (!test) return;
        this._activeTest = test;
        this._telemetry = [];
        this._telemetryMeta = {
            id: test.id,
            label: test.label,
            startedAt: new Date().toISOString()
        };
        this._testElapsed = 0;
        this._stepElapsed = 0;
        this._testStepIndex = 0;
        if (this._copyButton) this._copyButton.classList.add('hidden');
        if (this._statusText) this._statusText.textContent = '';
        this._openTestPopup(test);

        this.setEnabled(this._enabled);
    }

    _advanceTest(dt) {
        if (!this._activeTest) return;

        const steps = this._activeTest.steps ?? [];
        const curStep = steps[this._testStepIndex];
        if (!curStep) {
            this._finishTest();
            return;
        }

        this._testElapsed += dt;
        this._stepElapsed += dt;

        if (this._stepElapsed >= curStep.duration) {
            this._stepElapsed = 0;
            this._testStepIndex += 1;
            if (this._testStepIndex >= steps.length) {
                this._finishTest();
                return;
            }
        }

        const active = steps[this._testStepIndex];
        if (active?.input) {
            for (const [k, v] of Object.entries(active.input)) {
                if (Number.isFinite(v)) this._setInputValue(k, v);
            }
        }
    }

    _finishTest() {
        this._activeTest = null;
        if (this._statusText) this._statusText.textContent = '';
        if (this._copyButton) this._copyButton.classList.add('hidden');
        this._setTestPopupState('done');
        this.setEnabled(this._enabled);
    }

    _recordTelemetry(snapshot) {
        if (!this._telemetry) return;
        this._telemetry.push({
            t: this._testElapsed,
            input: { ...this._inputs },
            output: snapshot
        });
    }

    async _copyTelemetry() {
        if (!this._telemetry || !this._telemetryMeta) return false;
        const payload = JSON.stringify({ meta: this._telemetryMeta, frames: this._telemetry }, null, 2);
        try {
            await navigator.clipboard.writeText(payload);
            if (this._statusText) this._statusText.textContent = '';
            return true;
        } catch {
            if (this._statusText) this._statusText.textContent = '';
            return false;
        }
    }

    _resetInitialPosition() {
        this._activeTest = null;
        this._testElapsed = 0;
        this._stepElapsed = 0;
        this._testStepIndex = 0;
        this._telemetry = null;
        this._telemetryMeta = null;
        if (this._copyButton) this._copyButton.classList.add('hidden');
        this._sampleRecording = false;
        this._sampleElapsed = 0;
        this._sampleFrames = null;
        this._sampleConfig = null;
        if (this._recordButton) {
            this._recordButton.disabled = !this._enabled || !!this._activeTest || this._sampleRecording;
        }

        this._setInputValue('engineForce', 0);
        this._setInputValue('brakeForce', 0);
        this._setInputValue('handbrakeForce', 0);
        this._setInputValue('steerAngle', 0);

        this.onResetForces?.();
        this._setForceLogEntry('const-force', null);
        this._clearForceEventLog({ category: 'force', keepConstants: true });
        this.onResetTorques?.();
        this._setForceLogEntry('const-torque', null);
        this._clearForceEventLog({ category: 'torque', keepConstants: true });

        if (this._statusText) this._statusText.textContent = '';
        this.setEnabled(this._enabled);
        this.onReset?.();
    }
}
