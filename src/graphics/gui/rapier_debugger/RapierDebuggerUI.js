// src/graphics/gui/rapier_debugger/RapierDebuggerUI.js
const INPUT_HELP = {
    engineForce: 'Sets the forward force applied by the wheel on the chassis. Start around 8000-20000 for this scale.',
    brakeForce: 'Sets the maximum braking impulse applied by the wheel to slow down the vehicle. Use similar order as engine force.',
    handbrakeForce: 'Extra rear-wheel braking impulse. Often 0.5x to 1.2x brake force.',
    steerAngle: 'Sets the steering angle (radians) for the wheel. Typical +/-0.2 to 0.6.',
    bodyType: 'Rigid-body type: dynamic reacts to forces, fixed is immovable, kinematic is user-driven.',
    translation: 'Rigid-body translation in world space (meters).',
    rotation: 'Rigid-body rotation as a unit quaternion.',
    linvel: 'Initial linear velocity (m/s).',
    angvel: 'Initial angular velocity (axis times rad/s).',
    worldGravity: 'World gravity vector (m/s^2). Slider controls gravity scale for this body.',
    gravityScale: 'Scales gravity for this body (0 disables, negative flips). Typical 0.5 to 2.',
    canSleep: 'Allow this body to sleep when it becomes idle. Marker: green=awake, red=sleeping.',
    ccdEnabled: 'Enable continuous collision detection to reduce tunneling.',
    dominanceGroup: 'Dominance group [-127, 127]. Keep small values like -1, 0, 1.',
    lockTranslations: 'Lock translations along all axes.',
    lockRotations: 'Lock rotations along all axes.',
    enabledRotations: 'Enable rotation per axis (X/Y/Z).',
    force: 'Persistent force added in chassis local space (X=right, Y=up, Z=forward). Scale with mass.',
    forcePoint: 'Local point on the chassis box for applying a force (meters).',
    torque: 'Persistent torque in chassis local space. Scale with mass and size.',
    impulse: 'Instantaneous impulse in chassis local space. Scale with mass.',
    impulsePoint: 'Local point on the chassis box for applying an impulse (meters).',
    torqueImpulse: 'Instantaneous torque impulse in chassis local space. Scale with mass and size.',
    forcesPanelForce: 'Force (persistent) adds a continuous push every physics step and changes linear velocity.\n\nAdd force acts at the center of mass (COM), so it does not create torque.\n\nForce @ point applies at a point on the body. If that point is not at the COM, it also creates torque: torque = (point - COM) Ã— force.\n\nReset forces clears the linear component. If you used Force @ point (or the COM is offset), reset torques too to clear the rotational component.',
    forcesPanelTorque: 'Torque (persistent) adds a continuous twist every physics step and changes angular velocity.\n\nTorque does not directly translate the body.\n\nReset torques clears persistent torque inputs (including torque generated by Force @ point).',
    forcesPanelImpulse: 'Impulse is a one-shot change to velocity.\n\nApply impulse changes linear velocity. Impulse @ point can also change angular velocity when the point is not at the COM (same cross-product rule).\n\nImpulses are not persistent; use Reset All Velocities to clear their effect.',
    spawnHeight: 'Initial translation Y when spawning or resetting.',
    groundClearance: 'Ride height before suspension. Often 0.2-0.4 of wheel radius.',
    wheelSideInset: 'Wheel side offset from chassis side. Positive widens track. Zero keeps wheel outer face flush; typical 0-0.2x wheel width.',
    restLength: 'Sets the rest length of the wheel suspension spring. Often 0.3-0.6 of wheel radius.',
    wheelbaseRatio: 'Wheel Z position as a fraction of chassis length. Typical 0.6-0.75.',
    additionalMass: 'Additional mass before collider contributions. Typical 0-100000 kg (start at 0).',
    linearDamping: 'Linear damping coefficient. Typical 0 to 1.',
    angularDamping: 'Angular damping coefficient. Typical 0 to 2.',
    massPropsMass: 'Overrides additional mass when full mass properties are set.',
    massPropsComX: 'Additional mass properties center of mass X (local chassis space).',
    massPropsComY: 'Additional mass properties center of mass Y (local chassis space).',
    massPropsComZ: 'Additional mass properties center of mass Z (local chassis space).',
    massPropsInertiaX: 'Principal inertia X. Roughly mass * size^2.',
    massPropsInertiaY: 'Principal inertia Y. Roughly mass * size^2.',
    massPropsInertiaZ: 'Principal inertia Z. Roughly mass * size^2.',
    massPropsFrameW: 'Inertia frame W. Keep quaternion normalized.',
    massPropsFrameX: 'Inertia frame X. Keep quaternion normalized.',
    massPropsFrameY: 'Inertia frame Y. Keep quaternion normalized.',
    massPropsFrameZ: 'Inertia frame Z. Keep quaternion normalized.',
    inertia: 'Principal inertia values override how rotational mass is distributed.',
    inertiaFrame: 'Quaternion that orients the inertia tensor in body space.',
    locking: 'Locks translations or rotations for this rigid body.',
    suspMaxTravel: 'Sets the maximum distance the suspension can travel before and after its resting length. Typical 0.1-0.3.',
    suspStiffness: 'Sets the wheel suspension stiffness. Typical 0-10000 N/m (start around 500).',
    suspCompression: 'Wheel suspension compression damping. Typical 0.0-5.0 (start around 1.0).',
    suspRelaxation: 'Wheel suspension relaxation damping. Typical 0.0-5.0 (start around 1.0).',
    suspMaxForce: 'Sets the maximum force applied by the wheel suspension. Typical 0-50000 N (start around 10000).',
    tireFrictionSlip: 'Sets the parameter controlling how much traction the tire has. Typical 6-10.',
    tireSideStiffness: 'Multiplier of friction between the tire and the collider it is on top of. Typical 1-2.'
};

const OUTPUT_HELP = {
    status: 'Simulation status from the physics step.',
    speed: 'Controller speed along vehicle forward axis.',
    speedKph: 'Controller speed in km/h.',
    speedProj: 'Projected speed along world forward.',
    yaw: 'Yaw angle in degrees.',
    axes: 'Vehicle controller axis indices.',
    mass: 'Computed rigid-body mass.',
    position: 'Rigid-body position in world space (m).',
    rotation: 'Rigid-body rotation quaternion.',
    linvel: 'Rigid-body linear velocity (m/s).',
    angvel: 'Rigid-body angular velocity (rad/s).',
    contacts: 'wheelIsInContact for each wheel. Dots are FL, FR, RL, RR (front to rear, left to right).',
    rayDown: 'Ray cast down hit and time of impact.',
    counts: 'Rigid-body and collider counts.',
    wheels: 'Per-wheel: contact uses wheelIsInContact, steer uses wheelSteering (rad), suspension length/force use wheelSuspensionLength and wheelSuspensionForce, impulses use wheelForwardImpulse and wheelSideImpulse. Connect L is wheelChassisConnectionPointCs (chassis space).'
};

function formatNum(value, digits = 2) {
    if (!Number.isFinite(value)) return 'n/a';
    return value.toFixed(digits);
}

function padLeft(str, width) {
    if (str.length >= width) return str;
    return `${' '.repeat(width - str.length)}${str}`;
}

function scalePx(value, factor) {
    if (typeof value === 'number' && Number.isFinite(value)) return `${value * factor}px`;
    if (typeof value === 'string' && value.endsWith('px')) {
        const num = parseFloat(value);
        if (Number.isFinite(num)) return `${num * factor}px`;
    }
    return value;
}

function outNum(value, digits = 2, width = 8) {
    if (!Number.isFinite(value)) return padLeft('n/a', width);
    const normalized = Math.abs(value) < 1e-9 ? 0 : value;
    return padLeft(normalized.toFixed(digits), width);
}

function outVec3(v, digits = 2, width = 8) {
    if (!v) return `${outNum(NaN, digits, width)}, ${outNum(NaN, digits, width)}, ${outNum(NaN, digits, width)}`;
    return `${outNum(v.x, digits, width)}, ${outNum(v.y, digits, width)}, ${outNum(v.z, digits, width)}`;
}

function qNum(value, digits = 3) {
    return Number.isFinite(value) ? Number(value.toFixed(digits)) : null;
}

function packVec3(v, digits = 3) {
    return [qNum(v?.x, digits), qNum(v?.y, digits), qNum(v?.z, digits)];
}

function packQuat(q, digits = 4) {
    return [qNum(q?.x, digits), qNum(q?.y, digits), qNum(q?.z, digits), qNum(q?.w, digits)];
}

function formatVec3(v, digits = 2) {
    if (!v) return 'n/a';
    return `${formatNum(v.x, digits)}, ${formatNum(v.y, digits)}, ${formatNum(v.z, digits)}`;
}

function vecNonZero(v, eps = 1e-4) {
    if (!v) return false;
    return (Math.abs(v.x) > eps) || (Math.abs(v.y) > eps) || (Math.abs(v.z) > eps);
}

function crossVec3(a, b) {
    return {
        x: (a?.y ?? 0) * (b?.z ?? 0) - (a?.z ?? 0) * (b?.y ?? 0),
        y: (a?.z ?? 0) * (b?.x ?? 0) - (a?.x ?? 0) * (b?.z ?? 0),
        z: (a?.x ?? 0) * (b?.y ?? 0) - (a?.y ?? 0) * (b?.x ?? 0)
    };
}

function makeHudRoot() {
    const root = document.createElement('div');
    root.style.position = 'fixed';
    root.style.inset = '0';
    root.style.pointerEvents = 'none';
    root.style.display = 'flex';
    root.style.flexWrap = 'wrap';
    root.style.justifyContent = 'space-between';
    root.style.alignItems = 'flex-start';
    root.style.alignContent = 'flex-start';
    root.style.padding = '16px';
    root.style.gap = '16px';
    root.style.zIndex = '60';
    return root;
}

function stylePanel(el, { interactive = false } = {}) {
    el.style.pointerEvents = interactive ? 'auto' : 'none';
    el.style.userSelect = 'none';
    el.style.minWidth = '280px';
    el.style.maxWidth = '440px';
    el.style.boxSizing = 'border-box';
    el.style.background = 'rgba(10, 14, 20, 0.55)';
    el.style.border = '1px solid rgba(255,255,255,0.12)';
    el.style.backdropFilter = 'blur(8px)';
    el.style.borderRadius = '14px';
    el.style.padding = '12px 14px';
    el.style.color = '#e9f2ff';
    el.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, Arial';
    el.style.boxShadow = '0 10px 28px rgba(0,0,0,0.35)';
}

function makeTitle(text) {
    const t = document.createElement('div');
    t.textContent = text;
    t.style.fontWeight = '800';
    t.style.fontSize = '14px';
    t.style.letterSpacing = '0.6px';
    t.style.textTransform = 'uppercase';
    t.style.opacity = '0.92';
    t.style.marginBottom = '10px';
    return t;
}

function makePopupCloseButton(onClose) {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.textContent = 'x';
    btn.style.width = '24px';
    btn.style.height = '24px';
    btn.style.borderRadius = '8px';
    btn.style.border = '1px solid rgba(255,255,255,0.16)';
    btn.style.background = 'rgba(12, 16, 24, 0.85)';
    btn.style.color = '#e9f2ff';
    btn.style.fontWeight = '900';
    btn.style.fontSize = '12px';
    btn.style.lineHeight = '1';
    btn.style.cursor = 'pointer';
    btn.style.opacity = '0.7';
    btn.style.display = 'grid';
    btn.style.placeItems = 'center';
    btn.style.padding = '0';

    btn.addEventListener('pointerdown', (event) => {
        event.stopPropagation();
    });
    btn.addEventListener('mouseenter', () => {
        btn.style.opacity = '1';
        btn.style.background = 'rgba(255,255,255,0.12)';
    });
    btn.addEventListener('mouseleave', () => {
        btn.style.opacity = '0.7';
        btn.style.background = 'rgba(12, 16, 24, 0.85)';
    });
    if (typeof onClose === 'function') {
        btn.addEventListener('click', (event) => {
            event.preventDefault();
            onClose();
        });
    }

    return btn;
}

function makePopupHeader(text, onClose) {
    const header = document.createElement('div');
    header.style.display = 'flex';
    header.style.alignItems = 'center';
    header.style.justifyContent = 'space-between';
    header.style.gap = '10px';

    const title = makeTitle(text);
    title.style.marginBottom = '0';
    title.style.flex = '1';

    const closeBtn = makePopupCloseButton(onClose);

    header.appendChild(title);
    header.appendChild(closeBtn);

    return { header, title, closeBtn };
}

function makePopupDraggable(wrap, handle) {
    if (!wrap || !handle) return;
    handle.style.cursor = 'grab';
    handle.style.userSelect = 'none';
    handle.style.touchAction = 'none';

    const onPointerDown = (event) => {
        if (event.button !== 0) return;
        event.preventDefault();
        const rect = wrap.getBoundingClientRect();
        const offsetX = event.clientX - rect.left;
        const offsetY = event.clientY - rect.top;
        wrap.style.left = `${rect.left}px`;
        wrap.style.top = `${rect.top}px`;
        wrap.style.bottom = '';
        wrap.style.right = '';
        handle.style.cursor = 'grabbing';

        const onPointerMove = (moveEvent) => {
            wrap.style.left = `${moveEvent.clientX - offsetX}px`;
            wrap.style.top = `${moveEvent.clientY - offsetY}px`;
        };

        const onPointerUp = () => {
            handle.style.cursor = 'grab';
            window.removeEventListener('pointermove', onPointerMove);
            window.removeEventListener('pointerup', onPointerUp);
            window.removeEventListener('pointercancel', onPointerUp);
        };

        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
        window.addEventListener('pointercancel', onPointerUp);
    };

    handle.addEventListener('pointerdown', onPointerDown);
}

function makeLabel(text) {
    const l = document.createElement('div');
    l.textContent = text;
    l.style.fontSize = '12px';
    l.style.fontWeight = '800';
    l.style.opacity = '0.85';
    l.style.marginTop = '10px';
    l.style.marginBottom = '6px';
    l.style.textTransform = 'uppercase';
    l.style.letterSpacing = '0.4px';
    return l;
}

function makeSeparator() {
    const hr = document.createElement('div');
    hr.style.height = '1px';
    hr.style.margin = '10px 0';
    hr.style.background = 'rgba(255,255,255,0.10)';
    return hr;
}

function makeGroup(title, { tightTop = false, showLabel = true } = {}) {
    const wrap = document.createElement('div');
    const body = document.createElement('div');
    if (showLabel) {
        const label = makeLabel(title);
        if (tightTop) {
            label.style.marginTop = '0';
        }
        wrap.appendChild(label);
    }
    wrap.appendChild(body);
    return { wrap, body };
}

function appendHelp(labelEl, helpText, helpSystem) {
    if (!helpText || !helpSystem) return;
    const help = document.createElement('span');
    help.textContent = '?';
    help.style.display = 'inline-flex';
    help.style.alignItems = 'center';
    help.style.justifyContent = 'center';
    help.style.width = '16px';
    help.style.height = '16px';
    help.style.marginLeft = '6px';
    help.style.borderRadius = '999px';
    help.style.border = '1px solid rgba(255,255,255,0.35)';
    help.style.fontSize = '11px';
    help.style.fontWeight = '700';
    help.style.opacity = '0.85';
    help.style.cursor = 'default';
    help.style.pointerEvents = 'auto';
    help.addEventListener('mouseenter', (e) => helpSystem.show(helpText, e));
    help.addEventListener('mousemove', (e) => helpSystem.move(e));
    help.addEventListener('mouseleave', () => helpSystem.hide());
    labelEl.appendChild(help);
}

function makeRangeControl({
    title,
    min,
    max,
    step,
    value,
    fmt,
    help,
    helpSystem,
    showLabel = true,
    sliderFirst = false,
    showHelp = true
}) {
    const wrap = document.createElement('div');
    wrap.style.margin = '8px 0 10px';

    const head = document.createElement('div');
    head.style.display = 'flex';
    head.style.alignItems = 'baseline';
    head.style.justifyContent = 'space-between';
    head.style.gap = '10px';

    const label = document.createElement('div');
    label.textContent = title;
    label.style.fontSize = '13px';
    label.style.fontWeight = '700';
    label.style.opacity = '0.95';
    label.style.display = 'flex';
    label.style.alignItems = 'center';
    appendHelp(label, help, helpSystem);

    const val = document.createElement('div');
    val.style.fontSize = '12px';
    val.style.opacity = '0.75';
    val.textContent = fmt(value);

    if (showLabel && !sliderFirst) {
        head.appendChild(label);
        head.appendChild(val);
    }

    const input = document.createElement('input');
    input.type = 'range';
    input.min = String(min);
    input.max = String(max);
    input.step = String(step);
    input.value = String(value);
    input.style.width = '100%';
    input.style.marginTop = showLabel && !sliderFirst ? '6px' : '0';

    if (sliderFirst) {
        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.gap = '8px';
        input.style.flex = '1 1 auto';

        const helpWrap = document.createElement('div');
        helpWrap.style.display = 'inline-flex';
        helpWrap.style.alignItems = 'center';
        helpWrap.style.justifyContent = 'center';
        if (showHelp) {
            appendHelp(helpWrap, help, helpSystem);
        }

        row.appendChild(input);
        if (showHelp) {
            row.appendChild(helpWrap);
        }
        row.appendChild(val);
        wrap.appendChild(row);
    } else {
        if (showLabel) {
            wrap.appendChild(head);
        }
        wrap.appendChild(input);
    }

    return { wrap, input, valEl: showLabel || sliderFirst ? val : null, fmt };
}

function makeInlineRangeNumberControl({
    title,
    min,
    max,
    step,
    value,
    fmt,
    help,
    helpSystem,
    sliderWidth = '140px',
    inputWidth = '110px'
}) {
    const wrap = document.createElement('div');
    wrap.style.margin = '8px 0 10px';

    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.gap = '10px';

    const label = document.createElement('div');
    label.textContent = title;
    label.style.fontSize = '13px';
    label.style.fontWeight = '700';
    label.style.opacity = '0.95';
    label.style.display = 'flex';
    label.style.alignItems = 'center';
    label.style.flex = '1 1 auto';
    label.style.minWidth = '0';
    appendHelp(label, help, helpSystem);

    const controls = document.createElement('div');
    controls.style.display = 'flex';
    controls.style.alignItems = 'center';
    controls.style.justifyContent = 'flex-end';
    controls.style.gap = '10px';
    controls.style.marginLeft = 'auto';

    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = String(min);
    slider.max = String(max);
    slider.step = String(step);
    slider.value = String(value);
    slider.style.flex = `0 0 ${sliderWidth}`;
    slider.style.width = sliderWidth;
    slider.style.cursor = 'pointer';

    const input = document.createElement('input');
    input.type = 'number';
    input.value = Number.isFinite(value) ? String(value) : '';
    input.inputMode = 'decimal';
    input.min = String(min);
    input.max = String(max);
    input.step = String(step);
    input.style.width = scalePx(inputWidth, 0.5);
    input.style.padding = '3px 4px';
    input.style.borderRadius = '8px';
    input.style.border = '1px solid rgba(255,255,255,0.16)';
    input.style.background = 'rgba(8, 12, 18, 0.6)';
    input.style.color = '#e9f2ff';
    input.style.fontWeight = '600';
    input.style.fontSize = '11px';

    const clampNum = (v) => Math.min(max, Math.max(min, v));
    const setBoth = (next, { from = null } = {}) => {
        if (!Number.isFinite(next)) return;
        const clamped = clampNum(next);
        if (from !== 'slider') slider.value = String(clamped);
        if (from !== 'input') input.value = String(clamped);
    };

    setBoth(Number(value));

    slider.addEventListener('input', () => {
        const next = parseFloat(slider.value);
        setBoth(next, { from: 'slider' });
        input.dispatchEvent(new Event('input', { bubbles: true }));
    });

    input.addEventListener('input', () => {
        const next = parseFloat(input.value);
        if (!Number.isFinite(next)) return;
        setBoth(next, { from: 'input' });
    });

    controls.appendChild(slider);
    controls.appendChild(input);
    row.appendChild(label);
    row.appendChild(controls);
    wrap.appendChild(row);

    return { wrap, input, slider, valEl: null, fmt };
}

function makeKnobControl({ title, min, max, step, value, fmt, help, helpSystem, inlineValue = false }) {
    const wrap = document.createElement('div');
    wrap.style.margin = '8px 0 10px';

    const head = document.createElement('div');
    head.style.display = 'flex';
    head.style.alignItems = 'baseline';
    head.style.justifyContent = inlineValue ? 'flex-start' : 'space-between';
    head.style.gap = '10px';

    const label = document.createElement('div');
    label.textContent = title;
    label.style.fontSize = '13px';
    label.style.fontWeight = '700';
    label.style.opacity = '0.95';
    label.style.display = 'flex';
    label.style.alignItems = 'center';
    let inlineVal = null;
    if (inlineValue) {
        inlineVal = document.createElement('span');
        inlineVal.style.marginLeft = '6px';
        inlineVal.style.fontSize = '12px';
        inlineVal.style.opacity = '0.75';
        inlineVal.textContent = fmt(value);
        label.appendChild(inlineVal);
    }
    appendHelp(label, help, helpSystem);

    const val = document.createElement('div');
    val.style.fontSize = '12px';
    val.style.opacity = '0.75';
    val.textContent = fmt(value);

    head.appendChild(label);
    if (!inlineValue) {
        head.appendChild(val);
    }

    const track = document.createElement('div');
    track.style.position = 'relative';
    track.style.height = '18px';
    track.style.marginTop = '6px';

    const line = document.createElement('div');
    line.style.position = 'absolute';
    line.style.left = '6px';
    line.style.right = '6px';
    line.style.top = '50%';
    line.style.height = '2px';
    line.style.transform = 'translateY(-50%)';
    line.style.background = 'rgba(255,255,255,0.3)';
    track.appendChild(line);

    const knob = document.createElement('div');
    knob.style.position = 'absolute';
    knob.style.top = '50%';
    knob.style.width = '12px';
    knob.style.height = '12px';
    knob.style.borderRadius = '999px';
    knob.style.background = '#e9f2ff';
    knob.style.boxShadow = '0 0 0 2px rgba(0,0,0,0.25)';
    knob.style.transform = 'translate(-50%, -50%)';
    track.appendChild(knob);

    const input = document.createElement('input');
    input.type = 'range';
    input.min = String(min);
    input.max = String(max);
    input.step = String(step);
    input.value = String(value);
    input.style.position = 'absolute';
    input.style.inset = '0';
    input.style.width = '100%';
    input.style.height = '100%';
    input.style.opacity = '0';
    input.style.cursor = 'pointer';
    track.appendChild(input);

    const update = (next) => {
        const span = max - min;
        const t = span !== 0 ? (next - min) / span : 0;
        const clamped = Math.min(1, Math.max(0, t));
        knob.style.left = `${clamped * 100}%`;
        if (inlineVal) {
            inlineVal.textContent = fmt(next);
        } else {
            val.textContent = fmt(next);
        }
    };

    update(value);

    wrap.appendChild(head);
    wrap.appendChild(track);

    return { wrap, input, valEl: inlineVal ?? val, fmt, update };
}

function makeNumberControl({
    title,
    value,
    help,
    helpSystem,
    width = '120px',
    min = null,
    max = null,
    step = null,
    sliderWidth = null,
    controlsAlignRight = false
}) {
    const wrap = document.createElement('div');
    wrap.style.margin = '8px 0 10px';
    const scaledWidth = scalePx(width, 0.5);
    const hasMin = min !== null && min !== undefined && Number.isFinite(Number(min));
    const hasMax = max !== null && max !== undefined && Number.isFinite(Number(max));
    const hasStep = step !== null && step !== undefined && Number.isFinite(Number(step));
    const minValue = hasMin ? Number(min) : null;
    const maxValue = hasMax ? Number(max) : null;
    const stepValue = hasStep ? Math.abs(Number(step)) : 1;
    const valueNum = Number.isFinite(value) ? Number(value) : 0;
    const isForceLike = /\(n/i.test(String(title ?? ''));

    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.justifyContent = controlsAlignRight ? 'flex-start' : 'space-between';
    row.style.gap = '10px';

    const label = document.createElement('div');
    label.textContent = title;
    label.style.fontSize = '13px';
    label.style.fontWeight = '700';
    label.style.opacity = '0.95';
    label.style.display = 'flex';
    label.style.alignItems = 'center';
    appendHelp(label, help, helpSystem);

    const slider = document.createElement('input');
    slider.type = 'range';
    if (sliderWidth) {
        slider.style.flex = `0 0 ${sliderWidth}`;
        slider.style.width = sliderWidth;
    } else {
        slider.style.flex = '1';
        slider.style.minWidth = '90px';
    }
    slider.style.height = '18px';
    slider.style.margin = '0';
    slider.style.cursor = 'pointer';
    slider.style.opacity = '0.95';
    slider.step = String(stepValue);

    const autoRange = !(hasMin && hasMax);
    const computeAutoRange = (v) => {
        const base = Math.abs(Number.isFinite(v) ? v : 0);
        const span = isForceLike
            ? Math.max(stepValue * 10000, base * 1.5, 1000)
            : Math.max(stepValue * 200, base * 1.5, stepValue * 10, 1);
        const lo = hasMin ? Number(min) : (base === 0 ? -span : v - span);
        const hi = hasMax ? Number(max) : (base === 0 ? span : v + span);
        return { lo: Math.min(lo, hi), hi: Math.max(lo, hi) };
    };

    const syncSliderRange = (v) => {
        const range = computeAutoRange(v);
        slider.min = String(range.lo);
        slider.max = String(range.hi);
    };

    if (autoRange) syncSliderRange(valueNum);
    else {
        slider.min = String(min);
        slider.max = String(max);
    }

    const input = document.createElement('input');
    input.type = 'number';
    input.value = Number.isFinite(value) ? String(value) : '';
    input.inputMode = 'decimal';
    if (min !== null) input.min = String(min);
    if (max !== null) input.max = String(max);
    if (step !== null) input.step = String(step);
    input.style.width = scaledWidth;
    input.style.padding = '3px 4px';
    input.style.borderRadius = '8px';
    input.style.border = '1px solid rgba(255,255,255,0.16)';
    input.style.background = 'rgba(8, 12, 18, 0.6)';
    input.style.color = '#e9f2ff';
    input.style.fontWeight = '600';
    input.style.fontSize = '11px';

    const setBoth = (next, { from = null } = {}) => {
        if (!Number.isFinite(next)) return;
        if (hasMin && next < minValue) next = minValue;
        if (hasMax && next > maxValue) next = maxValue;
        if (autoRange) {
            const currentMin = Number(slider.min);
            const currentMax = Number(slider.max);
            if (!Number.isFinite(currentMin) || !Number.isFinite(currentMax) || next < currentMin || next > currentMax) {
                syncSliderRange(next);
            }
        }
        if (from !== 'slider') slider.value = String(next);
        if (from !== 'input') input.value = String(next);
    };

    setBoth(valueNum);

    slider.addEventListener('input', () => {
        const next = parseFloat(slider.value);
        setBoth(next, { from: 'slider' });
        input.dispatchEvent(new Event('input', { bubbles: true }));
    });

    input.addEventListener('input', () => {
        const next = parseFloat(input.value);
        if (!Number.isFinite(next)) return;
        setBoth(next, { from: 'input' });
    });

    row.appendChild(label);

    if (controlsAlignRight) {
        const controls = document.createElement('div');
        controls.style.display = 'flex';
        controls.style.alignItems = 'center';
        controls.style.justifyContent = 'flex-end';
        controls.style.gap = '10px';
        controls.style.marginLeft = 'auto';
        controls.appendChild(slider);
        controls.appendChild(input);
        row.appendChild(controls);
    } else {
        row.appendChild(slider);
        row.appendChild(input);
    }

    wrap.appendChild(row);

    return { wrap, input, slider, valEl: null };
}

function makeInlineVector3Control({
    title,
    values,
    help,
    helpSystem,
    width = '76px',
    min = null,
    max = null,
    step = null
}) {
    const wrap = document.createElement('div');
    wrap.style.margin = '8px 0 10px';
    const scaledWidth = scalePx(width, 0.5);

    const label = document.createElement('div');
    label.textContent = title;
    label.style.fontSize = '13px';
    label.style.fontWeight = '700';
    label.style.opacity = '0.95';
    label.style.display = 'flex';
    label.style.alignItems = 'center';
    label.style.marginBottom = '6px';
    appendHelp(label, help, helpSystem);
    wrap.appendChild(label);

    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.gap = '10px';

    const makeAxis = (axis) => {
        const axisWrap = document.createElement('div');
        axisWrap.style.display = 'flex';
        axisWrap.style.alignItems = 'center';
        axisWrap.style.gap = '6px';

        const axisLabel = document.createElement('div');
        axisLabel.textContent = axis.toUpperCase();
        axisLabel.style.fontSize = '11px';
        axisLabel.style.fontWeight = '700';
        axisLabel.style.opacity = '0.8';

        const input = document.createElement('input');
        input.type = 'number';
        input.value = Number.isFinite(values?.[axis]) ? String(values[axis]) : '';
        input.inputMode = 'decimal';
        if (min !== null) input.min = String(min);
        if (max !== null) input.max = String(max);
        if (step !== null) input.step = String(step);
        input.style.width = scaledWidth;
        input.style.padding = '3px 4px';
        input.style.borderRadius = '8px';
        input.style.border = '1px solid rgba(255,255,255,0.16)';
        input.style.background = 'rgba(8, 12, 18, 0.6)';
        input.style.color = '#e9f2ff';
        input.style.fontWeight = '600';
        input.style.fontSize = '11px';

        axisWrap.appendChild(axisLabel);
        axisWrap.appendChild(input);
        row.appendChild(axisWrap);
        return input;
    };

    const inputX = makeAxis('x');
    const inputY = makeAxis('y');
    const inputZ = makeAxis('z');

    wrap.appendChild(row);
    return { wrap, inputs: { x: inputX, y: inputY, z: inputZ } };
}

function makeInlineVector3Row({
    title,
    values,
    help,
    helpSystem,
    width = '76px',
    min = null,
    max = null,
    step = null
}) {
    const wrap = document.createElement('div');
    wrap.style.margin = '8px 0 10px';
    const scaledWidth = scalePx(width, 0.5);

    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.justifyContent = 'space-between';
    row.style.gap = '10px';

    const label = document.createElement('div');
    label.textContent = title;
    label.style.fontSize = '13px';
    label.style.fontWeight = '700';
    label.style.opacity = '0.95';
    label.style.display = 'flex';
    label.style.alignItems = 'center';
    appendHelp(label, help, helpSystem);

    const inputsRow = document.createElement('div');
    inputsRow.style.display = 'flex';
    inputsRow.style.alignItems = 'center';
    inputsRow.style.gap = '10px';

    const makeAxis = (axis) => {
        const axisWrap = document.createElement('div');
        axisWrap.style.display = 'flex';
        axisWrap.style.alignItems = 'center';
        axisWrap.style.gap = '6px';

        const axisLabel = document.createElement('div');
        axisLabel.textContent = axis.toUpperCase();
        axisLabel.style.fontSize = '11px';
        axisLabel.style.fontWeight = '700';
        axisLabel.style.opacity = '0.8';

        const input = document.createElement('input');
        input.type = 'number';
        input.value = Number.isFinite(values?.[axis]) ? String(values[axis]) : '';
        input.inputMode = 'decimal';
        if (min !== null) input.min = String(min);
        if (max !== null) input.max = String(max);
        if (step !== null) input.step = String(step);
        input.style.width = scaledWidth;
        input.style.padding = '3px 4px';
        input.style.borderRadius = '8px';
        input.style.border = '1px solid rgba(255,255,255,0.16)';
        input.style.background = 'rgba(8, 12, 18, 0.6)';
        input.style.color = '#e9f2ff';
        input.style.fontWeight = '600';
        input.style.fontSize = '11px';

        axisWrap.appendChild(axisLabel);
        axisWrap.appendChild(input);
        inputsRow.appendChild(axisWrap);
        return input;
    };

    const inputX = makeAxis('x');
    const inputY = makeAxis('y');
    const inputZ = makeAxis('z');

    row.appendChild(label);
    row.appendChild(inputsRow);
    wrap.appendChild(row);

    return { wrap, inputs: { x: inputX, y: inputY, z: inputZ } };
}

function makeInlineValueRowWithButton({
    title,
    valueText,
    help,
    helpSystem,
    buttonLabel = '...'
}) {
    const wrap = document.createElement('div');
    wrap.style.margin = '8px 0 10px';

    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.gap = '10px';

    const label = document.createElement('div');
    label.textContent = title;
    label.style.fontSize = '13px';
    label.style.fontWeight = '700';
    label.style.opacity = '0.95';
    label.style.display = 'flex';
    label.style.alignItems = 'center';
    appendHelp(label, help, helpSystem);

    const value = document.createElement('div');
    value.textContent = valueText;
    value.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, monospace';
    value.style.fontVariantNumeric = 'tabular-nums';
    value.style.fontSize = '11px';
    value.style.opacity = '0.9';
    value.style.flex = '1 1 auto';

    const button = document.createElement('button');
    button.type = 'button';
    button.textContent = buttonLabel;
    button.style.padding = '4px 8px';
    button.style.borderRadius = '8px';
    button.style.border = '1px solid rgba(255,255,255,0.16)';
    button.style.background = 'rgba(12, 16, 24, 0.9)';
    button.style.color = '#e9f2ff';
    button.style.fontWeight = '700';
    button.style.cursor = 'pointer';

    row.appendChild(label);
    row.appendChild(value);
    row.appendChild(button);
    wrap.appendChild(row);

    return { wrap, valueEl: value, button };
}

function makeToggleControl({ title, value, help, helpSystem }) {
    const wrap = document.createElement('div');
    wrap.style.margin = '8px 0 10px';

    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.justifyContent = 'space-between';
    row.style.gap = '10px';

    const label = document.createElement('div');
    label.textContent = title;
    label.style.fontSize = '13px';
    label.style.fontWeight = '700';
    label.style.opacity = '0.95';
    label.style.display = 'flex';
    label.style.alignItems = 'center';
    appendHelp(label, help, helpSystem);

    const input = document.createElement('input');
    input.type = 'checkbox';
    input.checked = !!value;
    input.style.width = '16px';
    input.style.height = '16px';
    input.style.cursor = 'pointer';

    row.appendChild(label);
    row.appendChild(input);
    wrap.appendChild(row);

    return { wrap, input, valEl: null };
}

function makeSelectControl({ title, value, options = [], help, helpSystem }) {
    const wrap = document.createElement('div');
    wrap.style.margin = '8px 0 10px';

    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.justifyContent = 'space-between';
    row.style.gap = '10px';

    const label = document.createElement('div');
    label.textContent = title;
    label.style.fontSize = '13px';
    label.style.fontWeight = '700';
    label.style.opacity = '0.95';
    label.style.display = 'flex';
    label.style.alignItems = 'center';
    appendHelp(label, help, helpSystem);

    const select = document.createElement('select');
    select.style.width = '180px';
    select.style.padding = '4px 6px';
    select.style.borderRadius = '8px';
    select.style.border = '1px solid rgba(255,255,255,0.16)';
    select.style.background = 'rgba(8, 12, 18, 0.6)';
    select.style.color = '#e9f2ff';
    select.style.fontWeight = '600';

    for (const opt of options) {
        const option = document.createElement('option');
        option.value = String(opt.value);
        option.textContent = String(opt.label);
        select.appendChild(option);
    }
    if (value !== undefined && value !== null) {
        select.value = String(value);
    }

    row.appendChild(label);
    row.appendChild(select);
    wrap.appendChild(row);

    return { wrap, input: select, valEl: null };
}

function makeValueRow(label, { help = null, helpSystem = null, bar = false, arrow = false, dots = 0 } = {}) {
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.justifyContent = 'space-between';
    row.style.gap = '10px';
    row.style.margin = '6px 0';

    const key = document.createElement('div');
    key.textContent = label;
    key.style.fontSize = '12px';
    key.style.fontWeight = '700';
    key.style.opacity = '0.85';
    key.style.whiteSpace = 'pre-line';
    appendHelp(key, help, helpSystem);

    const value = document.createElement('div');
    value.textContent = 'n/a';
    value.style.fontSize = '12px';
    value.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, monospace';
    value.style.fontVariantNumeric = 'tabular-nums';
    value.style.whiteSpace = 'pre';
    value.style.textAlign = 'right';
    value.style.opacity = '0.9';

    const valueWrap = document.createElement('div');
    valueWrap.style.display = 'flex';
    valueWrap.style.flexDirection = 'column';
    valueWrap.style.alignItems = 'flex-end';
    valueWrap.style.gap = '4px';

    const valueLine = document.createElement('div');
    valueLine.style.display = 'flex';
    valueLine.style.alignItems = 'center';
    valueLine.style.gap = '6px';

    let arrowEl = null;
    if (arrow) {
        arrowEl = makeArrowMarker({ size: 14, color: 'rgba(233, 242, 255, 0.9)' });
        valueLine.appendChild(arrowEl);
    }

    valueLine.appendChild(value);
    valueWrap.appendChild(valueLine);

    let barFill = null;
    if (bar) {
        const barWrap = document.createElement('div');
        barWrap.style.width = '120px';
        barWrap.style.height = '6px';
        barWrap.style.borderRadius = '999px';
        barWrap.style.background = 'rgba(255,255,255,0.15)';
        barWrap.style.overflow = 'hidden';

        barFill = document.createElement('div');
        barFill.style.height = '100%';
        barFill.style.width = '0%';
        barFill.style.background = 'rgba(76,255,122,0.85)';
        barWrap.appendChild(barFill);
        valueWrap.appendChild(barWrap);
    }

    let dotEls = null;
    if (dots > 0) {
        const dotWrap = document.createElement('div');
        dotWrap.style.display = 'flex';
        dotWrap.style.alignItems = 'center';
        dotWrap.style.gap = '6px';

        dotEls = [];
        for (let i = 0; i < dots; i++) {
            const dot = document.createElement('div');
            dot.style.width = '8px';
            dot.style.height = '8px';
            dot.style.borderRadius = '999px';
            dot.style.background = 'rgba(255,255,255,0.2)';
            dot.style.boxShadow = '0 0 0 1px rgba(255,255,255,0.15)';
            dotWrap.appendChild(dot);
            dotEls.push(dot);
        }
        valueWrap.appendChild(dotWrap);
    }

    row.appendChild(key);
    row.appendChild(valueWrap);
    return { row, valueEl: value, barEl: barFill, arrowEl, dotEls };
}

function makeArrowMarker({ size = 14, color = 'rgba(233, 242, 255, 0.9)' } = {}) {
    const arrow = document.createElement('div');
    const headWidth = Math.max(6, Math.round(size * 0.6));
    const headHeight = Math.max(6, Math.round(size * 0.5));
    const shaftWidth = Math.max(2, Math.round(size * 0.15));
    const shaftHeight = Math.max(4, size - headHeight - 2);

    arrow.style.position = 'relative';
    arrow.style.width = `${size}px`;
    arrow.style.height = `${size}px`;
    arrow.style.transform = 'rotate(0deg)';
    arrow.style.transformOrigin = '50% 50%';

    const head = document.createElement('div');
    head.style.position = 'absolute';
    head.style.left = '50%';
    head.style.top = '0';
    head.style.width = '0';
    head.style.height = '0';
    head.style.borderLeft = `${Math.round(headWidth / 2)}px solid transparent`;
    head.style.borderRight = `${Math.round(headWidth / 2)}px solid transparent`;
    head.style.borderBottom = `${headHeight}px solid ${color}`;
    head.style.transform = 'translateX(-50%)';

    const shaft = document.createElement('div');
    shaft.style.position = 'absolute';
    shaft.style.left = '50%';
    shaft.style.top = `${headHeight - 1}px`;
    shaft.style.width = `${shaftWidth}px`;
    shaft.style.height = `${shaftHeight}px`;
    shaft.style.background = color;
    shaft.style.borderRadius = '999px';
    shaft.style.transform = 'translateX(-50%)';

    arrow.appendChild(shaft);
    arrow.appendChild(head);
    return arrow;
}

function makeButton(label) {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.textContent = label;
    btn.style.padding = '8px 12px';
    btn.style.borderRadius = '10px';
    btn.style.border = '1px solid rgba(255,255,255,0.16)';
    btn.style.background = 'rgba(12, 16, 24, 0.9)';
    btn.style.color = '#e9f2ff';
    btn.style.fontWeight = '700';
    btn.style.cursor = 'pointer';
    btn.style.marginRight = '8px';
    return btn;
}

function makeAxisLegend() {
    const wrap = document.createElement('div');
    wrap.style.position = 'absolute';
    wrap.style.left = '50%';
    wrap.style.bottom = '12px';
    wrap.style.transform = 'translateX(-50%)';
    wrap.style.overflow = 'visible';
    wrap.style.display = 'flex';
    wrap.style.alignItems = 'center';
    wrap.style.gap = '12px';
    wrap.style.padding = '6px 10px';
    wrap.style.borderRadius = '999px';
    wrap.style.background = 'rgba(10, 14, 20, 0.6)';
    wrap.style.border = '1px solid rgba(255,255,255,0.12)';
    wrap.style.backdropFilter = 'blur(6px)';
    wrap.style.color = '#e9f2ff';
    wrap.style.fontSize = '11px';
    wrap.style.fontWeight = '700';
    wrap.style.letterSpacing = '0.4px';
    wrap.style.textTransform = 'uppercase';

    const addItem = (label, color) => {
        const row = document.createElement('div');
        row.style.display = 'inline-flex';
        row.style.alignItems = 'center';
        row.style.gap = '6px';

        const dot = document.createElement('span');
        dot.style.width = '8px';
        dot.style.height = '8px';
        dot.style.borderRadius = '999px';
        dot.style.background = color;
        dot.style.boxShadow = `0 0 0 1px ${color}`;

        const text = document.createElement('span');
        text.textContent = label;

        row.appendChild(dot);
        row.appendChild(text);
        wrap.appendChild(row);
    };

    addItem('X', '#ff2d2d');
    addItem('Y', '#2fe75c');
    addItem('Z', '#2d7dff');

    const camWrap = document.createElement('div');
    camWrap.style.display = 'inline-flex';
    camWrap.style.alignItems = 'center';
    camWrap.style.gap = '8px';
    camWrap.style.marginLeft = '6px';

    const camIcon = document.createElement('div');
    camIcon.style.width = '16px';
    camIcon.style.height = '11px';
    camIcon.style.borderRadius = '3px';
    camIcon.style.border = '1px solid rgba(233, 242, 255, 0.75)';
    camIcon.style.position = 'relative';
    camIcon.style.boxSizing = 'border-box';
    camIcon.style.cursor = 'pointer';

    const camTop = document.createElement('div');
    camTop.style.position = 'absolute';
    camTop.style.left = '2px';
    camTop.style.top = '-4px';
    camTop.style.width = '6px';
    camTop.style.height = '4px';
    camTop.style.border = '1px solid rgba(233, 242, 255, 0.75)';
    camTop.style.borderBottom = 'none';
    camTop.style.borderRadius = '2px 2px 0 0';
    camTop.style.boxSizing = 'border-box';

    const camLens = document.createElement('div');
    camLens.style.position = 'absolute';
    camLens.style.left = '50%';
    camLens.style.top = '50%';
    camLens.style.width = '6px';
    camLens.style.height = '6px';
    camLens.style.borderRadius = '999px';
    camLens.style.border = '1px solid rgba(233, 242, 255, 0.85)';
    camLens.style.transform = 'translate(-50%, -50%)';
    camLens.style.boxSizing = 'border-box';

    camIcon.appendChild(camTop);
    camIcon.appendChild(camLens);

    const coords = document.createElement('div');
    coords.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, monospace';
    coords.style.fontVariantNumeric = 'tabular-nums';
    coords.style.fontSize = '11px';
    coords.style.opacity = '0.9';
    coords.textContent = 'X:0.00  Y:0.00  Z:0.00';

    camWrap.appendChild(camIcon);
    camWrap.appendChild(coords);
    wrap.appendChild(camWrap);

    const toast = document.createElement('div');
    toast.style.position = 'absolute';
    toast.style.left = '50%';
    toast.style.bottom = '100%';
    toast.style.transform = 'translate(-50%, -8px)';
    toast.style.padding = '6px 10px';
    toast.style.borderRadius = '10px';
    toast.style.background = 'rgba(10, 14, 20, 0.92)';
    toast.style.border = '1px solid rgba(255,255,255,0.18)';
    toast.style.color = '#e9f2ff';
    toast.style.fontSize = '11px';
    toast.style.fontWeight = '700';
    toast.style.boxShadow = '0 8px 20px rgba(0,0,0,0.35)';
    toast.style.whiteSpace = 'nowrap';
    toast.style.display = 'none';
    toast.style.zIndex = '90';
    wrap.appendChild(toast);

    return { wrap, coordsEl: coords, camIcon, toastEl: toast };
}

const PRESET_TESTS = [
    {
        id: 'straight_brake',
        label: 'Test 1: Throttle + Brake',
        steps: [
            { duration: 1.2, input: { engineForce: 8000, brakeForce: 0, handbrakeForce: 0, steerAngle: 0 } },
            { duration: 3.6, input: { engineForce: 14000, brakeForce: 0, handbrakeForce: 0, steerAngle: 0 } },
            { duration: 2.0, input: { engineForce: 0, brakeForce: 12000, handbrakeForce: 0, steerAngle: 0 } },
            { duration: 1.2, input: { engineForce: 0, brakeForce: 0, handbrakeForce: 0, steerAngle: 0 } }
        ]
    },
    {
        id: 'steer_sweep',
        label: 'Test 2: Steer Sweep',
        steps: [
            { duration: 1.6, input: { engineForce: 9000, brakeForce: 0, handbrakeForce: 0, steerAngle: 0 } },
            { duration: 2.4, input: { engineForce: 9000, brakeForce: 0, handbrakeForce: 0, steerAngle: 0.35 } },
            { duration: 2.4, input: { engineForce: 9000, brakeForce: 0, handbrakeForce: 0, steerAngle: -0.35 } },
            { duration: 1.6, input: { engineForce: 0, brakeForce: 10000, handbrakeForce: 0, steerAngle: 0 } }
        ]
    },
    {
        id: 'handbrake_turn',
        label: 'Test 3: Handbrake Turn',
        steps: [
            { duration: 1.6, input: { engineForce: 10000, brakeForce: 0, handbrakeForce: 0, steerAngle: 0.25 } },
            { duration: 1.8, input: { engineForce: 10000, brakeForce: 0, handbrakeForce: 0, steerAngle: 0.45 } },
            { duration: 1.6, input: { engineForce: 0, brakeForce: 0, handbrakeForce: 14000, steerAngle: 0.45 } },
            { duration: 1.6, input: { engineForce: 0, brakeForce: 9000, handbrakeForce: 0, steerAngle: 0 } }
        ]
    }
];

export class RapierDebuggerUI {
    constructor({ vehicleConfig = null, tuning = null, worldConfig = null } = {}) {
        this._hudRoot = null;
        this._inputPanel = null;
        this._outputPanel = null;
        if (this._helpTooltip?.parentElement) {
            this._helpTooltip.parentElement.removeChild(this._helpTooltip);
        }
        this._helpTooltip = null;
        this._helpSystem = null;

        this._inputControls = {};
        this._outputRows = {};
        this._wheelCells = null;
        this._testButtons = [];
        this._actionButtons = [];
        this._statusText = null;
        this._copyButton = null;
        this._recordButton = null;
        this._recordLabel = null;
        this._axisLegendCoords = null;
        this._axisLegendCamIcon = null;
        this._axisLegendToast = null;
        this._axisToastTimer = null;
        this._recordDot = null;
        this._recordDotTimer = null;
        this._gravityDisplay = null;
        this._cameraPopup = null;
        this._cameraPopupHandlers = null;
        this._resetButton = null;
        this._resetButtonBorder = null;
        this._sleepMarker = null;
        this._wakeButton = null;
        this._sleepingState = null;
        this._gravityPopup = null;
        this._gravityPopupHandlers = null;
        this._positionPopup = null;
        this._positionPopupHandlers = null;
        this._comPopup = null;
        this._comPopupHandlers = null;
        this._positionPopupLiveEnabled = false;
        this._positionPopupLiveApply = null;
        this._positionPopupLiveNextAt = 0;
        this._positionPopupLiveInterval = null;
        this._positionPopupLiveIntervalMs = 0;
        this._positionPopupLiveShowTimer = null;
        this._positionPopupLiveHideTimer = null;
        this._positionPopupLiveStatus = null;
        this._positionPopupLiveProgressFill = null;
        this._positionPopupLiveProgressInterval = null;
        this._inertiaPopup = null;
        this._inertiaPopupHandlers = null;
        this._inertiaFramePopup = null;
        this._inertiaFramePopupHandlers = null;
        this._lockingPopup = null;
        this._lockingPopupHandlers = null;
        this._forcesPopup = null;
        this._forcesPopupHandlers = null;
        this._forcePopupControls = null;
        this._forcePopupButtons = null;
        this._forcesPopupGrid = null;
        this._forcesPopupLogCol = null;
        this._forcesPopupLogEl = null;
        this._forceActionLog = [];
        this._forceActionMax = 12;
        this._forceActionSeq = 0;
        this._forceApplyAtPoint = true;
        this._forcesActiveTab = 'force';
        this._testsPopup = null;
        this._testsPopupHandlers = null;
        this._testPopup = null;
        this._testPopupHandlers = null;
        this._testPopupTitle = null;
        this._testPopupButton = null;
        this._testPopupLabel = null;
        this._testPopupDot = null;
        this._testPopupCloseTimer = null;
        this._testPopupEllipsisTimer = null;
        this._liveResetIntervalMs = 3000;
        this._resetLiveDot = null;
        this._resetLiveInterval = null;
        this._resetLiveShowTimer = null;
        this._resetLiveHideTimer = null;
        this._resetLiveNextAt = 0;
        this._resetLiveBlinkTimer = null;
        this._resetLiveBlinkInterval = null;
        this._resetLiveBlinkTimer = null;
        this._resetLiveBlinkInterval = null;

        this._enabled = false;
        this._inputs = {
            engineForce: 0,
            brakeForce: 0,
            handbrakeForce: 0,
            steerAngle: 0
        };

        const baseWorldConfig = worldConfig ?? {};
        const baseGravity = baseWorldConfig.gravity ?? {};
        this._worldConfig = {
            gravity: {
                x: Number.isFinite(baseGravity.x) ? baseGravity.x : 0,
                y: Number.isFinite(baseGravity.y) ? baseGravity.y : -9.81,
                z: Number.isFinite(baseGravity.z) ? baseGravity.z : 0
            }
        };

        this._forces = {
            force: { x: 0, y: 0, z: 0 },
            forcePoint: { x: 0, y: 0, z: 0 },
            torque: { x: 0, y: 0, z: 0 },
            impulse: { x: 0, y: 0, z: 0 },
            impulsePoint: { x: 0, y: 0, z: 0 },
            torqueImpulse: { x: 0, y: 0, z: 0 }
        };

        const baseVehicleConfig = vehicleConfig ?? {};
        this._vehicleConfig = {
            spawnHeight: Number.isFinite(baseVehicleConfig.spawnHeight) ? baseVehicleConfig.spawnHeight : 3,
            groundClearance: Number.isFinite(baseVehicleConfig.groundClearance) ? baseVehicleConfig.groundClearance : 0.24,
            restLength: Number.isFinite(baseVehicleConfig.restLength) ? baseVehicleConfig.restLength : 0.35,
            wheelbaseRatio: Number.isFinite(baseVehicleConfig.wheelbaseRatio) ? baseVehicleConfig.wheelbaseRatio : 0.65,
            wheelSideInset: Number.isFinite(baseVehicleConfig.wheelSideInset) ? baseVehicleConfig.wheelSideInset : 0.08
        };

        const baseTuning = tuning ?? {};
        const baseChassis = baseTuning.chassis ?? {};
        const baseProps = baseChassis.additionalMassProperties ?? {};
        const baseCom = baseProps.com ?? {};
        const baseInertia = baseProps.inertia ?? {};
        const baseFrame = baseProps.inertiaFrame ?? {};
        const baseTranslation = baseChassis.translation ?? {};
        const baseRotation = baseChassis.rotation ?? {};
        const baseLinvel = baseChassis.linvel ?? {};
        const baseAngvel = baseChassis.angvel ?? {};
        const baseEnabledRotations = baseChassis.enabledRotations ?? {};
        const spawnHeight = this._vehicleConfig.spawnHeight;
        this._tuning = {
            chassis: {
                bodyType: typeof baseChassis.bodyType === 'string' ? baseChassis.bodyType : 'dynamic',
                translation: {
                    x: Number.isFinite(baseTranslation.x) ? baseTranslation.x : 0,
                    y: Number.isFinite(baseTranslation.y) ? baseTranslation.y : spawnHeight,
                    z: Number.isFinite(baseTranslation.z) ? baseTranslation.z : 0
                },
                rotation: {
                    x: Number.isFinite(baseRotation.x) ? baseRotation.x : 0,
                    y: Number.isFinite(baseRotation.y) ? baseRotation.y : 0,
                    z: Number.isFinite(baseRotation.z) ? baseRotation.z : 0,
                    w: Number.isFinite(baseRotation.w) ? baseRotation.w : 1
                },
                linvel: {
                    x: Number.isFinite(baseLinvel.x) ? baseLinvel.x : 0,
                    y: Number.isFinite(baseLinvel.y) ? baseLinvel.y : 0,
                    z: Number.isFinite(baseLinvel.z) ? baseLinvel.z : 0
                },
                angvel: {
                    x: Number.isFinite(baseAngvel.x) ? baseAngvel.x : 0,
                    y: Number.isFinite(baseAngvel.y) ? baseAngvel.y : 0,
                    z: Number.isFinite(baseAngvel.z) ? baseAngvel.z : 0
                },
                additionalMass: Number.isFinite(baseChassis.additionalMass) ? baseChassis.additionalMass : 0,
                linearDamping: Number.isFinite(baseChassis.linearDamping) ? baseChassis.linearDamping : 0.32,
                angularDamping: Number.isFinite(baseChassis.angularDamping) ? baseChassis.angularDamping : 1.0,
                gravityScale: Number.isFinite(baseChassis.gravityScale) ? baseChassis.gravityScale : 1.0,
                canSleep: typeof baseChassis.canSleep === 'boolean' ? baseChassis.canSleep : true,
                ccdEnabled: typeof baseChassis.ccdEnabled === 'boolean' ? baseChassis.ccdEnabled : true,
                dominanceGroup: Number.isFinite(baseChassis.dominanceGroup) ? baseChassis.dominanceGroup : 0,
                lockTranslations: typeof baseChassis.lockTranslations === 'boolean' ? baseChassis.lockTranslations : false,
                lockRotations: typeof baseChassis.lockRotations === 'boolean' ? baseChassis.lockRotations : false,
                enabledRotations: {
                    x: typeof baseEnabledRotations.x === 'boolean' ? baseEnabledRotations.x : true,
                    y: typeof baseEnabledRotations.y === 'boolean' ? baseEnabledRotations.y : true,
                    z: typeof baseEnabledRotations.z === 'boolean' ? baseEnabledRotations.z : true
                },
                additionalMassProperties: {
                    mass: Number.isFinite(baseProps.mass) ? baseProps.mass : NaN,
                    com: {
                        x: Number.isFinite(baseCom.x) ? baseCom.x : 0,
                        y: Number.isFinite(baseCom.y) ? baseCom.y : 0,
                        z: Number.isFinite(baseCom.z) ? baseCom.z : 0
                    },
                    inertia: {
                        x: Number.isFinite(baseInertia.x) ? baseInertia.x : 0.3,
                        y: Number.isFinite(baseInertia.y) ? baseInertia.y : 0.2,
                        z: Number.isFinite(baseInertia.z) ? baseInertia.z : 0.1
                    },
                    inertiaFrame: {
                        w: Number.isFinite(baseFrame.w) ? baseFrame.w : 1,
                        x: Number.isFinite(baseFrame.x) ? baseFrame.x : 0,
                        y: Number.isFinite(baseFrame.y) ? baseFrame.y : 0,
                        z: Number.isFinite(baseFrame.z) ? baseFrame.z : 0
                    }
                }
            },
            suspension: {
                maxTravel: Number.isFinite(baseTuning.suspension?.maxTravel) ? baseTuning.suspension.maxTravel : 0.2,
                stiffness: Number.isFinite(baseTuning.suspension?.stiffness) ? baseTuning.suspension.stiffness : 500,
                compression: Number.isFinite(baseTuning.suspension?.compression) ? baseTuning.suspension.compression : 1.0,
                relaxation: Number.isFinite(baseTuning.suspension?.relaxation) ? baseTuning.suspension.relaxation : 1.0,
                maxForce: Number.isFinite(baseTuning.suspension?.maxForce) ? baseTuning.suspension.maxForce : 10000
            },
            tires: {
                frictionSlip: Number.isFinite(baseTuning.tires?.frictionSlip) ? baseTuning.tires.frictionSlip : 8.2,
                sideFrictionStiffness: Number.isFinite(baseTuning.tires?.sideFrictionStiffness) ? baseTuning.tires.sideFrictionStiffness : 1.45
            }
        };

        this.onReset = null;
        this.onResetCamera = null;
        this.onWheelHover = null;
        this.onAddForce = null;
        this.onAddForceAtPoint = null;
        this.onAddTorque = null;
        this.onResetForces = null;
        this.onResetTorques = null;
        this.onApplyImpulse = null;
        this.onApplyImpulseAtPoint = null;
        this.onApplyTorqueImpulse = null;
        this.onResetVelocities = null;
        this.onWakeUp = null;
        this.onSleep = null;
        this.onComPreview = null;

        this._activeTest = null;
        this._testElapsed = 0;
        this._stepElapsed = 0;
        this._testStepIndex = 0;
        this._telemetry = null;
        this._telemetryMeta = null;
        this._sampleRecording = false;
        this._sampleElapsed = 0;
        this._sampleFrames = null;
        this._sampleConfig = null;
    }

    mount() {
        if (this._hudRoot) return;
        this._buildHud();
        this.setEnabled(false);
    }

    unmount() {
        if (this._hudRoot?.parentElement) {
            this._hudRoot.parentElement.removeChild(this._hudRoot);
        }
        this._hudRoot = null;
        this._inputPanel = null;
        this._outputPanel = null;
        this._inputControls = {};
        this._outputRows = {};
        this._wheelCells = null;
        this._testButtons = [];
        this._actionButtons = [];
        this._statusText = null;
        this._copyButton = null;
        this._recordButton = null;
        this._recordLabel = null;
        if (this._helpTooltip?.parentElement) {
            this._helpTooltip.parentElement.removeChild(this._helpTooltip);
        }
        this._helpTooltip = null;
        this._helpSystem = null;
        this._axisLegendCoords = null;
        this._axisLegendToast = null;
        if (this._axisToastTimer) {
            clearTimeout(this._axisToastTimer);
            this._axisToastTimer = null;
        }
        this._recordDot = null;
        if (this._recordDotTimer) {
            clearTimeout(this._recordDotTimer);
            this._recordDotTimer = null;
        }
        this._resetButton = null;
        this._resetButtonBorder = null;
        this._gravityDisplay = null;
        this._closeGravityPopup();
        this._closePositionPopup();
        this._closeCameraPopup();
        this._closeComPopup();
        this._stopLiveReset();
        this._closeInertiaPopup();
        this._closeInertiaFramePopup();
        this._closeLockingPopup();
        this._closeForcesPopup();
        this._closeTestsPopup();
        this._closeTestPopup();
        this._forcePopupControls = null;
        this._forcePopupButtons = null;
        this._forcesPopupGrid = null;
        this._forcesPopupLogCol = null;
        this._forcesPopupLogEl = null;
        this._forceActionLog = [];
        this._forceActionSeq = 0;
        this._forceApplyAtPoint = true;
        this._forcesActiveTab = 'force';
        this._testsPopup = null;
        this._testsPopupHandlers = null;
        this._testPopup = null;
        this._testPopupHandlers = null;
        this._testPopupTitle = null;
        this._testPopupButton = null;
        this._testPopupLabel = null;
        this._testPopupDot = null;
        this._testPopupCloseTimer = null;
        this._testPopupEllipsisTimer = null;
        this._sleepMarker = null;
        this._wakeButton = null;
        this._sleepingState = null;
        this._comPopup = null;
        this._comPopupHandlers = null;
        this._positionPopupLiveEnabled = false;
        this._positionPopupLiveApply = null;
        this._positionPopupLiveNextAt = 0;
        this._positionPopupLiveInterval = null;
        this._positionPopupLiveIntervalMs = 0;
        this._positionPopupLiveShowTimer = null;
        this._positionPopupLiveHideTimer = null;
        this._positionPopupLiveStatus = null;
        this._positionPopupLiveProgressFill = null;
        this._positionPopupLiveProgressInterval = null;
        this._resetLiveDot = null;
        this._resetLiveInterval = null;
        this._resetLiveShowTimer = null;
        this._resetLiveHideTimer = null;
        this._resetLiveNextAt = 0;
        this._activeTest = null;
        this._telemetry = null;
        this._telemetryMeta = null;
        this._sampleRecording = false;
        this._sampleElapsed = 0;
        this._sampleFrames = null;
        this._sampleConfig = null;
    }

    setEnabled(enabled) {
        this._enabled = !!enabled;
        for (const control of Object.values(this._inputControls)) {
            if (control?.input) {
                control.input.disabled = !this._enabled || !!this._activeTest;
            }
        }
        for (const btn of this._testButtons) {
            if (!btn) continue;
            btn.disabled = !this._enabled || !!this._activeTest;
        }
        for (const btn of this._actionButtons) {
            if (!btn) continue;
            btn.disabled = !this._enabled || !!this._activeTest;
        }
        if (this._recordButton) {
            this._recordButton.disabled = !this._enabled || !!this._activeTest || this._sampleRecording;
        }
        if (this._statusText && !this._activeTest) {
            this._statusText.textContent = '';
        }
    }

    setCameraCoords(pos) {
        if (!this._axisLegendCoords) return;
        if (!pos || !Number.isFinite(pos.x) || !Number.isFinite(pos.y) || !Number.isFinite(pos.z)) {
            this._axisLegendCoords.textContent = 'X:n/a  Y:n/a  Z:n/a';
            return;
        }
        this._axisLegendCoords.textContent = `X:${formatNum(pos.x, 2)}  Y:${formatNum(pos.y, 2)}  Z:${formatNum(pos.z, 2)}`;
    }

    _showAxisToast(message, duration = 2000) {
        if (!this._axisLegendToast) return;
        this._axisLegendToast.textContent = message;
        this._axisLegendToast.style.display = 'block';
        if (this._axisToastTimer) {
            clearTimeout(this._axisToastTimer);
        }
        this._axisToastTimer = window.setTimeout(() => {
            if (this._axisLegendToast) {
                this._axisLegendToast.style.display = 'none';
            }
            this._axisToastTimer = null;
        }, duration);
    }

    _openCameraPopup(anchor) {
        this._closeCameraPopup();
        if (!this._hudRoot || !anchor) return;

        const wrap = document.createElement('div');
        wrap.style.position = 'fixed';
        wrap.style.zIndex = '90';
        wrap.style.padding = '10px';
        wrap.style.borderRadius = '10px';
        wrap.style.background = 'rgba(10, 14, 20, 0.92)';
        wrap.style.border = '1px solid rgba(255,255,255,0.18)';
        wrap.style.color = '#e9f2ff';
        wrap.style.boxShadow = '0 10px 28px rgba(0,0,0,0.35)';
        wrap.style.backdropFilter = 'blur(8px)';
        wrap.style.display = 'flex';
        wrap.style.flexDirection = 'column';
        wrap.style.gap = '8px';

        const { header } = makePopupHeader('Camera', () => this._closeCameraPopup());
        wrap.appendChild(header);
        makePopupDraggable(wrap, header);

        const topSeparator = makeSeparator();
        topSeparator.style.margin = '6px 0 4px';
        wrap.appendChild(topSeparator);

        const resetCameraButton = makeButton('Reset camera');
        resetCameraButton.style.padding = '6px 10px';
        resetCameraButton.style.fontSize = '11px';
        resetCameraButton.style.borderRadius = '8px';
        resetCameraButton.style.marginRight = '0';
        resetCameraButton.addEventListener('click', () => {
            this.onResetCamera?.();
            this._closeCameraPopup();
        });
        wrap.appendChild(resetCameraButton);

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const left = Math.min(window.innerWidth - 200, Math.max(pad, rect.left - 80));
        const top = Math.min(window.innerHeight - 120, Math.max(pad, rect.top - 50));
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closeCameraPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeCameraPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._cameraPopup = wrap;
        this._cameraPopupHandlers = { onPointerDown, onKeyDown };
    }

    _closeCameraPopup() {
        if (this._cameraPopup?.parentElement) {
            this._cameraPopup.parentElement.removeChild(this._cameraPopup);
        }
        if (this._cameraPopupHandlers) {
            document.removeEventListener('pointerdown', this._cameraPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._cameraPopupHandlers.onKeyDown);
        }
        this._cameraPopup = null;
        this._cameraPopupHandlers = null;
    }

    _openGravityPopup(anchor) {
        this._closeGravityPopup();
        if (!this._hudRoot || !anchor) return;

        const wrap = document.createElement('div');
        wrap.style.position = 'fixed';
        wrap.style.zIndex = '90';
        wrap.style.padding = '10px';
        wrap.style.borderRadius = '10px';
        wrap.style.background = 'rgba(10, 14, 20, 0.92)';
        wrap.style.border = '1px solid rgba(255,255,255,0.18)';
        wrap.style.color = '#e9f2ff';
        wrap.style.boxShadow = '0 10px 28px rgba(0,0,0,0.35)';
        wrap.style.backdropFilter = 'blur(8px)';
        wrap.style.display = 'flex';
        wrap.style.flexDirection = 'column';
        wrap.style.gap = '8px';
        wrap.style.minWidth = '210px';
        wrap.style.maxWidth = '210px';

        const { header } = makePopupHeader('Gravity', () => this._closeGravityPopup());
        wrap.appendChild(header);
        makePopupDraggable(wrap, header);

        const topSeparator = makeSeparator();
        topSeparator.style.margin = '6px 0 4px';
        wrap.appendChild(topSeparator);

        const makeField = (axis, value) => {
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.alignItems = 'center';
            row.style.justifyContent = 'space-between';
            row.style.gap = '10px';

            const label = document.createElement('div');
            label.textContent = axis;
            label.style.fontSize = '11px';
            label.style.fontWeight = '700';
            label.style.opacity = '0.8';
            label.style.width = '18px';

            const input = document.createElement('input');
            input.type = 'number';
            input.inputMode = 'decimal';
            input.step = '0.1';
            input.value = Number.isFinite(value) ? String(value) : '';
            input.style.width = '80px';
            input.style.padding = '3px 4px';
            input.style.borderRadius = '8px';
            input.style.border = '1px solid rgba(255,255,255,0.16)';
            input.style.background = 'rgba(8, 12, 18, 0.6)';
            input.style.color = '#e9f2ff';
            input.style.fontWeight = '600';
            input.style.fontSize = '11px';

            row.appendChild(label);
            row.appendChild(input);
            wrap.appendChild(row);
            return input;
        };

        const initialGravity = {
            x: this._worldConfig.gravity?.x ?? 0,
            y: this._worldConfig.gravity?.y ?? -9.81,
            z: this._worldConfig.gravity?.z ?? 0
        };

        const inputs = {
            x: makeField('X', initialGravity.x),
            y: makeField('Y', initialGravity.y),
            z: makeField('Z', initialGravity.z)
        };

        const wireLive = (inputEl, key) => {
            inputEl.addEventListener('input', () => {
                const value = parseFloat(inputEl.value);
                if (Number.isFinite(value)) this._setInputValue(key, value);
            });
        };
        wireLive(inputs.x, 'worldGravityX');
        wireLive(inputs.y, 'worldGravityY');
        wireLive(inputs.z, 'worldGravityZ');

        const actions = document.createElement('div');
        actions.style.display = 'flex';
        actions.style.justifyContent = 'flex-end';
        actions.style.gap = '8px';

        const separator = makeSeparator();
        separator.style.margin = '6px 0 4px';
        wrap.appendChild(separator);

        const reset = makeButton('Reset');
        reset.style.padding = '6px 10px';
        reset.style.fontSize = '11px';
        reset.style.borderRadius = '8px';
        reset.style.marginRight = '0';
        reset.addEventListener('click', () => {
            inputs.x.value = String(initialGravity.x);
            inputs.y.value = String(initialGravity.y);
            inputs.z.value = String(initialGravity.z);
            this._setInputValue('worldGravityX', initialGravity.x);
            this._setInputValue('worldGravityY', initialGravity.y);
            this._setInputValue('worldGravityZ', initialGravity.z);
        });

        actions.appendChild(reset);
        wrap.appendChild(actions);

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const popupWidth = 210;
        const left = Math.min(window.innerWidth - popupWidth - pad, Math.max(pad, rect.right + pad));
        const top = Math.min(window.innerHeight - 180, Math.max(pad, rect.top - 8));
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closeGravityPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeGravityPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._gravityPopup = wrap;
        this._gravityPopupHandlers = { onPointerDown, onKeyDown };
    }

    _closeGravityPopup() {
        if (this._gravityPopup?.parentElement) {
            this._gravityPopup.parentElement.removeChild(this._gravityPopup);
        }
        if (this._gravityPopupHandlers) {
            document.removeEventListener('pointerdown', this._gravityPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._gravityPopupHandlers.onKeyDown);
        }
        this._gravityPopup = null;
        this._gravityPopupHandlers = null;
    }

    _updateGravityDisplay() {
        if (!this._gravityDisplay) return;
        const g = this._worldConfig.gravity ?? {};
        const gx = Number.isFinite(g.x) ? formatNum(g.x, 2) : 'n/a';
        const gy = Number.isFinite(g.y) ? formatNum(g.y, 2) : 'n/a';
        const gz = Number.isFinite(g.z) ? formatNum(g.z, 2) : 'n/a';
        this._gravityDisplay.textContent = `${gx}  ${gy}  ${gz}`;
    }

    _openPositionPopup(anchor, { resetOnApply = false } = {}) {
        this._closePositionPopup();
        if (!this._hudRoot || !anchor) return;

        const wrap = document.createElement('div');
        wrap.style.position = 'fixed';
        wrap.style.zIndex = '90';
        wrap.style.padding = '10px';
        wrap.style.borderRadius = '10px';
        wrap.style.background = 'rgba(10, 14, 20, 0.92)';
        wrap.style.border = '1px solid rgba(255,255,255,0.18)';
        wrap.style.color = '#e9f2ff';
        wrap.style.boxShadow = '0 10px 28px rgba(0,0,0,0.35)';
        wrap.style.backdropFilter = 'blur(8px)';
        wrap.style.display = 'flex';
        wrap.style.flexDirection = 'column';
        wrap.style.gap = '8px';
        wrap.style.minWidth = '520px';

        const { header } = makePopupHeader('Reset', () => this._closePositionPopup());
        wrap.appendChild(header);
        makePopupDraggable(wrap, header);

        const topSeparator = makeSeparator();
        topSeparator.style.margin = '6px 0 4px';
        wrap.appendChild(topSeparator);

        const helpSystem = this._helpSystem;

        const makeTableInput = (value, step = 0.1) => {
            const input = document.createElement('input');
            input.type = 'number';
            input.inputMode = 'decimal';
            input.step = String(step);
            input.value = Number.isFinite(value) ? String(value) : '';
            input.style.width = '70px';
            input.style.padding = '3px 4px';
            input.style.borderRadius = '8px';
            input.style.border = '1px solid rgba(255,255,255,0.16)';
            input.style.background = 'rgba(8, 12, 18, 0.6)';
            input.style.color = '#e9f2ff';
            input.style.fontWeight = '600';
            input.style.fontSize = '11px';
            return input;
        };

        const makeTableSlider = (value, { min, max, step }) => {
            const slider = document.createElement('input');
            slider.type = 'range';
            slider.min = String(min);
            slider.max = String(max);
            slider.step = String(step);
            const startValue = Number.isFinite(value) ? Math.min(max, Math.max(min, value)) : 0;
            slider.value = String(startValue);
            slider.style.width = '70px';
            slider.style.cursor = 'pointer';
            return slider;
        };

        const makeHeaderCell = (text) => {
            const cell = document.createElement('div');
            cell.textContent = text;
            cell.style.fontSize = '11px';
            cell.style.fontWeight = '700';
            cell.style.opacity = '0.75';
            cell.style.textAlign = 'center';
            return cell;
        };

        const makeLabelCell = (text, help) => {
            const cell = document.createElement('div');
            cell.style.display = 'grid';
            cell.style.gridTemplateColumns = '1fr auto';
            cell.style.alignItems = 'center';
            cell.style.columnGap = '8px';
            cell.style.fontSize = '11px';
            cell.style.fontWeight = '700';
            cell.style.opacity = '0.85';
            const textSpan = document.createElement('div');
            textSpan.textContent = text;
            textSpan.style.whiteSpace = 'nowrap';
            cell.appendChild(textSpan);
            if (help && helpSystem) {
                appendHelp(cell, help, helpSystem);
                const helpEl = cell.lastElementChild;
                if (helpEl) {
                    helpEl.style.marginLeft = '0';
                    helpEl.style.justifySelf = 'end';
                }
            }
            return cell;
        };

        const makeEmptyCell = () => {
            const cell = document.createElement('div');
            cell.style.minHeight = '22px';
            return cell;
        };

        const makeInputCell = (value, { min, max, step }) => {
            const cell = document.createElement('div');
            cell.style.display = 'flex';
            cell.style.flexDirection = 'column';
            cell.style.alignItems = 'center';
            cell.style.gap = '6px';
            cell.style.justifyContent = 'center';
            const input = makeTableInput(value, step);
            const slider = makeTableSlider(value, { min, max, step });
            input.addEventListener('input', () => {
                const next = parseFloat(input.value);
                if (!Number.isFinite(next)) return;
                const clamped = Math.min(max, Math.max(min, next));
                slider.value = String(clamped);
            });
            slider.addEventListener('input', () => {
                input.value = slider.value;
            });
            cell.appendChild(input);
            cell.appendChild(slider);
            return { cell, input, slider };
        };

        const table = document.createElement('div');
        table.style.display = 'grid';
        table.style.gridTemplateColumns = '200px repeat(4, minmax(0, 1fr))';
        table.style.gap = '8px 10px';
        table.style.alignItems = 'start';

        table.appendChild(makeHeaderCell(''));
        table.appendChild(makeHeaderCell('W'));
        table.appendChild(makeHeaderCell('X'));
        table.appendChild(makeHeaderCell('Y'));
        table.appendChild(makeHeaderCell('Z'));

        const rot = this._tuning?.chassis?.rotation ?? {};
        const rotInputs = {
            w: makeInputCell(rot.w, { min: -1, max: 1, step: 0.01 }),
            x: makeInputCell(rot.x, { min: -1, max: 1, step: 0.01 }),
            y: makeInputCell(rot.y, { min: -1, max: 1, step: 0.01 }),
            z: makeInputCell(rot.z, { min: -1, max: 1, step: 0.01 })
        };
        table.appendChild(makeLabelCell('Rotation', INPUT_HELP.rotation));
        table.appendChild(rotInputs.w.cell);
        table.appendChild(rotInputs.x.cell);
        table.appendChild(rotInputs.y.cell);
        table.appendChild(rotInputs.z.cell);

        const pos = this._tuning?.chassis?.translation ?? {};
        const posInputs = {
            x: makeInputCell(pos.x, { min: -50, max: 50, step: 0.1 }),
            y: makeInputCell(pos.y, { min: -50, max: 50, step: 0.1 }),
            z: makeInputCell(pos.z, { min: -50, max: 50, step: 0.1 })
        };
        table.appendChild(makeLabelCell('Position', INPUT_HELP.translation));
        table.appendChild(makeEmptyCell());
        table.appendChild(posInputs.x.cell);
        table.appendChild(posInputs.y.cell);
        table.appendChild(posInputs.z.cell);

        const linvel = this._tuning?.chassis?.linvel ?? {};
        const linvelInputs = {
            x: makeInputCell(linvel.x, { min: -50, max: 50, step: 0.1 }),
            y: makeInputCell(linvel.y, { min: -50, max: 50, step: 0.1 }),
            z: makeInputCell(linvel.z, { min: -50, max: 50, step: 0.1 })
        };
        table.appendChild(makeLabelCell('Linear velocity (m/s)', INPUT_HELP.linvel));
        table.appendChild(makeEmptyCell());
        table.appendChild(linvelInputs.x.cell);
        table.appendChild(linvelInputs.y.cell);
        table.appendChild(linvelInputs.z.cell);

        const angvel = this._tuning?.chassis?.angvel ?? {};
        const angvelInputs = {
            x: makeInputCell(angvel.x, { min: -20, max: 20, step: 0.1 }),
            y: makeInputCell(angvel.y, { min: -20, max: 20, step: 0.1 }),
            z: makeInputCell(angvel.z, { min: -20, max: 20, step: 0.1 })
        };
        table.appendChild(makeLabelCell('Angular velocity (rad/s)', INPUT_HELP.angvel));
        table.appendChild(makeEmptyCell());
        table.appendChild(angvelInputs.x.cell);
        table.appendChild(angvelInputs.y.cell);
        table.appendChild(angvelInputs.z.cell);

        wrap.appendChild(table);

        const applyValues = ({ reset = false, close = false } = {}) => {
            const resolveVelocityInput = (cell) => {
                const raw = parseFloat(cell.input.value);
                const min = Number.parseFloat(cell.slider.min);
                const max = Number.parseFloat(cell.slider.max);
                const next = Number.isFinite(raw) ? raw : 0;
                const clamped = Math.min(max, Math.max(min, next));
                cell.input.value = String(clamped);
                cell.slider.value = String(clamped);
                return clamped;
            };
            const px = parseFloat(posInputs.x.input.value);
            const py = parseFloat(posInputs.y.input.value);
            const pz = parseFloat(posInputs.z.input.value);
            if (Number.isFinite(px)) this._setInputValue('translationX', px);
            if (Number.isFinite(py)) this._setInputValue('spawnHeight', py);
            if (Number.isFinite(pz)) this._setInputValue('translationZ', pz);
            const rw = parseFloat(rotInputs.w.input.value);
            const rx = parseFloat(rotInputs.x.input.value);
            const ry = parseFloat(rotInputs.y.input.value);
            const rz = parseFloat(rotInputs.z.input.value);
            if (Number.isFinite(rw)) this._setInputValue('rotationW', rw);
            if (Number.isFinite(rx)) this._setInputValue('rotationX', rx);
            if (Number.isFinite(ry)) this._setInputValue('rotationY', ry);
            if (Number.isFinite(rz)) this._setInputValue('rotationZ', rz);
            const lvx = resolveVelocityInput(linvelInputs.x);
            const lvy = resolveVelocityInput(linvelInputs.y);
            const lvz = resolveVelocityInput(linvelInputs.z);
            this._setInputValue('linvelX', lvx);
            this._setInputValue('linvelY', lvy);
            this._setInputValue('linvelZ', lvz);
            const avx = resolveVelocityInput(angvelInputs.x);
            const avy = resolveVelocityInput(angvelInputs.y);
            const avz = resolveVelocityInput(angvelInputs.z);
            this._setInputValue('angvelX', avx);
            this._setInputValue('angvelY', avy);
            this._setInputValue('angvelZ', avz);
            if (reset) this._resetInitialPosition();
            if (close) this._closePositionPopup();
        };

        const actions = document.createElement('div');
        actions.style.display = 'flex';
        actions.style.alignItems = 'center';
        actions.style.justifyContent = 'space-between';
        actions.style.gap = '8px';

        const liveWrap = document.createElement('label');
        liveWrap.style.display = 'inline-flex';
        liveWrap.style.alignItems = 'center';
        liveWrap.style.gap = '6px';
        liveWrap.style.fontSize = '11px';
        liveWrap.style.fontWeight = '700';
        liveWrap.style.opacity = '0.85';
        liveWrap.style.cursor = 'pointer';

        const liveCheckbox = document.createElement('input');
        liveCheckbox.type = 'checkbox';
        liveCheckbox.style.position = 'absolute';
        liveCheckbox.style.opacity = '0';
        liveCheckbox.style.width = '0';
        liveCheckbox.style.height = '0';

        const liveTrack = document.createElement('span');
        liveTrack.style.width = '30px';
        liveTrack.style.height = '16px';
        liveTrack.style.borderRadius = '999px';
        liveTrack.style.background = 'rgba(255,255,255,0.2)';
        liveTrack.style.boxShadow = 'inset 0 0 0 1px rgba(255,255,255,0.2)';
        liveTrack.style.position = 'relative';
        liveTrack.style.transition = 'background 150ms ease';

        const liveKnob = document.createElement('span');
        liveKnob.style.position = 'absolute';
        liveKnob.style.top = '2px';
        liveKnob.style.left = '2px';
        liveKnob.style.width = '12px';
        liveKnob.style.height = '12px';
        liveKnob.style.borderRadius = '999px';
        liveKnob.style.background = '#e9f2ff';
        liveKnob.style.boxShadow = '0 0 6px rgba(0,0,0,0.25)';
        liveKnob.style.transition = 'transform 150ms ease';

        liveTrack.appendChild(liveKnob);

        const liveIntervalMs = this._liveResetIntervalMs;
        const liveIntervalSeconds = formatNum(liveIntervalMs / 1000, liveIntervalMs % 1000 === 0 ? 0 : 1);

        const liveLabel = document.createElement('span');
        liveLabel.textContent = 'Live';
        appendHelp(
            liveLabel,
            `Auto-reset the vehicle using the current reset configuration every ${liveIntervalSeconds}s. Live stays active after closing this panel; the Reset button shows a green border while active.`,
            this._helpSystem
        );

        const syncLiveToggle = () => {
            if (liveCheckbox.checked) {
                liveTrack.style.background = 'rgba(76,255,122,0.45)';
                liveKnob.style.transform = 'translateX(14px)';
            } else {
                liveTrack.style.background = 'rgba(255,255,255,0.2)';
                liveKnob.style.transform = 'translateX(0)';
            }
        };

        liveCheckbox.checked = this._positionPopupLiveEnabled;
        syncLiveToggle();
        liveWrap.appendChild(liveCheckbox);
        liveWrap.appendChild(liveTrack);
        liveWrap.appendChild(liveLabel);

        const liveStatus = document.createElement('span');
        liveStatus.style.display = 'none';
        liveStatus.style.width = '84px';
        liveStatus.style.height = '10px';
        liveStatus.style.borderRadius = '999px';
        liveStatus.style.border = '1px solid rgba(255,255,255,0.16)';
        liveStatus.style.background = 'rgba(255,255,255,0.10)';
        liveStatus.style.overflow = 'hidden';
        liveStatus.style.boxSizing = 'border-box';

        const liveStatusFill = document.createElement('span');
        liveStatusFill.style.display = 'block';
        liveStatusFill.style.height = '100%';
        liveStatusFill.style.width = '100%';
        liveStatusFill.style.borderRadius = '999px';
        liveStatusFill.style.background = 'linear-gradient(270deg, rgba(210,210,210,0.10), rgba(235,235,235,0.55), rgba(210,210,210,0.10))';
        liveStatusFill.style.backgroundSize = '200% 100%';
        liveStatusFill.style.backgroundPosition = '100% 50%';
        liveStatusFill.style.opacity = '0.95';
        liveStatusFill.style.willChange = 'width, background-position';
        liveStatusFill.style.transition = 'width 120ms linear';
        liveStatus.appendChild(liveStatusFill);

        this._positionPopupLiveStatus = liveStatus;
        this._positionPopupLiveProgressFill = liveStatusFill;

        const intervalWrap = document.createElement('div');
        intervalWrap.style.display = 'inline-flex';
        intervalWrap.style.alignItems = 'center';
        intervalWrap.style.gap = '6px';
        intervalWrap.style.fontSize = '11px';
        intervalWrap.style.fontWeight = '700';
        intervalWrap.style.opacity = '0.85';

        const intervalLabel = document.createElement('span');
        intervalLabel.textContent = 'Interval';

        const intervalSlider = document.createElement('input');
        intervalSlider.type = 'range';
        intervalSlider.min = '1';
        intervalSlider.max = '30';
        intervalSlider.step = '1';
        intervalSlider.value = String(Math.min(30, Math.max(1, Math.round(liveIntervalMs / 1000))));
        intervalSlider.style.width = '120px';
        intervalSlider.style.cursor = 'pointer';

        const intervalValue = document.createElement('span');
        intervalValue.textContent = `${intervalSlider.value}s`;

        intervalSlider.addEventListener('input', () => {
            const seconds = parseFloat(intervalSlider.value);
            if (!Number.isFinite(seconds)) return;
            this._liveResetIntervalMs = Math.max(1, seconds) * 1000;
            intervalValue.textContent = `${intervalSlider.value}s`;
            if (this._positionPopupLiveEnabled) {
                this._rescheduleLiveReset();
            }
        });

        intervalWrap.appendChild(intervalLabel);
        intervalWrap.appendChild(intervalSlider);
        intervalWrap.appendChild(intervalValue);

        const liveGroup = document.createElement('div');
        liveGroup.style.display = 'flex';
        liveGroup.style.flexWrap = 'wrap';
        liveGroup.style.alignItems = 'center';
        liveGroup.style.gap = '10px';
        liveGroup.appendChild(liveWrap);
        liveGroup.appendChild(intervalWrap);
        liveGroup.appendChild(liveStatus);

        liveCheckbox.addEventListener('change', () => {
            syncLiveToggle();
            if (liveCheckbox.checked) {
                this._startLiveReset(applyValues, { showToast: true });
            } else {
                this._stopLiveReset();
            }
        });

        if (this._positionPopupLiveEnabled) {
            this._positionPopupLiveApply = applyValues;
            if (!this._positionPopupLiveInterval) {
                this._startLiveReset(applyValues);
            } else {
                this._setResetLiveActive(true);
                this._startLiveProgressTicker();
            }
        }

        const cancel = makeButton('Cancel');
        cancel.style.padding = '6px 10px';
        cancel.style.fontSize = '11px';
        cancel.style.borderRadius = '8px';
        cancel.style.marginRight = '0';
        cancel.addEventListener('click', () => {
            liveCheckbox.checked = false;
            syncLiveToggle();
            this._stopLiveReset();
            this._closePositionPopup();
        });

        const apply = makeButton('Apply');
        apply.style.padding = '6px 10px';
        apply.style.fontSize = '11px';
        apply.style.borderRadius = '8px';
        apply.style.marginRight = '0';
        apply.addEventListener('click', () => {
            applyValues({ reset: resetOnApply, close: true });
        });

        const buttonsSeparator = makeSeparator();
        buttonsSeparator.style.margin = '6px 0 4px';
        wrap.appendChild(buttonsSeparator);

        const buttons = document.createElement('div');
        buttons.style.display = 'flex';
        buttons.style.gap = '8px';
        buttons.appendChild(cancel);
        buttons.appendChild(apply);

        actions.appendChild(liveGroup);
        actions.appendChild(buttons);
        wrap.appendChild(actions);

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const left = Math.min(window.innerWidth - 560, Math.max(pad, rect.right + pad));
        const top = Math.min(window.innerHeight - 360, Math.max(pad, rect.top - 8));
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closePositionPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closePositionPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._positionPopup = wrap;
        this._positionPopupHandlers = { onPointerDown, onKeyDown };
    }

    _closePositionPopup() {
        if (this._positionPopup?.parentElement) {
            this._positionPopup.parentElement.removeChild(this._positionPopup);
        }
        if (this._positionPopupHandlers) {
            document.removeEventListener('pointerdown', this._positionPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._positionPopupHandlers.onKeyDown);
        }
        if (this._positionPopupLiveShowTimer) {
            clearTimeout(this._positionPopupLiveShowTimer);
            this._positionPopupLiveShowTimer = null;
        }
        if (this._positionPopupLiveHideTimer) {
            clearTimeout(this._positionPopupLiveHideTimer);
            this._positionPopupLiveHideTimer = null;
        }
        if (this._positionPopupLiveProgressInterval) {
            clearInterval(this._positionPopupLiveProgressInterval);
            this._positionPopupLiveProgressInterval = null;
        }
        if (this._positionPopupLiveStatus) {
            this._positionPopupLiveStatus.style.display = 'none';
        }
        if (!this._positionPopupLiveEnabled) {
            this._stopLiveReset();
        }
        this._positionPopup = null;
        this._positionPopupHandlers = null;
        this._positionPopupLiveStatus = null;
        this._positionPopupLiveProgressFill = null;
    }

    _getLiveResetIntervalMs() {
        return this._liveResetIntervalMs ?? 3000;
    }

    _rescheduleLiveReset({ showToast = false } = {}) {
        if (!this._positionPopupLiveEnabled || !this._positionPopupLiveApply) return;
        const intervalMs = this._getLiveResetIntervalMs();
        if (intervalMs <= 0) return;

        if (this._positionPopupLiveInterval) {
            clearInterval(this._positionPopupLiveInterval);
            this._positionPopupLiveInterval = null;
        }
        if (this._positionPopupLiveShowTimer) {
            clearTimeout(this._positionPopupLiveShowTimer);
            this._positionPopupLiveShowTimer = null;
        }
        if (this._positionPopupLiveHideTimer) {
            clearTimeout(this._positionPopupLiveHideTimer);
            this._positionPopupLiveHideTimer = null;
        }

        this._positionPopupLiveIntervalMs = intervalMs;
        this._positionPopupLiveNextAt = performance.now() + intervalMs;
        this._startLiveProgressTicker();
        this._updateLiveProgress();
        this._startResetLiveIndicator();

        if (showToast) {
            const seconds = formatNum(intervalMs / 1000, intervalMs % 1000 === 0 ? 0 : 1);
            this._showAxisToast(`Live reset enabled: reset in ${seconds}s`);
        }

        this._positionPopupLiveInterval = window.setInterval(() => {
            this._positionPopupLiveApply?.({ reset: true, close: false });
            const nextIntervalMs = this._getLiveResetIntervalMs();
            if (nextIntervalMs !== this._positionPopupLiveIntervalMs) {
                this._rescheduleLiveReset();
                return;
            }
            this._positionPopupLiveNextAt = performance.now() + nextIntervalMs;
            this._updateLiveProgress();
            this._startResetLiveIndicator();
        }, intervalMs);
    }

    _startLiveReset(applyValues, { showToast = false } = {}) {
        this._positionPopupLiveEnabled = true;
        this._positionPopupLiveApply = applyValues ?? this._positionPopupLiveApply;

        this._setResetLiveActive(true);
        if (this._resetLiveDot) {
            this._resetLiveDot.style.visibility = 'visible';
        }

        this._rescheduleLiveReset({ showToast });
    }

    _stopLiveReset() {
        this._positionPopupLiveEnabled = false;
        this._positionPopupLiveApply = null;
        this._positionPopupLiveNextAt = 0;
        this._positionPopupLiveIntervalMs = 0;
        this._setResetLiveActive(false);
        if (this._positionPopupLiveInterval) {
            clearInterval(this._positionPopupLiveInterval);
            this._positionPopupLiveInterval = null;
        }
        if (this._positionPopupLiveShowTimer) {
            clearTimeout(this._positionPopupLiveShowTimer);
            this._positionPopupLiveShowTimer = null;
        }
        if (this._positionPopupLiveHideTimer) {
            clearTimeout(this._positionPopupLiveHideTimer);
            this._positionPopupLiveHideTimer = null;
        }
        if (this._positionPopupLiveProgressInterval) {
            clearInterval(this._positionPopupLiveProgressInterval);
            this._positionPopupLiveProgressInterval = null;
        }
        if (this._positionPopupLiveStatus) {
            this._positionPopupLiveStatus.style.display = 'none';
        }
        if (this._positionPopupLiveProgressFill) {
            this._positionPopupLiveProgressFill.style.width = '0%';
            this._positionPopupLiveProgressFill.style.backgroundPosition = '100% 50%';
        }
        this._stopResetLiveIndicator();
    }

    _startLiveProgressTicker() {
        if (this._positionPopupLiveProgressInterval) {
            clearInterval(this._positionPopupLiveProgressInterval);
            this._positionPopupLiveProgressInterval = null;
        }
        if (!this._positionPopupLiveStatus || !this._positionPopupLiveProgressFill) return;
        this._positionPopupLiveStatus.style.display = 'inline-flex';
        this._updateLiveProgress();
        this._positionPopupLiveProgressInterval = window.setInterval(() => {
            if (!this._positionPopupLiveEnabled) return;
            this._updateLiveProgress();
        }, 80);
    }

    _updateLiveProgress() {
        if (!this._positionPopupLiveProgressFill) return;
        const intervalMs = this._positionPopupLiveIntervalMs || this._getLiveResetIntervalMs();
        const now = performance.now();
        if (!Number.isFinite(intervalMs) || intervalMs <= 0 || !Number.isFinite(this._positionPopupLiveNextAt)) {
            this._positionPopupLiveProgressFill.style.width = '0%';
            return;
        }
        const remaining = Math.max(0, this._positionPopupLiveNextAt - now);
        const t = Math.max(0, Math.min(1, remaining / intervalMs));
        const percent = Math.round(t * 100);
        this._positionPopupLiveProgressFill.style.width = `${percent}%`;
        const phase = Math.round(now / 40) % 200;
        this._positionPopupLiveProgressFill.style.backgroundPosition = `${100 - phase}% 50%`;
    }

    _startResetLiveIndicator() {
        if (!this._resetLiveDot) return;
        this._resetLiveDot.style.visibility = 'visible';
        if (this._resetLiveBlinkTimer) {
            clearTimeout(this._resetLiveBlinkTimer);
            this._resetLiveBlinkTimer = null;
        }
        if (this._resetLiveBlinkInterval) {
            clearInterval(this._resetLiveBlinkInterval);
            this._resetLiveBlinkInterval = null;
        }
    }

    _setResetLiveActive(active) {
        if (!this._resetButton) return;
        if (active) {
            this._resetButton.style.border = '1px solid rgba(76,255,122,0.9)';
            this._resetButton.style.boxShadow = '0 0 0 1px rgba(76,255,122,0.25)';
        } else {
            this._resetButton.style.border = this._resetButtonBorder ?? '1px solid rgba(255,255,255,0.16)';
            this._resetButton.style.boxShadow = '';
        }
    }

    _stopResetLiveIndicator() {
        if (this._resetLiveInterval) {
            clearInterval(this._resetLiveInterval);
            this._resetLiveInterval = null;
        }
        if (this._resetLiveShowTimer) {
            clearTimeout(this._resetLiveShowTimer);
            this._resetLiveShowTimer = null;
        }
        if (this._resetLiveHideTimer) {
            clearTimeout(this._resetLiveHideTimer);
            this._resetLiveHideTimer = null;
        }
        if (this._resetLiveBlinkTimer) {
            clearTimeout(this._resetLiveBlinkTimer);
            this._resetLiveBlinkTimer = null;
        }
        if (this._resetLiveBlinkInterval) {
            clearInterval(this._resetLiveBlinkInterval);
            this._resetLiveBlinkInterval = null;
        }
        if (this._resetLiveDot) {
            this._resetLiveDot.style.visibility = 'hidden';
        }
        this._resetLiveNextAt = 0;
    }

    _openComPopup(anchor) {
        this._closeComPopup();
        if (!this._hudRoot || !anchor) return;

        const wrap = document.createElement('div');
        wrap.style.position = 'fixed';
        wrap.style.zIndex = '90';
        wrap.style.padding = '10px';
        wrap.style.borderRadius = '10px';
        wrap.style.background = 'rgba(10, 14, 20, 0.92)';
        wrap.style.border = '1px solid rgba(255,255,255,0.18)';
        wrap.style.color = '#e9f2ff';
        wrap.style.boxShadow = '0 10px 28px rgba(0,0,0,0.35)';
        wrap.style.backdropFilter = 'blur(8px)';
        wrap.style.display = 'flex';
        wrap.style.flexDirection = 'column';
        wrap.style.gap = '8px';
        wrap.style.minWidth = '210px';

        const { header } = makePopupHeader('Center of mass', () => this._closeComPopup());
        wrap.appendChild(header);
        makePopupDraggable(wrap, header);

        const topSeparator = makeSeparator();
        topSeparator.style.margin = '6px 0 4px';
        wrap.appendChild(topSeparator);

        const makeField = (axis, value, key) => {
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.alignItems = 'center';
            row.style.justifyContent = 'space-between';
            row.style.gap = '10px';

            const label = document.createElement('div');
            label.textContent = axis;
            label.style.fontSize = '11px';
            label.style.fontWeight = '700';
            label.style.opacity = '0.85';
            label.style.width = '18px';
            appendHelp(label, INPUT_HELP[key], this._helpSystem);

            const input = document.createElement('input');
            input.type = 'number';
            input.inputMode = 'decimal';
            input.step = '0.01';
            input.value = Number.isFinite(value) ? String(value) : '';
            input.style.width = '80px';
            input.style.padding = '3px 4px';
            input.style.borderRadius = '8px';
            input.style.border = '1px solid rgba(255,255,255,0.16)';
            input.style.background = 'rgba(8, 12, 18, 0.6)';
            input.style.color = '#e9f2ff';
            input.style.fontWeight = '600';
            input.style.fontSize = '11px';
            input.addEventListener('input', () => {
                const next = parseFloat(input.value);
                if (!Number.isFinite(next)) return;
                this._setInputValue(key, next);
            });

            row.appendChild(label);
            row.appendChild(input);
            wrap.appendChild(row);
        };

        const com = this._tuning?.chassis?.additionalMassProperties?.com ?? {};
        makeField('X', com.x, 'massPropsComX');
        makeField('Y', com.y, 'massPropsComY');
        makeField('Z', com.z, 'massPropsComZ');

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const left = Math.min(window.innerWidth - 230, Math.max(pad, rect.right + pad));
        const top = Math.min(window.innerHeight - 200, Math.max(pad, rect.top - 8));
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closeComPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeComPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._comPopup = wrap;
        this._comPopupHandlers = { onPointerDown, onKeyDown };
        this._emitComPreview();
    }

    _closeComPopup() {
        if (this._comPopup?.parentElement) {
            this._comPopup.parentElement.removeChild(this._comPopup);
        }
        if (this._comPopupHandlers) {
            document.removeEventListener('pointerdown', this._comPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._comPopupHandlers.onKeyDown);
        }
        this._comPopup = null;
        this._comPopupHandlers = null;
        this.onComPreview?.(false, null);
    }

    _emitComPreview() {
        if (!this._comPopup) return;
        const com = this._tuning?.chassis?.additionalMassProperties?.com ?? {};
        this.onComPreview?.(true, { x: com.x ?? 0, y: com.y ?? 0, z: com.z ?? 0 });
    }

    _openInertiaPopup(anchor) {
        this._closeInertiaPopup();
        if (!this._hudRoot || !anchor) return;

        const wrap = document.createElement('div');
        wrap.style.position = 'fixed';
        wrap.style.zIndex = '90';
        wrap.style.padding = '10px';
        wrap.style.borderRadius = '10px';
        wrap.style.background = 'rgba(10, 14, 20, 0.92)';
        wrap.style.border = '1px solid rgba(255,255,255,0.18)';
        wrap.style.color = '#e9f2ff';
        wrap.style.boxShadow = '0 10px 28px rgba(0,0,0,0.35)';
        wrap.style.backdropFilter = 'blur(8px)';
        wrap.style.display = 'flex';
        wrap.style.flexDirection = 'column';
        wrap.style.gap = '8px';
        wrap.style.minWidth = '220px';

        const { header } = makePopupHeader('Inertia', () => this._closeInertiaPopup());
        wrap.appendChild(header);
        makePopupDraggable(wrap, header);

        const topSeparator = makeSeparator();
        topSeparator.style.margin = '6px 0 4px';
        wrap.appendChild(topSeparator);

        const makeField = (title, value, key) => {
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.alignItems = 'center';
            row.style.justifyContent = 'space-between';
            row.style.gap = '10px';

            const label = document.createElement('div');
            label.textContent = title;
            label.style.fontSize = '11px';
            label.style.fontWeight = '700';
            label.style.opacity = '0.85';
            appendHelp(label, INPUT_HELP[key], this._helpSystem);

            const input = document.createElement('input');
            input.type = 'number';
            input.inputMode = 'decimal';
            input.step = '0.01';
            input.value = Number.isFinite(value) ? String(value) : '';
            input.style.width = '90px';
            input.style.padding = '3px 4px';
            input.style.borderRadius = '8px';
            input.style.border = '1px solid rgba(255,255,255,0.16)';
            input.style.background = 'rgba(8, 12, 18, 0.6)';
            input.style.color = '#e9f2ff';
            input.style.fontWeight = '600';
            input.style.fontSize = '11px';
            input.addEventListener('input', () => {
                const next = parseFloat(input.value);
                if (!Number.isFinite(next)) return;
                this._setInputValue(key, next);
            });

            row.appendChild(label);
            row.appendChild(input);
            wrap.appendChild(row);
            return input;
        };

        const inertia = this._tuning?.chassis?.additionalMassProperties?.inertia ?? {};
        const initial = {
            x: inertia.x ?? 0,
            y: inertia.y ?? 0,
            z: inertia.z ?? 0
        };
        const inputs = {
            x: makeField('Inertia X', initial.x, 'massPropsInertiaX'),
            y: makeField('Inertia Y', initial.y, 'massPropsInertiaY'),
            z: makeField('Inertia Z', initial.z, 'massPropsInertiaZ')
        };

        const separator = makeSeparator();
        separator.style.margin = '6px 0 4px';
        wrap.appendChild(separator);

        const actions = document.createElement('div');
        actions.style.display = 'flex';
        actions.style.justifyContent = 'flex-end';
        actions.style.gap = '8px';

        const reset = makeButton('Reset');
        reset.style.padding = '6px 10px';
        reset.style.fontSize = '11px';
        reset.style.borderRadius = '8px';
        reset.style.marginRight = '0';
        reset.addEventListener('click', () => {
            inputs.x.value = String(initial.x);
            inputs.y.value = String(initial.y);
            inputs.z.value = String(initial.z);
            this._setInputValue('massPropsInertiaX', initial.x);
            this._setInputValue('massPropsInertiaY', initial.y);
            this._setInputValue('massPropsInertiaZ', initial.z);
        });

        actions.appendChild(reset);
        wrap.appendChild(actions);

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const left = Math.min(window.innerWidth - 260, Math.max(pad, rect.right + pad));
        const top = Math.min(window.innerHeight - 220, Math.max(pad, rect.top - 8));
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closeInertiaPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeInertiaPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._inertiaPopup = wrap;
        this._inertiaPopupHandlers = { onPointerDown, onKeyDown };
    }

    _closeInertiaPopup() {
        if (this._inertiaPopup?.parentElement) {
            this._inertiaPopup.parentElement.removeChild(this._inertiaPopup);
        }
        if (this._inertiaPopupHandlers) {
            document.removeEventListener('pointerdown', this._inertiaPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._inertiaPopupHandlers.onKeyDown);
        }
        this._inertiaPopup = null;
        this._inertiaPopupHandlers = null;
    }

    _openInertiaFramePopup(anchor) {
        this._closeInertiaFramePopup();
        if (!this._hudRoot || !anchor) return;

        const wrap = document.createElement('div');
        wrap.style.position = 'fixed';
        wrap.style.zIndex = '90';
        wrap.style.padding = '10px';
        wrap.style.borderRadius = '10px';
        wrap.style.background = 'rgba(10, 14, 20, 0.92)';
        wrap.style.border = '1px solid rgba(255,255,255,0.18)';
        wrap.style.color = '#e9f2ff';
        wrap.style.boxShadow = '0 10px 28px rgba(0,0,0,0.35)';
        wrap.style.backdropFilter = 'blur(8px)';
        wrap.style.display = 'flex';
        wrap.style.flexDirection = 'column';
        wrap.style.gap = '8px';
        wrap.style.minWidth = '220px';

        const { header } = makePopupHeader('Inertia frame', () => this._closeInertiaFramePopup());
        wrap.appendChild(header);
        makePopupDraggable(wrap, header);

        const topSeparator = makeSeparator();
        topSeparator.style.margin = '6px 0 4px';
        wrap.appendChild(topSeparator);

        const makeField = (title, value, key) => {
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.alignItems = 'center';
            row.style.justifyContent = 'space-between';
            row.style.gap = '10px';

            const label = document.createElement('div');
            label.textContent = title;
            label.style.fontSize = '11px';
            label.style.fontWeight = '700';
            label.style.opacity = '0.85';
            appendHelp(label, INPUT_HELP[key], this._helpSystem);

            const input = document.createElement('input');
            input.type = 'number';
            input.inputMode = 'decimal';
            input.step = '0.01';
            input.value = Number.isFinite(value) ? String(value) : '';
            input.style.width = '90px';
            input.style.padding = '3px 4px';
            input.style.borderRadius = '8px';
            input.style.border = '1px solid rgba(255,255,255,0.16)';
            input.style.background = 'rgba(8, 12, 18, 0.6)';
            input.style.color = '#e9f2ff';
            input.style.fontWeight = '600';
            input.style.fontSize = '11px';
            input.addEventListener('input', () => {
                const next = parseFloat(input.value);
                if (!Number.isFinite(next)) return;
                this._setInputValue(key, next);
            });

            row.appendChild(label);
            row.appendChild(input);
            wrap.appendChild(row);
            return input;
        };

        const frame = this._tuning?.chassis?.additionalMassProperties?.inertiaFrame ?? {};
        const initial = {
            w: frame.w ?? 1,
            x: frame.x ?? 0,
            y: frame.y ?? 0,
            z: frame.z ?? 0
        };
        const inputs = {
            w: makeField('Frame W', initial.w, 'massPropsFrameW'),
            x: makeField('Frame X', initial.x, 'massPropsFrameX'),
            y: makeField('Frame Y', initial.y, 'massPropsFrameY'),
            z: makeField('Frame Z', initial.z, 'massPropsFrameZ')
        };

        const separator = makeSeparator();
        separator.style.margin = '6px 0 4px';
        wrap.appendChild(separator);

        const actions = document.createElement('div');
        actions.style.display = 'flex';
        actions.style.justifyContent = 'flex-end';
        actions.style.gap = '8px';

        const reset = makeButton('Reset');
        reset.style.padding = '6px 10px';
        reset.style.fontSize = '11px';
        reset.style.borderRadius = '8px';
        reset.style.marginRight = '0';
        reset.addEventListener('click', () => {
            inputs.w.value = String(initial.w);
            inputs.x.value = String(initial.x);
            inputs.y.value = String(initial.y);
            inputs.z.value = String(initial.z);
            this._setInputValue('massPropsFrameW', initial.w);
            this._setInputValue('massPropsFrameX', initial.x);
            this._setInputValue('massPropsFrameY', initial.y);
            this._setInputValue('massPropsFrameZ', initial.z);
        });

        actions.appendChild(reset);
        wrap.appendChild(actions);

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const left = Math.min(window.innerWidth - 260, Math.max(pad, rect.right + pad));
        const top = Math.min(window.innerHeight - 240, Math.max(pad, rect.top - 8));
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closeInertiaFramePopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeInertiaFramePopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._inertiaFramePopup = wrap;
        this._inertiaFramePopupHandlers = { onPointerDown, onKeyDown };
    }

    _closeInertiaFramePopup() {
        if (this._inertiaFramePopup?.parentElement) {
            this._inertiaFramePopup.parentElement.removeChild(this._inertiaFramePopup);
        }
        if (this._inertiaFramePopupHandlers) {
            document.removeEventListener('pointerdown', this._inertiaFramePopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._inertiaFramePopupHandlers.onKeyDown);
        }
        this._inertiaFramePopup = null;
        this._inertiaFramePopupHandlers = null;
    }

    _openLockingPopup(anchor) {
        this._closeLockingPopup();
        if (!this._hudRoot || !anchor) return;

        const wrap = document.createElement('div');
        wrap.style.position = 'fixed';
        wrap.style.zIndex = '90';
        wrap.style.padding = '10px';
        wrap.style.borderRadius = '10px';
        wrap.style.background = 'rgba(10, 14, 20, 0.92)';
        wrap.style.border = '1px solid rgba(255,255,255,0.18)';
        wrap.style.color = '#e9f2ff';
        wrap.style.boxShadow = '0 10px 28px rgba(0,0,0,0.35)';
        wrap.style.backdropFilter = 'blur(8px)';
        wrap.style.display = 'flex';
        wrap.style.flexDirection = 'column';
        wrap.style.gap = '8px';
        wrap.style.minWidth = '220px';

        const { header } = makePopupHeader('Locking', () => this._closeLockingPopup());
        wrap.appendChild(header);
        makePopupDraggable(wrap, header);

        const topSeparator = makeSeparator();
        topSeparator.style.margin = '6px 0 4px';
        wrap.appendChild(topSeparator);

        const attach = (control) => {
            if (!control?.wrap) return;
            if (control.wrap.parentElement) {
                control.wrap.parentElement.removeChild(control.wrap);
            }
            control.wrap.style.margin = '6px 0';
            wrap.appendChild(control.wrap);
        };

        const initial = {
            lockTranslations: !!this._tuning?.chassis?.lockTranslations,
            lockRotations: !!this._tuning?.chassis?.lockRotations,
            enabledRotX: !!this._tuning?.chassis?.enabledRotations?.x,
            enabledRotY: !!this._tuning?.chassis?.enabledRotations?.y,
            enabledRotZ: !!this._tuning?.chassis?.enabledRotations?.z
        };

        attach(this._inputControls.lockTranslations);
        attach(this._inputControls.lockRotations);
        attach(this._inputControls.enabledRotX);
        attach(this._inputControls.enabledRotY);
        attach(this._inputControls.enabledRotZ);

        const separator = makeSeparator();
        separator.style.margin = '6px 0 4px';
        wrap.appendChild(separator);

        const actions = document.createElement('div');
        actions.style.display = 'flex';
        actions.style.justifyContent = 'flex-end';
        actions.style.gap = '8px';

        const reset = makeButton('Reset');
        reset.style.padding = '6px 10px';
        reset.style.fontSize = '11px';
        reset.style.borderRadius = '8px';
        reset.style.marginRight = '0';
        reset.addEventListener('click', () => {
            this._setInputValue('lockTranslations', initial.lockTranslations);
            this._setInputValue('lockRotations', initial.lockRotations);
            this._setInputValue('enabledRotX', initial.enabledRotX);
            this._setInputValue('enabledRotY', initial.enabledRotY);
            this._setInputValue('enabledRotZ', initial.enabledRotZ);
        });

        actions.appendChild(reset);
        wrap.appendChild(actions);

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const left = Math.min(window.innerWidth - 260, Math.max(pad, rect.right + pad));
        const top = Math.min(window.innerHeight - 240, Math.max(pad, rect.top - 8));
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closeLockingPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeLockingPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._lockingPopup = wrap;
        this._lockingPopupHandlers = { onPointerDown, onKeyDown };
    }

    _closeLockingPopup() {
        if (this._lockingPopup?.parentElement) {
            this._lockingPopup.parentElement.removeChild(this._lockingPopup);
        }
        if (this._lockingPopupHandlers) {
            document.removeEventListener('pointerdown', this._lockingPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._lockingPopupHandlers.onKeyDown);
        }
        this._lockingPopup = null;
        this._lockingPopupHandlers = null;
    }

    _openForcesPopup(anchor) {
        if (this._forcesPopup) {
            this._closeForcesPopup();
            return;
        }
        if (!this._hudRoot || !anchor) return;

        const helpSystem = this._helpSystem;

        const wrap = document.createElement('div');
        wrap.style.position = 'fixed';
        wrap.style.zIndex = '90';
        wrap.style.padding = '12px';
        wrap.style.borderRadius = '12px';
        wrap.style.background = 'rgba(10, 14, 20, 0.92)';
        wrap.style.border = '1px solid rgba(255,255,255,0.18)';
        wrap.style.color = '#e9f2ff';
        wrap.style.boxShadow = '0 10px 28px rgba(0,0,0,0.35)';
        wrap.style.backdropFilter = 'blur(8px)';
        wrap.style.display = 'flex';
        wrap.style.flexDirection = 'column';
        wrap.style.gap = '10px';
        wrap.style.minWidth = '340px';

        const { header } = makePopupHeader('Forces and impulses', () => this._closeForcesPopup());
        wrap.appendChild(header);
        makePopupDraggable(wrap, header);

        const topSeparator = makeSeparator();
        topSeparator.style.margin = '6px 0 4px';
        wrap.appendChild(topSeparator);

        const contentRow = document.createElement('div');
        contentRow.style.display = 'flex';
        contentRow.style.alignItems = 'flex-start';
        contentRow.style.gap = '14px';

        const controlsWrap = document.createElement('div');
        controlsWrap.style.display = 'flex';
        controlsWrap.style.flexDirection = 'column';
        controlsWrap.style.gap = '8px';
        controlsWrap.style.flex = '0 0 auto';
        controlsWrap.style.width = '360px';

        const applyModeRow = document.createElement('div');
        applyModeRow.style.display = 'flex';
        applyModeRow.style.alignItems = 'center';
        applyModeRow.style.justifyContent = 'space-between';
        applyModeRow.style.gap = '12px';

        const applyModeLabel = document.createElement('div');
        applyModeLabel.textContent = 'Apply at point';
        applyModeLabel.style.fontSize = '12px';
        applyModeLabel.style.fontWeight = '700';
        applyModeLabel.style.opacity = '0.85';

        const applyModeWrap = document.createElement('label');
        applyModeWrap.style.display = 'inline-flex';
        applyModeWrap.style.alignItems = 'center';
        applyModeWrap.style.gap = '6px';
        applyModeWrap.style.cursor = 'pointer';

        const applyModeToggle = document.createElement('input');
        applyModeToggle.type = 'checkbox';
        applyModeToggle.style.position = 'absolute';
        applyModeToggle.style.opacity = '0';
        applyModeToggle.style.width = '0';
        applyModeToggle.style.height = '0';

        const applyModeTrack = document.createElement('span');
        applyModeTrack.style.width = '34px';
        applyModeTrack.style.height = '18px';
        applyModeTrack.style.borderRadius = '999px';
        applyModeTrack.style.background = 'rgba(255,255,255,0.2)';
        applyModeTrack.style.boxShadow = 'inset 0 0 0 1px rgba(255,255,255,0.2)';
        applyModeTrack.style.position = 'relative';
        applyModeTrack.style.transition = 'background 150ms ease';

        const applyModeKnob = document.createElement('span');
        applyModeKnob.style.position = 'absolute';
        applyModeKnob.style.top = '2px';
        applyModeKnob.style.left = '2px';
        applyModeKnob.style.width = '14px';
        applyModeKnob.style.height = '14px';
        applyModeKnob.style.borderRadius = '999px';
        applyModeKnob.style.background = '#e9f2ff';
        applyModeKnob.style.boxShadow = '0 0 6px rgba(0,0,0,0.25)';
        applyModeKnob.style.transition = 'transform 150ms ease';

        applyModeTrack.appendChild(applyModeKnob);

        applyModeWrap.appendChild(applyModeToggle);
        applyModeWrap.appendChild(applyModeTrack);

        applyModeRow.appendChild(applyModeLabel);
        applyModeRow.appendChild(applyModeWrap);
        controlsWrap.appendChild(applyModeRow);

        const modeSeparator = makeSeparator();
        modeSeparator.style.margin = '6px 0 2px';
        controlsWrap.appendChild(modeSeparator);

        const grid = document.createElement('div');
        grid.style.display = 'grid';
        grid.style.gridTemplateColumns = 'minmax(190px, 1fr)';
        grid.style.gap = '14px';

        const tabs = document.createElement('div');
        tabs.style.display = 'grid';
        tabs.style.gridTemplateColumns = 'repeat(3, minmax(0, 1fr))';
        tabs.style.alignItems = 'center';
        tabs.style.gap = '8px';
        tabs.style.marginBottom = '4px';
        tabs.style.width = '100%';

        const makeTabButton = (label, key) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.textContent = label;
            btn.style.padding = '6px 10px';
            btn.style.borderRadius = '999px';
            btn.style.border = '1px solid rgba(255,255,255,0.18)';
            btn.style.background = 'rgba(8, 12, 18, 0.7)';
            btn.style.color = '#e9f2ff';
            btn.style.fontSize = '11px';
            btn.style.fontWeight = '700';
            btn.style.cursor = 'pointer';
            btn.style.width = '100%';
            btn.style.textAlign = 'center';
            btn.addEventListener('click', () => setActiveTab(key));
            return btn;
        };

        const tabButtons = {
            force: makeTabButton('Forces', 'force'),
            torque: makeTabButton('Torques', 'torque'),
            impulse: makeTabButton('Impulses', 'impulse')
        };

        tabs.appendChild(tabButtons.force);
        tabs.appendChild(tabButtons.torque);
        tabs.appendChild(tabButtons.impulse);
        controlsWrap.appendChild(tabs);

        const attachWraps = (wraps, container) => {
            for (const item of wraps) {
                if (!item) continue;
                if (item.parentElement) item.parentElement.removeChild(item);
                container.appendChild(item);
            }
        };

        const attachButtons = (buttons, container) => {
            for (const btn of buttons) {
                if (!btn) continue;
                if (btn.parentElement) btn.parentElement.removeChild(btn);
                btn.style.marginRight = '0';
                container.appendChild(btn);
            }
        };

        const makeColumn = (title, help, wraps, buttons) => {
            const col = document.createElement('div');
            col.style.display = 'flex';
            col.style.flexDirection = 'column';
            col.style.gap = '6px';

            const label = makeLabel(title);
            label.style.display = 'flex';
            label.style.alignItems = 'center';
            label.style.marginBottom = '4px';
            appendHelp(label, help, helpSystem);
            col.appendChild(label);

            attachWraps(wraps, col);

            const divider = makeSeparator();
            divider.style.margin = '6px 0 4px';
            col.appendChild(divider);

            const buttonRow = document.createElement('div');
            buttonRow.style.display = 'flex';
            buttonRow.style.flexWrap = 'wrap';
            buttonRow.style.gap = '8px';
            buttonRow.style.marginTop = '6px';
            attachButtons(buttons, buttonRow);
            col.appendChild(buttonRow);

            return col;
        };

        const controls = this._forcePopupControls ?? {};
        const buttons = this._forcePopupButtons ?? {};

        const forceCol = makeColumn(
            'Force',
            INPUT_HELP.forcesPanelForce,
            [
                controls.forceX,
                controls.forceY,
                controls.forceZ,
                controls.forcePointX,
                controls.forcePointY,
                controls.forcePointZ
            ],
            [
                buttons.applyForce,
                buttons.applyForceAtPoint,
                buttons.resetForces
            ]
        );

        const torqueCol = makeColumn(
            'Torque',
            INPUT_HELP.forcesPanelTorque,
            [
                controls.torqueX,
                controls.torqueY,
                controls.torqueZ,
                controls.torqueImpulseX,
                controls.torqueImpulseY,
                controls.torqueImpulseZ
            ],
            [
                buttons.applyTorque,
                buttons.applyTorqueImpulse,
                buttons.resetTorques
            ]
        );

        const impulseCol = makeColumn(
            'Impulse',
            INPUT_HELP.forcesPanelImpulse,
            [
                controls.impulseX,
                controls.impulseY,
                controls.impulseZ,
                controls.impulsePointX,
                controls.impulsePointY,
                controls.impulsePointZ
            ],
            [
                buttons.applyImpulse,
                buttons.applyImpulseAtPoint
            ]
        );

        grid.appendChild(forceCol);
        grid.appendChild(torqueCol);
        grid.appendChild(impulseCol);
        controlsWrap.appendChild(grid);

        const bottomSeparator = makeSeparator();
        bottomSeparator.style.margin = '10px 0 2px';
        controlsWrap.appendChild(bottomSeparator);

        const velocityRow = document.createElement('div');
        velocityRow.style.display = 'flex';
        velocityRow.style.justifyContent = 'flex-end';
        velocityRow.style.alignItems = 'center';
        velocityRow.style.gap = '8px';
        velocityRow.style.width = '100%';

        const resetAllButton = makeButton('Reset all');
        resetAllButton.style.marginRight = '0';
        resetAllButton.style.flex = '0 0 auto';
        resetAllButton.style.whiteSpace = 'nowrap';
        resetAllButton.addEventListener('click', () => {
            this.onResetForces?.();
            this.onResetTorques?.();
            this.onResetVelocities?.();
            this._setForceLogEntry('const-force', null);
            this._setForceLogEntry('const-torque', null);
            this._clearForceEventLog({ category: 'force', keepConstants: true });
            this._clearForceEventLog({ category: 'torque', keepConstants: true });
            this._setInputValue('linvelX', 0);
            this._setInputValue('linvelY', 0);
            this._setInputValue('linvelZ', 0);
            this._setInputValue('angvelX', 0);
            this._setInputValue('angvelY', 0);
            this._setInputValue('angvelZ', 0);
        });

        resetAllButton.style.marginLeft = 'auto';
        velocityRow.appendChild(resetAllButton);

        const resetVel = buttons.resetVelocities;
        if (resetVel) {
            if (resetVel.parentElement) resetVel.parentElement.removeChild(resetVel);
            resetVel.style.marginRight = '0';
            resetVel.style.flex = '0 0 auto';
            velocityRow.appendChild(resetVel);
        }
        controlsWrap.appendChild(velocityRow);

        const logCol = document.createElement('div');
        logCol.style.display = 'flex';
        logCol.style.flexDirection = 'column';
        logCol.style.gap = '6px';
        logCol.style.display = 'none';
        logCol.style.flex = '0 0 240px';
        logCol.style.minWidth = '240px';
        logCol.style.maxWidth = '280px';

        const logLabel = makeLabel('Applied');
        logLabel.style.marginBottom = '4px';
        logCol.appendChild(logLabel);

        const logList = document.createElement('div');
        logList.style.display = 'flex';
        logList.style.flexDirection = 'column';
        logList.style.gap = '6px';
        logCol.appendChild(logList);

        contentRow.appendChild(controlsWrap);
        contentRow.appendChild(logCol);
        wrap.appendChild(contentRow);

        const setActiveTab = (key) => {
            this._forcesActiveTab = key;
            forceCol.style.display = key === 'force' ? 'flex' : 'none';
            impulseCol.style.display = key === 'impulse' ? 'flex' : 'none';
            torqueCol.style.display = key === 'torque' ? 'flex' : 'none';
            for (const [tabKey, btn] of Object.entries(tabButtons)) {
                if (!btn) continue;
                const active = tabKey === key;
                btn.style.background = active ? 'rgba(76,255,122,0.18)' : 'rgba(8, 12, 18, 0.7)';
                btn.style.borderColor = active ? 'rgba(76,255,122,0.55)' : 'rgba(255,255,255,0.18)';
                btn.style.color = active ? '#d7ffe4' : '#e9f2ff';
            }
            this._refreshForcesPopupLog();
        };

        const updateApplyMode = (enabled) => {
            this._forceApplyAtPoint = !!enabled;
            if (this._forceApplyAtPoint) {
                applyModeTrack.style.background = 'rgba(76,255,122,0.45)';
                applyModeKnob.style.transform = 'translateX(16px)';
            } else {
                applyModeTrack.style.background = 'rgba(255,255,255,0.2)';
                applyModeKnob.style.transform = 'translateX(0)';
            }
            const pointControls = [
                controls.forcePointX,
                controls.forcePointY,
                controls.forcePointZ,
                controls.impulsePointX,
                controls.impulsePointY,
                controls.impulsePointZ
            ];
            for (const ctrl of pointControls) {
                if (!ctrl) continue;
                const input = ctrl.querySelector?.('input');
                if (input) input.disabled = !this._forceApplyAtPoint;
                ctrl.style.opacity = this._forceApplyAtPoint ? '1' : '0.4';
                ctrl.style.filter = this._forceApplyAtPoint ? 'none' : 'grayscale(0.4)';
            }
            if (buttons.applyForce) {
                buttons.applyForce.style.display = this._forceApplyAtPoint ? 'none' : '';
            }
            if (buttons.applyForceAtPoint) {
                buttons.applyForceAtPoint.style.display = this._forceApplyAtPoint ? '' : 'none';
            }
            if (buttons.applyImpulse) {
                buttons.applyImpulse.style.display = this._forceApplyAtPoint ? 'none' : '';
            }
            if (buttons.applyImpulseAtPoint) {
                buttons.applyImpulseAtPoint.style.display = this._forceApplyAtPoint ? '' : 'none';
            }
            if (this._forcesActiveTab === 'force') {
                forceCol.style.display = 'flex';
            } else if (this._forcesActiveTab === 'impulse') {
                impulseCol.style.display = 'flex';
            }
        };

        applyModeToggle.checked = this._forceApplyAtPoint;
        updateApplyMode(this._forceApplyAtPoint);
        applyModeToggle.addEventListener('change', () => {
            updateApplyMode(applyModeToggle.checked);
        });

        setActiveTab(this._forcesActiveTab ?? 'force');

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const left = Math.min(window.innerWidth - 640, Math.max(pad, rect.right + pad));
        const top = Math.max(pad, rect.top - 320);
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closeForcesPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeForcesPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._forcesPopup = wrap;
        this._forcesPopupHandlers = { onPointerDown, onKeyDown };
        this._forcesPopupGrid = grid;
        this._forcesPopupLogCol = logCol;
        this._forcesPopupLogEl = logList;
        this._refreshForcesPopupLog();
    }

    _closeForcesPopup() {
        if (this._forcesPopup?.parentElement) {
            this._forcesPopup.parentElement.removeChild(this._forcesPopup);
        }
        if (this._forcesPopupHandlers) {
            document.removeEventListener('pointerdown', this._forcesPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._forcesPopupHandlers.onKeyDown);
        }
        this._forcesPopup = null;
        this._forcesPopupHandlers = null;
        this._forcesPopupGrid = null;
        this._forcesPopupLogCol = null;
        this._forcesPopupLogEl = null;
    }

    _openTestsPopup(anchor) {
        if (this._testsPopup) {
            this._closeTestsPopup();
            return;
        }
        if (!this._hudRoot || !anchor) return;

        const wrap = document.createElement('div');
        wrap.style.position = 'fixed';
        wrap.style.zIndex = '90';
        wrap.style.padding = '12px';
        wrap.style.borderRadius = '12px';
        wrap.style.background = 'rgba(10, 14, 20, 0.92)';
        wrap.style.border = '1px solid rgba(255,255,255,0.18)';
        wrap.style.color = '#e9f2ff';
        wrap.style.boxShadow = '0 10px 28px rgba(0,0,0,0.35)';
        wrap.style.backdropFilter = 'blur(8px)';
        wrap.style.display = 'flex';
        wrap.style.flexDirection = 'column';
        wrap.style.gap = '8px';
        wrap.style.minWidth = '220px';

        const { header } = makePopupHeader('Automated tests', () => this._closeTestsPopup());
        wrap.appendChild(header);
        makePopupDraggable(wrap, header);

        const topSeparator = makeSeparator();
        topSeparator.style.margin = '6px 0 4px';
        wrap.appendChild(topSeparator);

        for (const test of PRESET_TESTS) {
            const btn = makeButton(test.label);
            btn.style.padding = '6px 10px';
            btn.style.fontSize = '13px';
            btn.style.borderRadius = '8px';
            btn.style.marginRight = '0';
            btn.style.width = '200px';
            btn.addEventListener('click', () => {
                this._startTest(test);
                this._closeTestsPopup();
            });
            wrap.appendChild(btn);
        }

        const rect = anchor.getBoundingClientRect();
        const pad = 8;
        const left = Math.min(window.innerWidth - 260, Math.max(pad, rect.right + pad));
        const top = Math.min(window.innerHeight - 220, Math.max(pad, rect.top - 8));
        wrap.style.left = `${left}px`;
        wrap.style.top = `${top}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target) || anchor.contains(event.target)) return;
            this._closeTestsPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeTestsPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._testsPopup = wrap;
        this._testsPopupHandlers = { onPointerDown, onKeyDown };
    }

    _closeTestsPopup() {
        if (this._testsPopup?.parentElement) {
            this._testsPopup.parentElement.removeChild(this._testsPopup);
        }
        if (this._testsPopupHandlers) {
            document.removeEventListener('pointerdown', this._testsPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._testsPopupHandlers.onKeyDown);
        }
        this._testsPopup = null;
        this._testsPopupHandlers = null;
    }

    _openTestPopup(test) {
        this._closeTestPopup();
        if (!this._outputPanel) return;

        const wrap = document.createElement('div');
        stylePanel(wrap, { interactive: true });
        wrap.style.position = 'fixed';
        wrap.style.zIndex = '70';
        wrap.style.minWidth = '220px';
        wrap.style.maxWidth = '260px';
        wrap.style.padding = '12px';
        wrap.style.minHeight = '120px';
        wrap.style.display = 'flex';
        wrap.style.flexDirection = 'column';
        wrap.style.gap = '14px';

        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.alignItems = 'center';
        header.style.justifyContent = 'space-between';
        header.style.gap = '10px';

        const title = document.createElement('div');
        title.textContent = test?.label ?? 'Automated Test';
        title.style.fontSize = '13px';
        title.style.fontWeight = '800';
        title.style.letterSpacing = '0.2px';
        title.style.flex = '1';

        const closeBtn = makePopupCloseButton(() => this._closeTestPopup());

        header.appendChild(title);
        header.appendChild(closeBtn);
        wrap.appendChild(header);
        makePopupDraggable(wrap, header);

        const topSeparator = makeSeparator();
        topSeparator.style.margin = '-2px 0 0';
        wrap.appendChild(topSeparator);

        const button = makeButton('Recording');
        button.style.padding = '6px 10px';
        button.style.fontSize = '13px';
        button.style.borderRadius = '8px';
        button.style.marginRight = '0';
        button.style.width = '100%';
        button.textContent = '';
        button.disabled = true;
        button.style.position = 'relative';

        const label = document.createElement('span');
        label.textContent = 'Recording';
        label.style.display = 'block';
        label.style.width = '100%';
        label.style.textAlign = 'center';
        button.appendChild(label);

        const dot = document.createElement('span');
        dot.style.position = 'absolute';
        dot.style.right = '12px';
        dot.style.top = '50%';
        dot.style.transform = 'translateY(-50%)';
        dot.style.width = '9px';
        dot.style.height = '9px';
        dot.style.borderRadius = '999px';
        dot.style.background = 'rgba(255,45,45,0.95)';
        dot.style.boxShadow = '0 0 10px rgba(255,45,45,0.6), 0 0 0 1px rgba(255,45,45,0.9)';
        dot.style.visibility = 'visible';
        button.appendChild(dot);

        wrap.appendChild(button);

        const rect = this._outputPanel.getBoundingClientRect();
        const pad = 10;
        const left = Math.max(pad, rect.left - 260 - pad);
        wrap.style.left = `${left}px`;
        wrap.style.bottom = `${pad}px`;

        const onPointerDown = (event) => {
            if (wrap.contains(event.target)) return;
            this._closeTestPopup();
        };
        const onKeyDown = (event) => {
            if (event.key === 'Escape') this._closeTestPopup();
        };

        document.body.appendChild(wrap);
        document.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', onKeyDown);
        this._testPopup = wrap;
        this._testPopupHandlers = { onPointerDown, onKeyDown };
        this._testPopupTitle = title;
        this._testPopupButton = button;
        this._testPopupLabel = label;
        this._testPopupDot = dot;
        this._setTestPopupState('recording');
    }

    _setTestPopupState(state) {
        if (!this._testPopupButton || !this._testPopupLabel || !this._testPopupDot) return;
        if (this._testPopupCloseTimer) {
            clearTimeout(this._testPopupCloseTimer);
            this._testPopupCloseTimer = null;
        }
        if (this._testPopupEllipsisTimer) {
            clearInterval(this._testPopupEllipsisTimer);
            this._testPopupEllipsisTimer = null;
        }
        if (state === 'recording') {
            const dots = ['.', '..', '...'];
            let idx = 0;
            this._testPopupLabel.textContent = `Recording${dots[idx]}`;
            this._testPopupDot.style.visibility = 'visible';
            this._testPopupButton.disabled = true;
            this._testPopupButton.onclick = null;
            this._testPopupEllipsisTimer = window.setInterval(() => {
                idx = (idx + 1) % dots.length;
                if (this._testPopupLabel) {
                    this._testPopupLabel.textContent = `Recording${dots[idx]}`;
                }
            }, 400);
        } else if (state === 'done') {
            this._testPopupLabel.textContent = 'Copy telemetry';
            this._testPopupDot.style.visibility = 'hidden';
            this._testPopupButton.disabled = false;
            this._testPopupButton.onclick = () => {
                this._copyTelemetry().then(() => {
                    this._showAxisToast('Telemetry copied to clipboard');
                    this._closeTestPopup();
                });
            };
            this._testPopupCloseTimer = window.setTimeout(() => {
                this._closeTestPopup();
            }, 5000);
        }
    }

    _closeTestPopup() {
        if (this._testPopup?.parentElement) {
            this._testPopup.parentElement.removeChild(this._testPopup);
        }
        if (this._testPopupHandlers) {
            document.removeEventListener('pointerdown', this._testPopupHandlers.onPointerDown);
            window.removeEventListener('keydown', this._testPopupHandlers.onKeyDown);
        }
        if (this._testPopupCloseTimer) {
            clearTimeout(this._testPopupCloseTimer);
        }
        if (this._testPopupEllipsisTimer) {
            clearInterval(this._testPopupEllipsisTimer);
        }
        this._testPopup = null;
        this._testPopupHandlers = null;
        this._testPopupTitle = null;
        this._testPopupButton = null;
        this._testPopupLabel = null;
        this._testPopupDot = null;
        this._testPopupCloseTimer = null;
        this._testPopupEllipsisTimer = null;
        this._testPopupEllipsisTimer = null;
    }

    _recordForceEvent(label, vec, point = null) {
        const now = Date.now();
        const fmt = (v) => `${formatNum(v?.x, 2)}, ${formatNum(v?.y, 2)}, ${formatNum(v?.z, 2)}`;
        let text = `${label}: ${fmt(vec)}`;
        if (point) text += ` @ ${fmt(point)}`;
        const lower = String(label ?? '').toLowerCase();
        const category = lower.includes('torque') ? 'torque'
            : lower.includes('force') ? 'force'
                : lower.includes('impulse') ? 'impulse'
                    : 'other';
        const persistent = (lower === 'force' || lower === 'torque');
        const expiresAt = persistent ? null : (now + 4000);
        const key = `event-${category}-${now}-${this._forceActionSeq++}`;
        this._setForceLogEntry(key, text, expiresAt);
    }

    _clearForceEventLog({ category = null, keepConstants = true } = {}) {
        if (!this._forceActionLog?.length) return;
        const prefix = category ? `event-${category}-` : 'event-';
        this._forceActionLog = this._forceActionLog.filter((entry) => {
            const key = entry?.key ?? '';
            if (keepConstants && String(key).startsWith('const-')) return true;
            return !String(key).startsWith(prefix);
        });
        this._refreshForcesPopupLog();
    }

    _setForceLogEntry(key, text, expiresAt = null) {
        if (!this._forceActionLog) this._forceActionLog = [];
        const idx = this._forceActionLog.findIndex((entry) => entry.key === key);
        const isConstant = key.startsWith('const-');
        if (!text) {
            if (idx >= 0) this._forceActionLog.splice(idx, 1);
        } else if (idx >= 0) {
            const entry = { key, text, expiresAt };
            if (isConstant && idx > 0) {
                this._forceActionLog.splice(idx, 1);
                this._forceActionLog.unshift(entry);
            } else {
                this._forceActionLog[idx] = entry;
            }
        } else {
            this._forceActionLog.unshift({ key, text, expiresAt });
        }
        this._pruneForceEvents();
        if (this._forceActionLog.length > this._forceActionMax) {
            this._forceActionLog.length = this._forceActionMax;
        }
        this._refreshForcesPopupLog();
    }

    _pruneForceEvents(now = Date.now()) {
        if (!this._forceActionLog?.length) return;
        const next = this._forceActionLog.filter((entry) => !entry.expiresAt || entry.expiresAt > now);
        if (next.length !== this._forceActionLog.length) {
            this._forceActionLog = next;
        }
    }

    _updateForceLogFromSnapshot(snapshot) {
        const force = snapshot?.body?.force;
        const torque = snapshot?.body?.torque;
        if (vecNonZero(force)) {
            this._setForceLogEntry('const-force', `Force: ${formatVec3(force, 2)}`, null);
        } else {
            this._setForceLogEntry('const-force', null);
        }
        if (vecNonZero(torque)) {
            this._setForceLogEntry('const-torque', `Torque: ${formatVec3(torque, 2)}`, null);
        } else {
            this._setForceLogEntry('const-torque', null);
        }
    }

    _refreshForcesPopupLog() {
        if (!this._forcesPopupLogEl || !this._forcesPopupGrid || !this._forcesPopupLogCol) return;
        const log = this._forceActionLog ?? [];
        const show = log.length > 0;
        this._forcesPopupLogCol.style.display = show ? 'flex' : 'none';
        this._forcesPopupLogEl.textContent = '';
        if (!show) return;
        for (const entry of log) {
            const row = document.createElement('div');
            row.textContent = entry.text;
            row.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, monospace';
            row.style.fontSize = '11px';
            row.style.opacity = '0.9';
            this._forcesPopupLogEl.appendChild(row);
        }
    }

    getInputs() {
        return { ...this._inputs };
    }

    getVehicleConfig() {
        return { ...this._vehicleConfig };
    }

    getTuning() {
        return {
            chassis: {
                ...this._tuning.chassis,
                translation: { ...(this._tuning.chassis.translation ?? {}) },
                rotation: { ...(this._tuning.chassis.rotation ?? {}) },
                linvel: { ...(this._tuning.chassis.linvel ?? {}) },
                angvel: { ...(this._tuning.chassis.angvel ?? {}) },
                enabledRotations: { ...(this._tuning.chassis.enabledRotations ?? {}) },
                additionalMassProperties: {
                    mass: this._tuning.chassis.additionalMassProperties?.mass ?? NaN,
                    com: { ...(this._tuning.chassis.additionalMassProperties?.com ?? {}) },
                    inertia: { ...(this._tuning.chassis.additionalMassProperties?.inertia ?? {}) },
                    inertiaFrame: { ...(this._tuning.chassis.additionalMassProperties?.inertiaFrame ?? {}) }
                }
            },
            suspension: { ...this._tuning.suspension },
            tires: { ...this._tuning.tires }
        };
    }

    getWorldConfig() {
        return {
            gravity: {
                x: this._worldConfig.gravity?.x ?? 0,
                y: this._worldConfig.gravity?.y ?? -9.81,
                z: this._worldConfig.gravity?.z ?? 0
            }
        };
    }

    getForcePreview() {
        if (!this._forcesPopup) return null;
        const com = this._tuning?.chassis?.additionalMassProperties?.com ?? {};
        const tab = this._forcesActiveTab ?? 'force';
        const colorByTab = {
            force: 0x7a4cff,
            torque: 0xff8a3d,
            impulse: 0x32d0ff
        };
        let vec = this._forces.force ?? { x: 0, y: 0, z: 0 };
        let point = this._forces.forcePoint ?? { x: 0, y: 0, z: 0 };
        let atPoint = !!this._forceApplyAtPoint;
        if (tab === 'impulse') {
            vec = this._forces.impulse ?? { x: 0, y: 0, z: 0 };
            point = this._forces.impulsePoint ?? { x: 0, y: 0, z: 0 };
        } else if (tab === 'torque') {
            vec = this._forces.torque ?? { x: 0, y: 0, z: 0 };
            atPoint = false;
        }
        return {
            tab,
            color: colorByTab[tab] ?? colorByTab.force,
            atPoint,
            force: {
                x: vec?.x ?? 0,
                y: vec?.y ?? 0,
                z: vec?.z ?? 0
            },
            point: {
                x: point?.x ?? 0,
                y: point?.y ?? 0,
                z: point?.z ?? 0
            },
            com: {
                x: com.x ?? 0,
                y: com.y ?? 0,
                z: com.z ?? 0
            }
        };
    }

    update(dt, snapshot) {
        const clampedDt = Math.min(Math.max(dt ?? 0, 0), 0.05);
        if (this._activeTest) {
            this._advanceTest(clampedDt);
            if (snapshot) this._recordTelemetry(snapshot);
        }
        if (this._sampleRecording) {
            if (clampedDt > 0) this._sampleElapsed += clampedDt;
            if (snapshot) {
                this._recordSampleFrame(snapshot);
                if (this._sampleElapsed >= 0.5) this._finishSampleRecord();
            }
        }
    }

    setOutputs(snapshot) {
        if (!snapshot || !this._outputRows.status) return;

        this._outputRows.status.valueEl.textContent = snapshot.status ?? 'â€”';

        const body = snapshot.body;
        const pos = body?.position;
        const rot = body?.rotation;
        const linvel = body?.linvel;
        const angvel = body?.angvel;

        const speedMps = snapshot.speedMps ?? 0;
        const speedMax = 40;
        this._outputRows.speed.valueEl.textContent = `${outNum(speedMps, 2, 8)} m/s`;
        if (this._outputRows.speed.barEl) {
            const t = Math.min(1, Math.max(0, speedMps / speedMax));
            this._outputRows.speed.barEl.style.width = `${Math.round(t * 100)}%`;
        }
        this._outputRows.speedKph.valueEl.textContent = `${outNum(speedMps * 3.6, 1, 8)} km/h`;
        if (this._outputRows.speedProj) {
            const sp = snapshot.speedProjMps ?? 0;
            this._outputRows.speedProj.valueEl.textContent = `${outNum(sp, 2, 8)} m/s (${outNum(sp * 3.6, 1, 8)} km/h)`;
            if (this._outputRows.speedProj.barEl) {
                const t = Math.min(1, Math.max(0, sp / speedMax));
                this._outputRows.speedProj.barEl.style.width = `${Math.round(t * 100)}%`;
            }
        }
        const yawDeg = (snapshot.yawRad ?? 0) * (180 / Math.PI);
        this._outputRows.yaw.valueEl.textContent = `${outNum(yawDeg, 1, 8)} deg`;
        if (this._outputRows.yaw.arrowEl) {
            this._outputRows.yaw.arrowEl.style.transform = `rotate(${yawDeg}deg)`;
        }
        if (this._outputRows.axes) {
            const axes = snapshot.controllerAxes ?? {};
            const up = Number.isFinite(axes.up) ? axes.up : 'n/a';
            const fwd = Number.isFinite(axes.forward) ? axes.forward : 'n/a';
            this._outputRows.axes.valueEl.textContent = `up:${padLeft(String(up), 2)}  fwd:${padLeft(String(fwd), 2)}`;
        }
        if (this._outputRows.mass) {
            this._outputRows.mass.valueEl.textContent = Number.isFinite(snapshot.massKg) ? `${outNum(snapshot.massKg, 0, 8)} kg` : `${outNum(NaN, 0, 8)} kg`;
        }
        this._outputRows.position.valueEl.textContent = outVec3(pos, 2, 8);
        this._outputRows.linvel.valueEl.textContent = outVec3(linvel, 2, 8);
        this._outputRows.angvel.valueEl.textContent = outVec3(angvel, 2, 8);
        this._outputRows.rotation.valueEl.textContent = rot ? `${outNum(rot.x, 3, 8)}, ${outNum(rot.y, 3, 8)}, ${outNum(rot.z, 3, 8)}` : outVec3(null, 3, 8);

        this._pruneForceEvents();
        this._updateForceLogFromSnapshot(snapshot);

        const contacts = snapshot.contacts ?? { count: 0, total: 0 };
        this._outputRows.contacts.valueEl.textContent = `${padLeft(String(contacts.count ?? 0), 2)}/${padLeft(String(contacts.total ?? 0), 2)}`;
        if (this._outputRows.contacts.dotEls) {
            const dots = this._outputRows.contacts.dotEls;
            const wheels = snapshot.wheelStates ?? [];
            const order = ['FL', 'FR', 'RL', 'RR'];
            for (let i = 0; i < dots.length; i++) {
                const label = order[i];
                const wheel = wheels.find((w) => w?.label === label);
                const on = !!wheel?.inContact;
                dots[i].style.background = on ? 'rgba(76,255,122,0.95)' : 'rgba(255,255,255,0.2)';
                dots[i].style.boxShadow = on
                    ? '0 0 0 1px rgba(76,255,122,0.6), 0 0 10px rgba(76,255,122,0.35)'
                    : '0 0 0 1px rgba(255,255,255,0.15)';
            }
        }

        if (this._outputRows.rayDown) {
            const rd = snapshot.rayDown;
            if (!rd) this._outputRows.rayDown.valueEl.textContent = 'â€”';
            else if (rd.hit) this._outputRows.rayDown.valueEl.textContent = `hit:Y  toi:${outNum(rd.toi, 2, 7)}`;
            else this._outputRows.rayDown.valueEl.textContent = `hit:N  toi:${outNum(NaN, 2, 7)}`;
        }

        if (this._outputRows.counts) {
            const world = snapshot.world ?? {};
            this._outputRows.counts.valueEl.textContent = `bodies:${padLeft(String(world.bodies ?? 'â€”'), 4)}  coll:${padLeft(String(world.colliders ?? 'â€”'), 4)}`;
        }

        const sleeping = snapshot.body?.sleeping;
        const canForceSleep = snapshot.body?.canForceSleep;
        this._sleepingState = sleeping;
        if (this._sleepMarker) {
            if (sleeping === true) {
                this._sleepMarker.style.background = 'rgba(255,76,76,0.95)';
                this._sleepMarker.style.boxShadow = '0 0 0 1px rgba(255,76,76,0.6), 0 0 10px rgba(255,76,76,0.35)';
            } else if (sleeping === false) {
                this._sleepMarker.style.background = 'rgba(76,255,122,0.95)';
                this._sleepMarker.style.boxShadow = '0 0 0 1px rgba(76,255,122,0.6), 0 0 10px rgba(76,255,122,0.35)';
            } else {
                this._sleepMarker.style.background = 'rgba(255,255,255,0.2)';
                this._sleepMarker.style.boxShadow = '0 0 0 1px rgba(255,255,255,0.2)';
            }
        }
        if (this._wakeButton) {
            if (canForceSleep) {
                this._wakeButton.style.display = '';
                if (sleeping === false) {
                    this._wakeButton.textContent = 'Sleep';
                } else {
                    this._wakeButton.textContent = 'Wake up';
                }
            } else {
                this._wakeButton.style.display = 'none';
            }
        }

        const wheelCells = this._wheelCells;
        const wheels = snapshot.wheelStates ?? [];
        const suspRest = this._vehicleConfig?.restLength ?? 0;
        const suspTravel = this._tuning?.suspension?.maxTravel ?? 0;
        const suspMin = Math.max(0, suspRest - suspTravel);
        const suspMax = suspRest + suspTravel;
        if (wheelCells && wheels.length) {
            const find = (label) => wheels.find((w) => w?.label === label);
            const toText = (w, fallbackLabel) => {
                if (!w) return 'â€”';
                const contact = w.inContact ? 'Y' : 'N';
                const steerDeg = Number.isFinite(w.steering) ? -w.steering * (180 / Math.PI) : NaN;
                const centerLocal = w.centerLocal ?? null;
                const connectionLocal = w.connectionPointLocal ?? null;
                return (
                    `${padLeft(String(w.label ?? fallbackLabel), 2)}  contact:${contact}\n` +
                    `steer:${outNum(steerDeg, 1, 5)} deg\n` +
                    `susp len:${outNum(w.suspensionLength, 3, 5)} m\n` +
                    `susp force:${outNum(w.suspensionForce, 0, 5)} N\n` +
                    `imp fwd:${outNum(w.forwardImpulse, 2, 5)}\n` +
                    `imp side:${outNum(w.sideImpulse, 2, 5)}\n` +
                    `centerL:${outNum(centerLocal?.x, 1, 5)} ${outNum(centerLocal?.y, 1, 5)} ${outNum(centerLocal?.z, 1, 5)}\n` +
                    `connectL:${outNum(connectionLocal?.x, 1, 5)} ${outNum(connectionLocal?.y, 1, 5)} ${outNum(connectionLocal?.z, 1, 5)}`
                );
            };

            const apply = (cell, wheel) => {
                if (!cell) return;
                if (cell.textEl) {
                    cell.textEl.textContent = toText(wheel, cell.label ?? 'â€”');
                }
                if (cell.knobEl) {
                    const inContact = !!wheel?.inContact;
                    cell.knobEl.style.background = inContact ? '#4cff7a' : '#c8cbd1';
                    cell.knobEl.style.boxShadow = inContact
                        ? '0 0 0 2px rgba(76,255,122,0.25), 0 0 18px rgba(76,255,122,0.25)'
                        : '0 0 0 2px rgba(0,0,0,0.25)';
                    cell.knobEl.style.opacity = inContact ? '1' : '0.85';
                }
                if (cell.arrowEl) {
                    const steerDeg = Number.isFinite(wheel?.steering) ? -wheel.steering * (180 / Math.PI) : 0;
                    cell.arrowEl.style.transform = `rotate(${steerDeg}deg)`;
                    cell.arrowEl.style.opacity = Number.isFinite(wheel?.steering) ? '1' : '0.2';
                }
                if (cell.barEl) {
                    const len = Number.isFinite(wheel?.suspensionLength) ? wheel.suspensionLength : suspRest;
                    const span = Math.max(1e-6, suspMax - suspMin);
                    const t = Math.min(1, Math.max(0, (len - suspMin) / span));
                    cell.barEl.style.height = `${Math.round(t * 100)}%`;
                }
            };

            apply(wheelCells.fl, find('FL'));
            apply(wheelCells.fr, find('FR'));
            apply(wheelCells.rl, find('RL'));
            apply(wheelCells.rr, find('RR'));
        }
    }

    _buildHud() {
        const root = makeHudRoot();
        const helpSystem = this._createHelpSystem(root);
        this._helpSystem = helpSystem;

        const inputPanel = document.createElement('div');
        stylePanel(inputPanel, { interactive: true });
        const inputHeader = document.createElement('div');
        inputHeader.style.display = 'flex';
        inputHeader.style.alignItems = 'center';
        inputHeader.style.justifyContent = 'space-between';
        inputHeader.style.gap = '10px';

        const inputTitle = makeTitle('Rapier Input');
        inputTitle.style.marginBottom = '0';
        inputHeader.appendChild(inputTitle);

        inputHeader.style.marginBottom = '10px';
        inputPanel.appendChild(inputHeader);
        inputPanel.style.flex = '4 1 972px';
        inputPanel.style.minWidth = '842px';
        inputPanel.style.width = 'auto';
        inputPanel.style.maxHeight = 'calc(100vh - 32px)';
        inputPanel.style.overflowY = 'auto';
        inputPanel.style.overflowX = 'auto';

        const columns = document.createElement('div');
        columns.style.display = 'grid';
        columns.style.gridTemplateColumns = 'minmax(240px, 1fr) minmax(240px, 1fr)';
        columns.style.gap = '10px 16px';

        const leftCol = document.createElement('div');
        leftCol.style.display = 'flex';
        leftCol.style.flexDirection = 'column';
        leftCol.style.minWidth = '240px';

        const middleCol = document.createElement('div');
        middleCol.style.display = 'flex';
        middleCol.style.flexDirection = 'column';
        middleCol.style.minWidth = '240px';


        const internalGroups = {
            vehicle: makeGroup('Vehicle', { tightTop: true }),
            suspension: makeGroup('Suspension'),
            tires: makeGroup('Tires'),
            bodyType: makeGroup('Rigid-body Type', { tightTop: true, showLabel: false }),
            mass: makeGroup('Mass Properties'),
            damping: makeGroup('Damping'),
            dominance: makeGroup('Dominance', { showLabel: false }),
            ccd: makeGroup('Continuous Collision Detection', { showLabel: false }),
            sleeping: makeGroup('Sleeping', { showLabel: false })
        };

        middleCol.appendChild(internalGroups.vehicle.wrap);
        middleCol.appendChild(internalGroups.suspension.wrap);
        middleCol.appendChild(internalGroups.tires.wrap);

        middleCol.appendChild(internalGroups.mass.wrap);
        middleCol.appendChild(internalGroups.damping.wrap);

        columns.appendChild(leftCol);
        columns.appendChild(middleCol);
        inputPanel.appendChild(columns);

        this._inputControls.bodyType = makeSelectControl({
            title: 'Type',
            value: this._tuning.chassis.bodyType,
            options: [
                { value: 'dynamic', label: 'Dynamic' },
                { value: 'fixed', label: 'Fixed' },
                { value: 'kinematicPositionBased', label: 'Kinematic (Position)' },
                { value: 'kinematicVelocityBased', label: 'Kinematic (Velocity)' }
            ],
            help: INPUT_HELP.bodyType,
            helpSystem
        });
        internalGroups.bodyType.body.appendChild(this._inputControls.bodyType.wrap);

        this._inputControls.translationX = { input: null, valEl: null };
        this._inputControls.spawnHeight = { input: null, valEl: null };
        this._inputControls.translationZ = { input: null, valEl: null };
        this._inputControls.linvelX = { input: null, valEl: null };
        this._inputControls.linvelY = { input: null, valEl: null };
        this._inputControls.linvelZ = { input: null, valEl: null };
        this._inputControls.angvelX = { input: null, valEl: null };
        this._inputControls.angvelY = { input: null, valEl: null };
        this._inputControls.angvelZ = { input: null, valEl: null };

        this._inputControls.forceX = makeNumberControl({
            title: 'Force X (N)',
            value: this._forces.force.x,
            help: INPUT_HELP.force,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.forceY = makeNumberControl({
            title: 'Force Y (N)',
            value: this._forces.force.y,
            help: INPUT_HELP.force,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.forceZ = makeNumberControl({
            title: 'Force Z (N)',
            value: this._forces.force.z,
            help: INPUT_HELP.force,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.forcePointX = makeNumberControl({
            title: 'Force point X (m)',
            value: this._forces.forcePoint.x,
            help: INPUT_HELP.forcePoint,
            helpSystem,
            step: 0.1,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.forcePointY = makeNumberControl({
            title: 'Force point Y (m)',
            value: this._forces.forcePoint.y,
            help: INPUT_HELP.forcePoint,
            helpSystem,
            step: 0.1,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.forcePointZ = makeNumberControl({
            title: 'Force point Z (m)',
            value: this._forces.forcePoint.z,
            help: INPUT_HELP.forcePoint,
            helpSystem,
            step: 0.1,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.torqueX = makeNumberControl({
            title: 'Torque X (N*m)',
            value: this._forces.torque.x,
            help: INPUT_HELP.torque,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.torqueY = makeNumberControl({
            title: 'Torque Y (N*m)',
            value: this._forces.torque.y,
            help: INPUT_HELP.torque,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.torqueZ = makeNumberControl({
            title: 'Torque Z (N*m)',
            value: this._forces.torque.z,
            help: INPUT_HELP.torque,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        const addForceButton = makeButton('Add force');
        addForceButton.addEventListener('click', () => {
            if (this.onAddForce) {
                this.onAddForce(this._forces.force);
                this._recordForceEvent('Force', this._forces.force);
            }
        });
        this._actionButtons.push(addForceButton);

        const addForcePointButton = makeButton('Add force @ point');
        addForcePointButton.addEventListener('click', () => {
            if (this.onAddForceAtPoint) {
                this.onAddForceAtPoint(this._forces.force, this._forces.forcePoint);
                this._recordForceEvent('Force', this._forces.force, this._forces.forcePoint);
                const induced = crossVec3(this._forces.forcePoint, this._forces.force);
                this._recordForceEvent('Torque (from force @ point)', induced);
            }
        });
        this._actionButtons.push(addForcePointButton);

        const addTorqueButton = makeButton('Add torque');
        addTorqueButton.addEventListener('click', () => {
            if (this.onAddTorque) {
                this.onAddTorque(this._forces.torque);
                this._recordForceEvent('Torque', this._forces.torque);
            }
        });
        this._actionButtons.push(addTorqueButton);

        const resetForcesButton = makeButton('Reset forces');
        resetForcesButton.addEventListener('click', () => {
            this.onResetForces?.();
            this._setForceLogEntry('const-force', null);
            this._clearForceEventLog({ category: 'force', keepConstants: true });
        });
        this._actionButtons.push(resetForcesButton);

        const resetTorquesButton = makeButton('Reset torques');
        resetTorquesButton.addEventListener('click', () => {
            this.onResetTorques?.();
            this._setForceLogEntry('const-torque', null);
            this._clearForceEventLog({ category: 'torque', keepConstants: true });
        });
        this._actionButtons.push(resetTorquesButton);

        this._inputControls.impulseX = makeNumberControl({
            title: 'Impulse X (N*s)',
            value: this._forces.impulse.x,
            help: INPUT_HELP.impulse,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.impulseY = makeNumberControl({
            title: 'Impulse Y (N*s)',
            value: this._forces.impulse.y,
            help: INPUT_HELP.impulse,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.impulseZ = makeNumberControl({
            title: 'Impulse Z (N*s)',
            value: this._forces.impulse.z,
            help: INPUT_HELP.impulse,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.impulsePointX = makeNumberControl({
            title: 'Impulse point X (m)',
            value: this._forces.impulsePoint.x,
            help: INPUT_HELP.impulsePoint,
            helpSystem,
            step: 0.1,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.impulsePointY = makeNumberControl({
            title: 'Impulse point Y (m)',
            value: this._forces.impulsePoint.y,
            help: INPUT_HELP.impulsePoint,
            helpSystem,
            step: 0.1,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.impulsePointZ = makeNumberControl({
            title: 'Impulse point Z (m)',
            value: this._forces.impulsePoint.z,
            help: INPUT_HELP.impulsePoint,
            helpSystem,
            step: 0.1,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.torqueImpulseX = makeNumberControl({
            title: 'Torque impulse X (N*m*s)',
            value: this._forces.torqueImpulse.x,
            help: INPUT_HELP.torqueImpulse,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.torqueImpulseY = makeNumberControl({
            title: 'Torque impulse Y (N*m*s)',
            value: this._forces.torqueImpulse.y,
            help: INPUT_HELP.torqueImpulse,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        this._inputControls.torqueImpulseZ = makeNumberControl({
            title: 'Torque impulse Z (N*m*s)',
            value: this._forces.torqueImpulse.z,
            help: INPUT_HELP.torqueImpulse,
            helpSystem,
            step: 10,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });

        const applyImpulseButton = makeButton('Apply impulse');
        applyImpulseButton.addEventListener('click', () => {
            if (this.onApplyImpulse) {
                this.onApplyImpulse(this._forces.impulse);
                this._recordForceEvent('Impulse', this._forces.impulse);
            }
        });
        this._actionButtons.push(applyImpulseButton);

        const applyImpulsePointButton = makeButton('Apply impulse @ point');
        applyImpulsePointButton.addEventListener('click', () => {
            if (this.onApplyImpulseAtPoint) {
                this.onApplyImpulseAtPoint(this._forces.impulse, this._forces.impulsePoint);
                this._recordForceEvent('Impulse', this._forces.impulse, this._forces.impulsePoint);
            }
        });
        this._actionButtons.push(applyImpulsePointButton);

        const applyTorqueImpulseButton = makeButton('Apply torque impulse');
        applyTorqueImpulseButton.addEventListener('click', () => {
            if (this.onApplyTorqueImpulse) {
                this.onApplyTorqueImpulse(this._forces.torqueImpulse);
                this._recordForceEvent('Torque impulse', this._forces.torqueImpulse);
            }
        });
        this._actionButtons.push(applyTorqueImpulseButton);

        const resetAllVelocitiesButton = makeButton('Reset velocities');
        resetAllVelocitiesButton.addEventListener('click', () => {
            this.onResetVelocities?.();
        });
        this._actionButtons.push(resetAllVelocitiesButton);

        this._forcePopupControls = {
            forceX: this._inputControls.forceX.wrap,
            forceY: this._inputControls.forceY.wrap,
            forceZ: this._inputControls.forceZ.wrap,
            forcePointX: this._inputControls.forcePointX.wrap,
            forcePointY: this._inputControls.forcePointY.wrap,
            forcePointZ: this._inputControls.forcePointZ.wrap,
            torqueX: this._inputControls.torqueX.wrap,
            torqueY: this._inputControls.torqueY.wrap,
            torqueZ: this._inputControls.torqueZ.wrap,
            impulseX: this._inputControls.impulseX.wrap,
            impulseY: this._inputControls.impulseY.wrap,
            impulseZ: this._inputControls.impulseZ.wrap,
            impulsePointX: this._inputControls.impulsePointX.wrap,
            impulsePointY: this._inputControls.impulsePointY.wrap,
            impulsePointZ: this._inputControls.impulsePointZ.wrap,
            torqueImpulseX: this._inputControls.torqueImpulseX.wrap,
            torqueImpulseY: this._inputControls.torqueImpulseY.wrap,
            torqueImpulseZ: this._inputControls.torqueImpulseZ.wrap
        };

        this._forcePopupButtons = {
            applyForce: addForceButton,
            applyForceAtPoint: addForcePointButton,
            resetForces: resetForcesButton,
            applyImpulse: applyImpulseButton,
            applyImpulseAtPoint: applyImpulsePointButton,
            applyTorque: addTorqueButton,
            applyTorqueImpulse: applyTorqueImpulseButton,
            resetTorques: resetTorquesButton,
            resetVelocities: resetAllVelocitiesButton
        };

        this._inputControls.additionalMass = makeNumberControl({
            title: 'Additional mass (kg)',
            value: this._tuning.chassis.additionalMass,
            help: INPUT_HELP.additionalMass,
            helpSystem,
            min: 0,
            max: 100000,
            step: 10,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.mass.body.appendChild(this._inputControls.additionalMass.wrap);

        this._inputControls.massPropsMass = makeNumberControl({
            title: 'Mass props mass (kg)',
            value: this._tuning.chassis.additionalMassProperties.mass,
            help: INPUT_HELP.massPropsMass,
            helpSystem,
            min: 0,
            max: 100000,
            step: 10,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.mass.body.appendChild(this._inputControls.massPropsMass.wrap);

        this._inputControls.massPropsComX = { input: null, valEl: null };
        this._inputControls.massPropsComY = { input: null, valEl: null };
        this._inputControls.massPropsComZ = { input: null, valEl: null };

        const comRow = document.createElement('div');
        comRow.style.display = 'flex';
        comRow.style.alignItems = 'center';
        comRow.style.justifyContent = 'space-between';
        comRow.style.gap = '10px';
        comRow.style.margin = '8px 0 10px';

        const comLabel = document.createElement('div');
        comLabel.textContent = 'Center of mass';
        comLabel.style.fontSize = '13px';
        comLabel.style.fontWeight = '700';
        comLabel.style.opacity = '0.95';

        const comButton = makeButton('...');
        comButton.style.padding = '4px 8px';
        comButton.style.fontSize = '11px';
        comButton.style.borderRadius = '8px';
        comButton.style.marginRight = '0';
        comButton.addEventListener('click', (event) => {
            event.preventDefault();
            this._openComPopup(comButton);
        });

        comRow.appendChild(comLabel);
        comRow.appendChild(comButton);
        internalGroups.mass.body.appendChild(comRow);

        const inertiaRow = document.createElement('div');
        inertiaRow.style.display = 'flex';
        inertiaRow.style.alignItems = 'center';
        inertiaRow.style.justifyContent = 'space-between';
        inertiaRow.style.gap = '10px';
        inertiaRow.style.margin = '8px 0 10px';

        const inertiaLabel = document.createElement('div');
        inertiaLabel.textContent = 'Inertia (Principal)';
        inertiaLabel.style.fontSize = '13px';
        inertiaLabel.style.fontWeight = '700';
        inertiaLabel.style.opacity = '0.95';
        appendHelp(inertiaLabel, INPUT_HELP.inertia, helpSystem);

        const inertiaButton = makeButton('...');
        inertiaButton.style.padding = '4px 8px';
        inertiaButton.style.fontSize = '11px';
        inertiaButton.style.borderRadius = '8px';
        inertiaButton.style.marginRight = '0';
        inertiaButton.addEventListener('click', (event) => {
            event.preventDefault();
            this._openInertiaPopup(inertiaButton);
        });

        inertiaRow.appendChild(inertiaLabel);
        inertiaRow.appendChild(inertiaButton);

        const inertiaFrameRow = document.createElement('div');
        inertiaFrameRow.style.display = 'flex';
        inertiaFrameRow.style.alignItems = 'center';
        inertiaFrameRow.style.justifyContent = 'space-between';
        inertiaFrameRow.style.gap = '10px';
        inertiaFrameRow.style.margin = '8px 0 10px';

        const inertiaFrameLabel = document.createElement('div');
        inertiaFrameLabel.textContent = 'Inertia Frame (Quat)';
        inertiaFrameLabel.style.fontSize = '13px';
        inertiaFrameLabel.style.fontWeight = '700';
        inertiaFrameLabel.style.opacity = '0.95';
        appendHelp(inertiaFrameLabel, INPUT_HELP.inertiaFrame, helpSystem);

        const inertiaFrameButton = makeButton('...');
        inertiaFrameButton.style.padding = '4px 8px';
        inertiaFrameButton.style.fontSize = '11px';
        inertiaFrameButton.style.borderRadius = '8px';
        inertiaFrameButton.style.marginRight = '0';
        inertiaFrameButton.addEventListener('click', (event) => {
            event.preventDefault();
            this._openInertiaFramePopup(inertiaFrameButton);
        });

        inertiaFrameRow.appendChild(inertiaFrameLabel);
        inertiaFrameRow.appendChild(inertiaFrameButton);

        this._inputControls.lockTranslations = makeToggleControl({
            title: 'Lock translations',
            value: this._tuning.chassis.lockTranslations,
            help: INPUT_HELP.lockTranslations,
            helpSystem
        });

        this._inputControls.lockRotations = makeToggleControl({
            title: 'Lock rotations',
            value: this._tuning.chassis.lockRotations,
            help: INPUT_HELP.lockRotations,
            helpSystem
        });

        this._inputControls.enabledRotX = makeToggleControl({
            title: 'Enable rotation X',
            value: this._tuning.chassis.enabledRotations.x,
            help: INPUT_HELP.enabledRotations,
            helpSystem
        });

        this._inputControls.enabledRotY = makeToggleControl({
            title: 'Enable rotation Y',
            value: this._tuning.chassis.enabledRotations.y,
            help: INPUT_HELP.enabledRotations,
            helpSystem
        });

        this._inputControls.enabledRotZ = makeToggleControl({
            title: 'Enable rotation Z',
            value: this._tuning.chassis.enabledRotations.z,
            help: INPUT_HELP.enabledRotations,
            helpSystem
        });

        const lockingRow = document.createElement('div');
        lockingRow.style.display = 'flex';
        lockingRow.style.alignItems = 'center';
        lockingRow.style.justifyContent = 'space-between';
        lockingRow.style.gap = '10px';
        lockingRow.style.margin = '8px 0 10px';

        const lockingLabel = document.createElement('div');
        lockingLabel.textContent = 'Locking';
        lockingLabel.style.fontSize = '13px';
        lockingLabel.style.fontWeight = '700';
        lockingLabel.style.opacity = '0.95';
        appendHelp(lockingLabel, INPUT_HELP.locking, helpSystem);

        const lockingButton = makeButton('...');
        lockingButton.style.padding = '4px 8px';
        lockingButton.style.fontSize = '11px';
        lockingButton.style.borderRadius = '8px';
        lockingButton.style.marginRight = '0';
        lockingButton.addEventListener('click', (event) => {
            event.preventDefault();
            this._openLockingPopup(lockingButton);
        });

        lockingRow.appendChild(lockingLabel);
        lockingRow.appendChild(lockingButton);

        this._inputControls.linearDamping = makeNumberControl({
            title: 'Linear damping',
            value: this._tuning.chassis.linearDamping,
            help: INPUT_HELP.linearDamping,
            helpSystem,
            step: 0.01,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.damping.body.appendChild(this._inputControls.linearDamping.wrap);

        this._inputControls.angularDamping = makeNumberControl({
            title: 'Angular damping',
            value: this._tuning.chassis.angularDamping,
            help: INPUT_HELP.angularDamping,
            helpSystem,
            step: 0.01,
            width: '100px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.damping.body.appendChild(this._inputControls.angularDamping.wrap);

        this._inputControls.dominanceGroup = makeNumberControl({
            title: 'Dominance group',
            value: this._tuning.chassis.dominanceGroup,
            help: INPUT_HELP.dominanceGroup,
            helpSystem,
            min: -127,
            max: 127,
            step: 1,
            width: '100px'
        });
        internalGroups.dominance.body.appendChild(this._inputControls.dominanceGroup.wrap);

        this._inputControls.ccdEnabled = makeToggleControl({
            title: 'CCD enabled',
            value: this._tuning.chassis.ccdEnabled,
            help: INPUT_HELP.ccdEnabled,
            helpSystem
        });
        internalGroups.ccd.body.appendChild(this._inputControls.ccdEnabled.wrap);

        const sleepRow = document.createElement('div');
        sleepRow.style.display = 'flex';
        sleepRow.style.alignItems = 'center';
        sleepRow.style.justifyContent = 'flex-start';
        sleepRow.style.gap = '10px';
        sleepRow.style.margin = '8px 0 10px';

        const sleepLabel = document.createElement('div');
        sleepLabel.textContent = 'Can sleep';
        sleepLabel.style.fontSize = '13px';
        sleepLabel.style.fontWeight = '700';
        sleepLabel.style.opacity = '0.95';
        sleepLabel.style.display = 'flex';
        sleepLabel.style.alignItems = 'center';
        appendHelp(sleepLabel, INPUT_HELP.canSleep, helpSystem);

        const sleepToggle = document.createElement('input');
        sleepToggle.type = 'checkbox';
        sleepToggle.checked = !!this._tuning.chassis.canSleep;
        sleepToggle.style.width = '16px';
        sleepToggle.style.height = '16px';
        sleepToggle.style.cursor = 'pointer';

        const sleepMarker = document.createElement('div');
        sleepMarker.style.width = '10px';
        sleepMarker.style.height = '10px';
        sleepMarker.style.borderRadius = '999px';
        sleepMarker.style.background = 'rgba(255,255,255,0.2)';
        sleepMarker.style.boxShadow = '0 0 0 1px rgba(255,255,255,0.2)';
        sleepMarker.style.cursor = 'default';
        if (helpSystem) {
            const statusText = () => {
                if (this._sleepingState === true) return 'Sleeping';
                if (this._sleepingState === false) return 'Awake';
                return 'Sleep status: n/a';
            };
            sleepMarker.addEventListener('mouseenter', (e) => helpSystem.show(statusText(), e));
            sleepMarker.addEventListener('mousemove', (e) => helpSystem.move(e));
            sleepMarker.addEventListener('mouseleave', () => helpSystem.hide());
        }
        this._sleepMarker = sleepMarker;

        const wakeButton = makeButton('Wake up');
        wakeButton.style.padding = '7px 12px';
        wakeButton.style.fontSize = '12px';
        wakeButton.style.borderRadius = '8px';
        wakeButton.style.marginRight = '0';
        wakeButton.style.minWidth = '72px';
        wakeButton.addEventListener('click', () => {
            if (this._sleepingState === false) {
                this.onSleep?.();
            } else {
                this.onWakeUp?.();
            }
        });
        this._actionButtons.push(wakeButton);
        this._wakeButton = wakeButton;

        const sleepControls = document.createElement('div');
        sleepControls.style.display = 'inline-flex';
        sleepControls.style.alignItems = 'center';
        sleepControls.style.gap = '8px';
        sleepControls.style.marginLeft = 'auto';
        sleepControls.appendChild(sleepToggle);
        sleepControls.appendChild(sleepMarker);
        sleepControls.appendChild(wakeButton);

        sleepRow.appendChild(sleepLabel);
        sleepRow.appendChild(sleepControls);
        internalGroups.sleeping.body.appendChild(sleepRow);
        this._inputControls.canSleep = { input: sleepToggle, valEl: null, wrap: sleepRow };

        leftCol.appendChild(makeLabel('Wheel Forces'));

        this._inputControls.engineForce = makeRangeControl({
            title: 'Engine (N)',
            min: 0,
            max: 25000,
            step: 100,
            value: this._inputs.engineForce,
            fmt: (v) => formatNum(v, 0),
            help: INPUT_HELP.engineForce,
            helpSystem
        });
        leftCol.appendChild(this._inputControls.engineForce.wrap);

        this._inputControls.brakeForce = makeRangeControl({
            title: 'Brake (N)',
            min: 0,
            max: 25000,
            step: 100,
            value: this._inputs.brakeForce,
            fmt: (v) => formatNum(v, 0),
            help: INPUT_HELP.brakeForce,
            helpSystem
        });
        leftCol.appendChild(this._inputControls.brakeForce.wrap);

        this._inputControls.handbrakeForce = makeRangeControl({
            title: 'Handbrake (N)',
            min: 0,
            max: 25000,
            step: 100,
            value: this._inputs.handbrakeForce,
            fmt: (v) => formatNum(v, 0),
            help: INPUT_HELP.handbrakeForce,
            helpSystem
        });
        leftCol.appendChild(this._inputControls.handbrakeForce.wrap);

        this._inputControls.steerAngle = makeKnobControl({
            title: 'Steering',
            min: -0.8,
            max: 0.8,
            step: 0.01,
            value: this._inputs.steerAngle,
            fmt: (v) => formatNum(v, 2),
            help: INPUT_HELP.steerAngle,
            helpSystem
        });
        leftCol.appendChild(this._inputControls.steerAngle.wrap);

        this._inputControls.groundClearance = makeNumberControl({
            title: 'Ground clearance (m)',
            value: this._vehicleConfig.groundClearance,
            help: INPUT_HELP.groundClearance,
            helpSystem,
            step: 0.01,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.vehicle.body.appendChild(this._inputControls.groundClearance.wrap);

        internalGroups.vehicle.body.appendChild(makeLabel('Wheel placement'));

        this._inputControls.wheelSideInset = makeInlineRangeNumberControl({
            title: 'Side offset (m)',
            min: -0.5,
            max: 0.66,
            step: 0.01,
            value: this._vehicleConfig.wheelSideInset,
            fmt: (v) => formatNum(v, 2),
            help: INPUT_HELP.wheelSideInset,
            helpSystem,
            sliderWidth: '140px',
            inputWidth: '110px'
        });
        internalGroups.vehicle.body.appendChild(this._inputControls.wheelSideInset.wrap);

        this._inputControls.wheelbaseRatio = makeInlineRangeNumberControl({
            title: 'Base ratio',
            min: 0.0,
            max: 1.3,
            step: 0.01,
            value: this._vehicleConfig.wheelbaseRatio,
            fmt: (v) => formatNum(v, 2),
            help: INPUT_HELP.wheelbaseRatio,
            helpSystem,
            sliderWidth: '140px',
            inputWidth: '110px'
        });
        internalGroups.vehicle.body.appendChild(this._inputControls.wheelbaseRatio.wrap);

        this._inputControls.restLength = makeNumberControl({
            title: 'Suspension rest length (m)',
            value: this._vehicleConfig.restLength,
            help: INPUT_HELP.restLength,
            helpSystem,
            step: 0.01,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.suspension.body.appendChild(this._inputControls.restLength.wrap);

        this._inputControls.suspMaxTravel = makeNumberControl({
            title: 'Max travel (m)',
            value: this._tuning.suspension.maxTravel,
            help: INPUT_HELP.suspMaxTravel,
            helpSystem,
            step: 0.01,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.suspension.body.appendChild(this._inputControls.suspMaxTravel.wrap);

        this._inputControls.suspStiffness = makeNumberControl({
            title: 'Stiffness',
            value: this._tuning.suspension.stiffness,
            help: INPUT_HELP.suspStiffness,
            helpSystem,
            min: 0,
            max: 10000,
            step: 10,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.suspension.body.appendChild(this._inputControls.suspStiffness.wrap);

        this._inputControls.suspCompression = makeNumberControl({
            title: 'Compression',
            value: this._tuning.suspension.compression,
            help: INPUT_HELP.suspCompression,
            helpSystem,
            min: 0,
            max: 5,
            step: 0.1,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.suspension.body.appendChild(this._inputControls.suspCompression.wrap);

        this._inputControls.suspRelaxation = makeNumberControl({
            title: 'Relaxation',
            value: this._tuning.suspension.relaxation,
            help: INPUT_HELP.suspRelaxation,
            helpSystem,
            min: 0,
            max: 5,
            step: 0.1,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.suspension.body.appendChild(this._inputControls.suspRelaxation.wrap);

        this._inputControls.suspMaxForce = makeNumberControl({
            title: 'Max force',
            value: this._tuning.suspension.maxForce,
            help: INPUT_HELP.suspMaxForce,
            helpSystem,
            min: 0,
            max: 50000,
            step: 100,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.suspension.body.appendChild(this._inputControls.suspMaxForce.wrap);

        this._inputControls.tireFrictionSlip = makeNumberControl({
            title: 'Friction slip',
            value: this._tuning.tires.frictionSlip,
            help: INPUT_HELP.tireFrictionSlip,
            helpSystem,
            step: 0.1,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.tires.body.appendChild(this._inputControls.tireFrictionSlip.wrap);

        this._inputControls.tireSideStiffness = makeNumberControl({
            title: 'Side friction stiffness',
            value: this._tuning.tires.sideFrictionStiffness,
            help: INPUT_HELP.tireSideStiffness,
            helpSystem,
            step: 0.05,
            width: '110px',
            sliderWidth: '140px',
            controlsAlignRight: true
        });
        internalGroups.tires.body.appendChild(this._inputControls.tireSideStiffness.wrap);

        const resetButton = makeButton('Reset');
        resetButton.title = [
            'Reset: configure and apply a reset to the vehicle body.',
            'Options include position/rotation, linear/angular velocity, plus Live auto-reset scheduling.',
            'Use Apply to reset once; enable Live to repeat the reset automatically.'
        ].join('\n');
        resetButton.addEventListener('click', (event) => {
            event.preventDefault();
            this._openPositionPopup(resetButton, { resetOnApply: true });
        });
        resetButton.style.padding = '8px 12px';
        resetButton.style.fontSize = '14px';
        resetButton.style.borderRadius = '8px';
        resetButton.style.marginRight = '0';
        resetButton.style.width = '100%';
        resetButton.style.position = 'relative';
        this._resetButton = resetButton;
        this._resetButtonBorder = resetButton.style.border;

        const resetDot = document.createElement('span');
        resetDot.style.position = 'absolute';
        resetDot.style.right = '12px';
        resetDot.style.top = '50%';
        resetDot.style.transform = 'translateY(-50%)';
        resetDot.style.width = '9px';
        resetDot.style.height = '9px';
        resetDot.style.borderRadius = '999px';
        resetDot.style.background = 'rgba(76,255,122,0.95)';
        resetDot.style.boxShadow = '0 0 10px rgba(76,255,122,0.55), 0 0 0 1px rgba(76,255,122,0.85)';
        resetDot.style.visibility = 'hidden';
        resetButton.appendChild(resetDot);
        this._resetLiveDot = resetDot;
        const forcesManageButton = makeButton('Forces and Impulses');
        forcesManageButton.title = [
            'Forces and Impulses: apply external inputs to the vehicle body.',
            'Force/Torque are persistent (until reset); Impulse/Torque impulse are instantaneous.',
            'â€œ@ pointâ€ applies at a world-space point and can induce rotation.',
            'Use Reset forces/torques to clear persistent effects and the applied log.'
        ].join('\n');
        forcesManageButton.style.padding = '8px 12px';
        forcesManageButton.style.fontSize = '14px';
        forcesManageButton.style.borderRadius = '8px';
        forcesManageButton.style.marginRight = '0';
        forcesManageButton.style.width = '100%';
        forcesManageButton.addEventListener('click', (event) => {
            event.preventDefault();
            this._openForcesPopup(forcesManageButton);
        });

        leftCol.appendChild(makeSeparator());

        const gravityRow = document.createElement('div');
        gravityRow.style.display = 'flex';
        gravityRow.style.alignItems = 'center';
        gravityRow.style.gap = '10px';
        gravityRow.style.margin = '8px 0 10px';
        gravityRow.style.width = '100%';
        gravityRow.style.boxSizing = 'border-box';

        const gravityLabel = document.createElement('div');
        gravityLabel.textContent = 'Gravity';
        gravityLabel.style.fontSize = '13px';
        gravityLabel.style.fontWeight = '700';
        gravityLabel.style.opacity = '0.95';
        gravityLabel.style.display = 'flex';
        gravityLabel.style.alignItems = 'center';
        gravityLabel.style.flex = '0 0 auto';
        appendHelp(gravityLabel, INPUT_HELP.worldGravity, helpSystem);

        const gravityScale = document.createElement('input');
        gravityScale.type = 'range';
        gravityScale.min = '0';
        gravityScale.max = '3';
        gravityScale.step = '0.05';
        gravityScale.value = String(this._tuning.chassis.gravityScale ?? 1);
        gravityScale.style.flex = '1 1 0';
        gravityScale.style.minWidth = '0';
        gravityScale.style.width = '100%';
        gravityScale.style.cursor = 'pointer';

        const gravityScaleOut = document.createElement('div');
        gravityScaleOut.style.fontSize = '11px';
        gravityScaleOut.style.fontWeight = '700';
        gravityScaleOut.style.opacity = '0.75';
        gravityScaleOut.style.whiteSpace = 'nowrap';
        gravityScaleOut.style.flex = '0 0 auto';
        gravityScaleOut.style.textAlign = 'right';
        gravityScaleOut.style.minWidth = '72px';
        gravityScaleOut.textContent = `${formatNum(parseFloat(gravityScale.value), 2)}`;

        const gravityButton = document.createElement('button');
        gravityButton.type = 'button';
        gravityButton.textContent = '...';
        gravityButton.style.padding = '4px 8px';
        gravityButton.style.borderRadius = '8px';
        gravityButton.style.border = '1px solid rgba(255,255,255,0.16)';
        gravityButton.style.background = 'rgba(12, 16, 24, 0.9)';
        gravityButton.style.color = '#e9f2ff';
        gravityButton.style.fontWeight = '700';
        gravityButton.style.cursor = 'pointer';
        gravityButton.style.flexShrink = '0';

        gravityRow.appendChild(gravityLabel);
        gravityRow.appendChild(gravityScale);
        gravityRow.appendChild(gravityScaleOut);
        gravityRow.appendChild(gravityButton);
        leftCol.appendChild(gravityRow);

        this._inputControls.worldGravityX = { input: null, valEl: null };
        this._inputControls.worldGravityY = { input: null, valEl: null };
        this._inputControls.worldGravityZ = { input: null, valEl: null };
        this._inputControls.gravityScale = {
            input: gravityScale,
            valEl: gravityScaleOut,
            wrap: gravityRow,
            fmt: (v) => `${formatNum(v, 2)}`
        };
        this._gravityDisplay = null;
        gravityScale.addEventListener('input', () => {
            const v = parseFloat(gravityScale.value);
            gravityScaleOut.textContent = `${formatNum(v, 2)}`;
        });
        gravityButton.addEventListener('click', (event) => {
            event.preventDefault();
            this._openGravityPopup(gravityButton);
        });

        leftCol.appendChild(internalGroups.ccd.wrap);
        leftCol.appendChild(internalGroups.sleeping.wrap);

        leftCol.appendChild(internalGroups.bodyType.wrap);
        leftCol.appendChild(inertiaRow);
        leftCol.appendChild(inertiaFrameRow);
        leftCol.appendChild(lockingRow);
        leftCol.appendChild(internalGroups.dominance.wrap);

        const bottomActions = document.createElement('div');
        bottomActions.style.display = 'flex';
        bottomActions.style.flexDirection = 'column';
        bottomActions.style.gap = '8px';

        const forcesSeparator = makeSeparator();
        forcesSeparator.style.margin = '6px 0 4px';
        bottomActions.appendChild(forcesSeparator);
        bottomActions.appendChild(forcesManageButton);
        bottomActions.appendChild(resetButton);
        leftCol.appendChild(bottomActions);

        leftCol.appendChild(makeSeparator());

        const testsButton = makeButton('Run Automated Tests');
        testsButton.style.width = '100%';
        testsButton.style.padding = '8px 12px';
        testsButton.style.fontSize = '14px';
        testsButton.style.borderRadius = '8px';
        testsButton.style.marginRight = '0';
        testsButton.style.marginBottom = '10px';
        testsButton.addEventListener('click', (event) => {
            event.preventDefault();
            this._openTestsPopup(testsButton);
        });
        leftCol.appendChild(testsButton);
        this._testButtons.push(testsButton);

        const sampleWrap = document.createElement('div');
        sampleWrap.style.display = 'flex';
        sampleWrap.style.flexWrap = 'wrap';
        sampleWrap.style.gap = '8px';
        sampleWrap.style.marginBottom = '10px';

        const recordButton = makeButton('Record sample');
        recordButton.style.width = '100%';
        recordButton.style.flex = '1 1 100%';
        recordButton.style.padding = '8px 12px';
        recordButton.style.fontSize = '14px';
        recordButton.style.borderRadius = '8px';
        recordButton.style.marginRight = '0';
        recordButton.textContent = '';
        recordButton.style.position = 'relative';

        const recordLabel = document.createElement('span');
        recordLabel.textContent = 'Record sample';
        recordLabel.style.display = 'block';
        recordLabel.style.width = '100%';
        recordLabel.style.textAlign = 'center';
        recordButton.appendChild(recordLabel);
        this._recordLabel = recordLabel;

        const recordDot = document.createElement('span');
        recordDot.style.position = 'absolute';
        recordDot.style.right = '12px';
        recordDot.style.top = '50%';
        recordDot.style.transform = 'translateY(-50%)';
        recordDot.style.width = '9px';
        recordDot.style.height = '9px';
        recordDot.style.borderRadius = '999px';
        recordDot.style.background = 'rgba(255,45,45,0.95)';
        recordDot.style.boxShadow = '0 0 10px rgba(255,45,45,0.6), 0 0 0 1px rgba(255,45,45,0.9)';
        recordDot.style.visibility = 'hidden';
        recordButton.appendChild(recordDot);
        this._recordDot = recordDot;

        recordButton.addEventListener('click', () => {
            if (!this._enabled || this._activeTest || this._sampleRecording) return;
            if (this._recordDot) {
                this._recordDot.style.visibility = 'visible';
            }
            if (this._recordDotTimer) {
                clearTimeout(this._recordDotTimer);
            }
            this._recordDotTimer = window.setTimeout(() => {
                if (this._recordDot) {
                    this._recordDot.style.visibility = 'hidden';
                }
                if (this._recordLabel) {
                    this._recordLabel.textContent = 'Record sample';
                }
                this._showAxisToast('Sample copied to clipboard');
                this._recordDotTimer = null;
            }, 1000);
            this._startSampleRecord();
        });
        sampleWrap.appendChild(recordButton);
        this._recordButton = recordButton;

        leftCol.appendChild(sampleWrap);

        const status = document.createElement('div');
        status.style.fontSize = '12px';
        status.style.opacity = '0.8';
        status.textContent = '';
        leftCol.appendChild(status);
        this._statusText = status;

        const copyButton = makeButton('Copy Telemetry');
        copyButton.style.display = 'none';
        copyButton.style.padding = '8px 12px';
        copyButton.style.fontSize = '14px';
        copyButton.style.borderRadius = '8px';
        copyButton.style.marginRight = '0';
        copyButton.addEventListener('click', () => {
            this._copyTelemetry().then(() => {
                this._showAxisToast('Telemetry copied to clipboard');
            });
        });
        leftCol.appendChild(copyButton);
        this._copyButton = copyButton;

        const outputPanel = document.createElement('div');
        stylePanel(outputPanel, { interactive: true });
        outputPanel.style.flex = '1 1 260px';
        outputPanel.style.minWidth = '240px';
        outputPanel.style.width = 'auto';
        outputPanel.style.overflowX = 'hidden';
        outputPanel.appendChild(makeTitle('Rapier Output'));

        this._outputRows.status = makeValueRow('Status', { help: OUTPUT_HELP.status, helpSystem });
        outputPanel.appendChild(this._outputRows.status.row);

        this._outputRows.speed = makeValueRow('Speed (controller)', { help: OUTPUT_HELP.speed, helpSystem, bar: true });
        this._outputRows.speedKph = makeValueRow('Speed (controller)\nkm/h', { help: OUTPUT_HELP.speedKph, helpSystem });
        this._outputRows.speedProj = makeValueRow('Speed (projected)\nforward', { help: OUTPUT_HELP.speedProj, helpSystem, bar: true });
        this._outputRows.yaw = makeValueRow('Yaw (deg)', { help: OUTPUT_HELP.yaw, helpSystem, arrow: true });
        this._outputRows.axes = makeValueRow('Controller axes\nup/forward', { help: OUTPUT_HELP.axes, helpSystem });
        this._outputRows.mass = makeValueRow('Mass (kg)', { help: OUTPUT_HELP.mass, helpSystem });
        this._outputRows.position = makeValueRow('Position (m)', { help: OUTPUT_HELP.position, helpSystem });
        this._outputRows.rotation = makeValueRow('Rotation (quat)', { help: OUTPUT_HELP.rotation, helpSystem });
        this._outputRows.linvel = makeValueRow('Linear velocity (m/s)', { help: OUTPUT_HELP.linvel, helpSystem });
        this._outputRows.angvel = makeValueRow('Angular velocity (rad/s)', { help: OUTPUT_HELP.angvel, helpSystem });
        this._outputRows.contacts = makeValueRow('Wheel contacts', { help: OUTPUT_HELP.contacts, helpSystem, dots: 4 });
        this._outputRows.rayDown = makeValueRow('Ray down hit', { help: OUTPUT_HELP.rayDown, helpSystem });
        this._outputRows.counts = makeValueRow('World counts', { help: OUTPUT_HELP.counts, helpSystem });

        outputPanel.appendChild(this._outputRows.speed.row);
        outputPanel.appendChild(this._outputRows.speedKph.row);
        outputPanel.appendChild(this._outputRows.speedProj.row);
        outputPanel.appendChild(this._outputRows.yaw.row);
        outputPanel.appendChild(this._outputRows.axes.row);
        outputPanel.appendChild(this._outputRows.mass.row);
        outputPanel.appendChild(this._outputRows.position.row);
        outputPanel.appendChild(this._outputRows.rotation.row);
        outputPanel.appendChild(this._outputRows.linvel.row);
        outputPanel.appendChild(this._outputRows.angvel.row);
        outputPanel.appendChild(this._outputRows.contacts.row);
        outputPanel.appendChild(this._outputRows.rayDown.row);
        outputPanel.appendChild(this._outputRows.counts.row);

        outputPanel.appendChild(makeSeparator());
        const wheelsLabel = makeLabel('Wheels');
        appendHelp(wheelsLabel, OUTPUT_HELP.wheels, helpSystem);
        outputPanel.appendChild(wheelsLabel);

        const wheelTable = document.createElement('div');
        wheelTable.style.display = 'grid';
        wheelTable.style.gridTemplateColumns = 'minmax(140px, 1fr) minmax(140px, 1fr)';
        wheelTable.style.gap = '12px';
        wheelTable.style.justifyContent = 'center';

        const headerLeft = document.createElement('div');
        headerLeft.textContent = 'Left wheels';
        headerLeft.style.fontSize = '12px';
        headerLeft.style.fontWeight = '800';
        headerLeft.style.opacity = '0.85';
        headerLeft.style.textTransform = 'uppercase';
        headerLeft.style.letterSpacing = '0.3px';
        headerLeft.style.textAlign = 'center';

        const headerRight = headerLeft.cloneNode(true);
        headerRight.textContent = 'Right wheels';

        const makeWheelCell = (wheelLabel) => {
            const cell = document.createElement('div');
            const baseBg = 'rgba(255,255,255,0.06)';
            const baseBorder = 'rgba(255,255,255,0.10)';
            const hoverBg = 'rgba(76,255,122,0.14)';
            const hoverBorder = 'rgba(76,255,122,0.65)';
            const hoverShadow = '0 0 14px rgba(76,255,122,0.35)';
            cell.style.background = baseBg;
            cell.style.border = `1px solid ${baseBorder}`;
            cell.style.borderRadius = '12px';
            cell.style.padding = '10px 10px 12px';
            cell.style.position = 'relative';
            cell.style.minHeight = '184px';
            cell.style.transition = 'background 140ms ease, border-color 140ms ease, box-shadow 140ms ease';

            const arrow = makeArrowMarker({ size: 14, color: 'rgba(233, 242, 255, 0.9)' });
            arrow.style.position = 'absolute';
            arrow.style.top = '10px';
            arrow.style.left = '10px';
            cell.appendChild(arrow);

            const knob = document.createElement('div');
            knob.style.position = 'absolute';
            knob.style.top = '10px';
            knob.style.right = '10px';
            knob.style.width = '11px';
            knob.style.height = '11px';
            knob.style.borderRadius = '999px';
            knob.style.background = '#c8cbd1';
            knob.style.boxShadow = '0 0 0 2px rgba(0,0,0,0.25)';
            knob.style.opacity = '0.85';
            cell.appendChild(knob);

            const text = document.createElement('div');
            text.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, monospace';
            text.style.fontSize = '12px';
            text.style.fontVariantNumeric = 'tabular-nums';
            text.style.whiteSpace = 'pre';
            text.style.lineHeight = '1.25';
            text.style.paddingLeft = '28px';
            text.textContent = 'â€”';
            cell.appendChild(text);

            const barWrap = document.createElement('div');
            barWrap.style.position = 'absolute';
            barWrap.style.left = '10px';
            barWrap.style.top = '32px';
            barWrap.style.width = '8px';
            barWrap.style.height = '96px';
            barWrap.style.borderRadius = '999px';
            barWrap.style.background = 'rgba(255,255,255,0.12)';
            barWrap.style.overflow = 'hidden';

            const barFill = document.createElement('div');
            barFill.style.position = 'absolute';
            barFill.style.left = '0';
            barFill.style.bottom = '0';
            barFill.style.width = '100%';
            barFill.style.height = '0%';
            barFill.style.background = 'rgba(76,255,122,0.85)';
            barWrap.appendChild(barFill);
            cell.appendChild(barWrap);

            const setHover = (active) => {
                cell.style.background = active ? hoverBg : baseBg;
                cell.style.borderColor = active ? hoverBorder : baseBorder;
                cell.style.boxShadow = active ? hoverShadow : 'none';
            };

            cell.addEventListener('mouseenter', () => {
                setHover(true);
                this.onWheelHover?.(wheelLabel);
            });
            cell.addEventListener('mouseleave', () => {
                setHover(false);
                this.onWheelHover?.(null);
            });
            return { root: cell, textEl: text, knobEl: knob, arrowEl: arrow, barEl: barFill, label: wheelLabel };
        };

        wheelTable.appendChild(headerLeft);
        wheelTable.appendChild(headerRight);

        const fl = makeWheelCell('FL');
        const fr = makeWheelCell('FR');
        const rl = makeWheelCell('RL');
        const rr = makeWheelCell('RR');
        this._wheelCells = { fl, fr, rl, rr };

        wheelTable.appendChild(fl.root);
        wheelTable.appendChild(fr.root);
        wheelTable.appendChild(rl.root);
        wheelTable.appendChild(rr.root);

        outputPanel.appendChild(wheelTable);

        const axisLegend = makeAxisLegend();
        root.appendChild(inputPanel);
        root.appendChild(outputPanel);
        root.appendChild(axisLegend.wrap);
        document.body.appendChild(root);

        this._hudRoot = root;
        this._inputPanel = inputPanel;
        this._outputPanel = outputPanel;
        this._axisLegendCoords = axisLegend.coordsEl;
        this._axisLegendCamIcon = axisLegend.camIcon;
        this._axisLegendToast = axisLegend.toastEl;

        if (this._axisLegendCamIcon) {
            this._axisLegendCamIcon.addEventListener('mouseenter', () => {
                this._openCameraPopup(this._axisLegendCamIcon);
            });
        }

        this._wireControls();
    }

    _createHelpSystem(root) {
        const tooltip = document.createElement('div');
        tooltip.style.position = 'fixed';
        tooltip.style.maxWidth = '280px';
        tooltip.style.padding = '8px 10px';
        tooltip.style.borderRadius = '10px';
        tooltip.style.background = 'rgba(10, 14, 20, 0.92)';
        tooltip.style.border = '1px solid rgba(255,255,255,0.18)';
        tooltip.style.color = '#e9f2ff';
        tooltip.style.fontSize = '12px';
        tooltip.style.lineHeight = '1.3';
        tooltip.style.whiteSpace = 'pre-line';
        tooltip.style.boxShadow = '0 8px 24px rgba(0,0,0,0.45)';
        tooltip.style.pointerEvents = 'none';
        tooltip.style.zIndex = '120';
        tooltip.style.display = 'none';
        document.body.appendChild(tooltip);
        this._helpTooltip = tooltip;

        const move = (event) => {
            if (!this._helpTooltip || this._helpTooltip.style.display === 'none') return;
            const pad = 12;
            const rect = this._helpTooltip.getBoundingClientRect();
            const x = Math.min(window.innerWidth - rect.width - pad, event.clientX + pad);
            const y = Math.min(window.innerHeight - rect.height - pad, event.clientY + pad);
            this._helpTooltip.style.left = `${Math.max(pad, x)}px`;
            this._helpTooltip.style.top = `${Math.max(pad, y)}px`;
        };

        return {
            show: (text, event) => {
                if (!this._helpTooltip) return;
                this._helpTooltip.textContent = text;
                this._helpTooltip.style.display = 'block';
                move(event);
            },
            move,
            hide: () => {
                if (!this._helpTooltip) return;
                this._helpTooltip.style.display = 'none';
            }
        };
    }

    _wireControls() {
        const wire = (control, key) => {
            if (!control?.input) return;
            const input = control.input;
            const isSelect = input.tagName === 'SELECT';
            const isCheckbox = input.type === 'checkbox';
            const readValue = () => {
                if (isCheckbox) return input.checked;
                if (isSelect) return input.value;
                const value = parseFloat(input.value);
                if (!Number.isFinite(value)) return null;
                return value;
            };
            const eventName = (isCheckbox || isSelect) ? 'change' : 'input';
            input.addEventListener(eventName, () => {
                const value = readValue();
                if (value === null) return;
                this._setInputValue(key, value);
            });
        };

        wire(this._inputControls.bodyType, 'bodyType');
        wire(this._inputControls.translationX, 'translationX');
        wire(this._inputControls.spawnHeight, 'spawnHeight');
        wire(this._inputControls.translationZ, 'translationZ');
        wire(this._inputControls.rotationW, 'rotationW');
        wire(this._inputControls.rotationX, 'rotationX');
        wire(this._inputControls.rotationY, 'rotationY');
        wire(this._inputControls.rotationZ, 'rotationZ');
        wire(this._inputControls.linvelX, 'linvelX');
        wire(this._inputControls.linvelY, 'linvelY');
        wire(this._inputControls.linvelZ, 'linvelZ');
        wire(this._inputControls.angvelX, 'angvelX');
        wire(this._inputControls.angvelY, 'angvelY');
        wire(this._inputControls.angvelZ, 'angvelZ');
        wire(this._inputControls.worldGravityX, 'worldGravityX');
        wire(this._inputControls.worldGravityY, 'worldGravityY');
        wire(this._inputControls.worldGravityZ, 'worldGravityZ');
        wire(this._inputControls.gravityScale, 'gravityScale');
        wire(this._inputControls.forceX, 'forceX');
        wire(this._inputControls.forceY, 'forceY');
        wire(this._inputControls.forceZ, 'forceZ');
        wire(this._inputControls.forcePointX, 'forcePointX');
        wire(this._inputControls.forcePointY, 'forcePointY');
        wire(this._inputControls.forcePointZ, 'forcePointZ');
        wire(this._inputControls.torqueX, 'torqueX');
        wire(this._inputControls.torqueY, 'torqueY');
        wire(this._inputControls.torqueZ, 'torqueZ');
        wire(this._inputControls.impulseX, 'impulseX');
        wire(this._inputControls.impulseY, 'impulseY');
        wire(this._inputControls.impulseZ, 'impulseZ');
        wire(this._inputControls.impulsePointX, 'impulsePointX');
        wire(this._inputControls.impulsePointY, 'impulsePointY');
        wire(this._inputControls.impulsePointZ, 'impulsePointZ');
        wire(this._inputControls.torqueImpulseX, 'torqueImpulseX');
        wire(this._inputControls.torqueImpulseY, 'torqueImpulseY');
        wire(this._inputControls.torqueImpulseZ, 'torqueImpulseZ');
        wire(this._inputControls.additionalMass, 'additionalMass');
        wire(this._inputControls.massPropsMass, 'massPropsMass');
        wire(this._inputControls.massPropsComX, 'massPropsComX');
        wire(this._inputControls.massPropsComY, 'massPropsComY');
        wire(this._inputControls.massPropsComZ, 'massPropsComZ');
        wire(this._inputControls.massPropsInertiaX, 'massPropsInertiaX');
        wire(this._inputControls.massPropsInertiaY, 'massPropsInertiaY');
        wire(this._inputControls.massPropsInertiaZ, 'massPropsInertiaZ');
        wire(this._inputControls.massPropsFrameW, 'massPropsFrameW');
        wire(this._inputControls.massPropsFrameX, 'massPropsFrameX');
        wire(this._inputControls.massPropsFrameY, 'massPropsFrameY');
        wire(this._inputControls.massPropsFrameZ, 'massPropsFrameZ');
        wire(this._inputControls.lockTranslations, 'lockTranslations');
        wire(this._inputControls.lockRotations, 'lockRotations');
        wire(this._inputControls.enabledRotX, 'enabledRotX');
        wire(this._inputControls.enabledRotY, 'enabledRotY');
        wire(this._inputControls.enabledRotZ, 'enabledRotZ');
        wire(this._inputControls.linearDamping, 'linearDamping');
        wire(this._inputControls.angularDamping, 'angularDamping');
        wire(this._inputControls.dominanceGroup, 'dominanceGroup');
        wire(this._inputControls.ccdEnabled, 'ccdEnabled');
        wire(this._inputControls.canSleep, 'canSleep');
        wire(this._inputControls.engineForce, 'engineForce');
        wire(this._inputControls.brakeForce, 'brakeForce');
        wire(this._inputControls.handbrakeForce, 'handbrakeForce');
        wire(this._inputControls.steerAngle, 'steerAngle');
        wire(this._inputControls.groundClearance, 'groundClearance');
        wire(this._inputControls.wheelSideInset, 'wheelSideInset');
        wire(this._inputControls.restLength, 'restLength');
        wire(this._inputControls.wheelbaseRatio, 'wheelbaseRatio');
        wire(this._inputControls.suspMaxTravel, 'suspMaxTravel');
        wire(this._inputControls.suspStiffness, 'suspStiffness');
        wire(this._inputControls.suspCompression, 'suspCompression');
        wire(this._inputControls.suspRelaxation, 'suspRelaxation');
        wire(this._inputControls.suspMaxForce, 'suspMaxForce');
        wire(this._inputControls.tireFrictionSlip, 'tireFrictionSlip');
        wire(this._inputControls.tireSideStiffness, 'tireSideStiffness');
    }

    _setInputValue(key, value) {
        let next = value;
        if (key === 'bodyType') {
            this._tuning.chassis.bodyType = String(next);
        } else if (key === 'translationX') {
            this._tuning.chassis.translation.x = next;
        } else if (key === 'spawnHeight') {
            this._vehicleConfig.spawnHeight = next;
            this._tuning.chassis.translation.y = next;
        } else if (key === 'translationZ') {
            this._tuning.chassis.translation.z = next;
        } else if (key === 'rotationW') {
            this._tuning.chassis.rotation.w = next;
        } else if (key === 'rotationX') {
            this._tuning.chassis.rotation.x = next;
        } else if (key === 'rotationY') {
            this._tuning.chassis.rotation.y = next;
        } else if (key === 'rotationZ') {
            this._tuning.chassis.rotation.z = next;
        } else if (key === 'linvelX') {
            this._tuning.chassis.linvel.x = next;
        } else if (key === 'linvelY') {
            this._tuning.chassis.linvel.y = next;
        } else if (key === 'linvelZ') {
            this._tuning.chassis.linvel.z = next;
        } else if (key === 'angvelX') {
            this._tuning.chassis.angvel.x = next;
        } else if (key === 'angvelY') {
            this._tuning.chassis.angvel.y = next;
        } else if (key === 'angvelZ') {
            this._tuning.chassis.angvel.z = next;
        } else if (key === 'worldGravityX') {
            this._worldConfig.gravity.x = next;
        } else if (key === 'worldGravityY') {
            this._worldConfig.gravity.y = next;
        } else if (key === 'worldGravityZ') {
            this._worldConfig.gravity.z = next;
        } else if (key === 'forceX') {
            this._forces.force.x = next;
        } else if (key === 'forceY') {
            this._forces.force.y = next;
        } else if (key === 'forceZ') {
            this._forces.force.z = next;
        } else if (key === 'forcePointX') {
            this._forces.forcePoint.x = next;
        } else if (key === 'forcePointY') {
            this._forces.forcePoint.y = next;
        } else if (key === 'forcePointZ') {
            this._forces.forcePoint.z = next;
        } else if (key === 'torqueX') {
            this._forces.torque.x = next;
        } else if (key === 'torqueY') {
            this._forces.torque.y = next;
        } else if (key === 'torqueZ') {
            this._forces.torque.z = next;
        } else if (key === 'impulseX') {
            this._forces.impulse.x = next;
        } else if (key === 'impulseY') {
            this._forces.impulse.y = next;
        } else if (key === 'impulseZ') {
            this._forces.impulse.z = next;
        } else if (key === 'impulsePointX') {
            this._forces.impulsePoint.x = next;
        } else if (key === 'impulsePointY') {
            this._forces.impulsePoint.y = next;
        } else if (key === 'impulsePointZ') {
            this._forces.impulsePoint.z = next;
        } else if (key === 'torqueImpulseX') {
            this._forces.torqueImpulse.x = next;
        } else if (key === 'torqueImpulseY') {
            this._forces.torqueImpulse.y = next;
        } else if (key === 'torqueImpulseZ') {
            this._forces.torqueImpulse.z = next;
        } else if (key === 'lockTranslations') {
            this._tuning.chassis.lockTranslations = !!next;
        } else if (key === 'lockRotations') {
            this._tuning.chassis.lockRotations = !!next;
        } else if (key === 'enabledRotX') {
            this._tuning.chassis.enabledRotations.x = !!next;
        } else if (key === 'enabledRotY') {
            this._tuning.chassis.enabledRotations.y = !!next;
        } else if (key === 'enabledRotZ') {
            this._tuning.chassis.enabledRotations.z = !!next;
        } else if (key === 'dominanceGroup') {
            this._tuning.chassis.dominanceGroup = next;
        } else if (key === 'ccdEnabled') {
            this._tuning.chassis.ccdEnabled = !!next;
        } else if (key === 'canSleep') {
            this._tuning.chassis.canSleep = !!next;
        } else if (key === 'engineForce') {
            this._inputs.engineForce = next;
        } else if (key === 'brakeForce') {
            this._inputs.brakeForce = next;
        } else if (key === 'handbrakeForce') {
            this._inputs.handbrakeForce = next;
        } else if (key === 'steerAngle') {
            this._inputs.steerAngle = next;
        } else if (key === 'groundClearance') {
            this._vehicleConfig.groundClearance = next;
        } else if (key === 'wheelSideInset') {
            this._vehicleConfig.wheelSideInset = next;
        } else if (key === 'restLength') {
            this._vehicleConfig.restLength = next;
        } else if (key === 'wheelbaseRatio') {
            this._vehicleConfig.wheelbaseRatio = next;
        } else if (key === 'additionalMass') {
            this._tuning.chassis.additionalMass = next;
        } else if (key === 'massPropsMass') {
            this._tuning.chassis.additionalMassProperties.mass = next;
        } else if (key === 'massPropsComX') {
            this._tuning.chassis.additionalMassProperties.com.x = next;
            this._emitComPreview();
        } else if (key === 'massPropsComY') {
            this._tuning.chassis.additionalMassProperties.com.y = next;
            this._emitComPreview();
        } else if (key === 'massPropsComZ') {
            this._tuning.chassis.additionalMassProperties.com.z = next;
            this._emitComPreview();
        } else if (key === 'massPropsInertiaX') {
            this._tuning.chassis.additionalMassProperties.inertia.x = next;
        } else if (key === 'massPropsInertiaY') {
            this._tuning.chassis.additionalMassProperties.inertia.y = next;
        } else if (key === 'massPropsInertiaZ') {
            this._tuning.chassis.additionalMassProperties.inertia.z = next;
        } else if (key === 'massPropsFrameW') {
            this._tuning.chassis.additionalMassProperties.inertiaFrame.w = next;
        } else if (key === 'massPropsFrameX') {
            this._tuning.chassis.additionalMassProperties.inertiaFrame.x = next;
        } else if (key === 'massPropsFrameY') {
            this._tuning.chassis.additionalMassProperties.inertiaFrame.y = next;
        } else if (key === 'massPropsFrameZ') {
            this._tuning.chassis.additionalMassProperties.inertiaFrame.z = next;
        } else if (key === 'linearDamping') {
            this._tuning.chassis.linearDamping = next;
        } else if (key === 'angularDamping') {
            this._tuning.chassis.angularDamping = next;
        } else if (key === 'gravityScale') {
            this._tuning.chassis.gravityScale = next;
        } else if (key === 'suspMaxTravel') {
            this._tuning.suspension.maxTravel = next;
        } else if (key === 'suspStiffness') {
            this._tuning.suspension.stiffness = next;
        } else if (key === 'suspCompression') {
            this._tuning.suspension.compression = next;
        } else if (key === 'suspRelaxation') {
            this._tuning.suspension.relaxation = next;
        } else if (key === 'suspMaxForce') {
            this._tuning.suspension.maxForce = next;
        } else if (key === 'tireFrictionSlip') {
            this._tuning.tires.frictionSlip = next;
        } else if (key === 'tireSideStiffness') {
            this._tuning.tires.sideFrictionStiffness = next;
        }

        const control = this._inputControls[key];
        if (control?.input) {
            if (control.input.type === 'checkbox') {
                control.input.checked = !!next;
            } else {
                control.input.value = String(next);
            }
            if (typeof control.update === 'function') {
                control.update(next);
            } else if (control.valEl) {
                control.valEl.textContent = control.fmt(next);
            }
        }
        if (key === 'worldGravityX' || key === 'worldGravityY' || key === 'worldGravityZ') {
            this._updateGravityDisplay();
        }
    }

    _startSampleRecord() {
        if (!this._enabled || this._activeTest || this._sampleRecording) return;
        this._sampleRecording = true;
        this._sampleElapsed = 0;
        this._sampleFrames = [];
        this._sampleConfig = this._buildSampleConfig();
        if (this._statusText) this._statusText.textContent = '';
        if (this._recordButton) this._recordButton.disabled = true;
        if (this._recordLabel) this._recordLabel.textContent = 'Recording';
    }

    _recordSampleFrame(snapshot) {
        if (!this._sampleRecording || !this._sampleFrames) return;
        this._sampleFrames.push(this._packSampleFrame(snapshot, this._sampleElapsed));
    }

    _finishSampleRecord() {
        if (!this._sampleRecording) return;
        this._sampleRecording = false;
        const payload = JSON.stringify({ c: this._sampleConfig ?? null, f: this._sampleFrames ?? [] });
        const done = (ok) => {
            if (this._statusText) this._statusText.textContent = '';
            this._sampleFrames = null;
            this._sampleConfig = null;
            this._sampleElapsed = 0;
            if (this._recordButton) {
                this._recordButton.disabled = !this._enabled || !!this._activeTest || this._sampleRecording;
            }
            if (this._recordLabel && !this._recordDotTimer) {
                this._recordLabel.textContent = 'Record sample';
            }
        };
        try {
            navigator.clipboard.writeText(payload).then(() => done(true)).catch(() => done(false));
        } catch {
            done(false);
        }
    }

    _buildSampleConfig() {
        const inputs = this._inputs ?? {};
        const vehicle = this._vehicleConfig ?? {};
        const tuning = this._tuning ?? {};
        const chassis = tuning.chassis ?? {};
        const massProps = chassis.additionalMassProperties ?? {};
        const suspension = tuning.suspension ?? {};
        const tires = tuning.tires ?? {};
        const world = this._worldConfig ?? {};
        const gravity = world.gravity ?? {};
        return {
            i: {
                e: qNum(inputs.engineForce, 0),
                b: qNum(inputs.brakeForce, 0),
                h: qNum(inputs.handbrakeForce, 0),
                s: qNum(inputs.steerAngle, 3)
            },
            v: {
                sh: qNum(vehicle.spawnHeight, 3),
                gc: qNum(vehicle.groundClearance, 3),
                rl: qNum(vehicle.restLength, 3),
                wbr: qNum(vehicle.wheelbaseRatio, 3),
                wso: qNum(vehicle.wheelSideInset, 3)
            },
            t: {
                bt: chassis.bodyType ?? null,
                tr: packVec3(chassis.translation, 3),
                rot: packQuat(chassis.rotation, 4),
                lv: packVec3(chassis.linvel, 3),
                av: packVec3(chassis.angvel, 3),
                am: qNum(chassis.additionalMass, 1),
                ld: qNum(chassis.linearDamping, 3),
                ad: qNum(chassis.angularDamping, 3),
                gs: qNum(chassis.gravityScale, 3),
                cs: typeof chassis.canSleep === 'boolean' ? (chassis.canSleep ? 1 : 0) : null,
                ccd: typeof chassis.ccdEnabled === 'boolean' ? (chassis.ccdEnabled ? 1 : 0) : null,
                dg: Number.isFinite(chassis.dominanceGroup) ? chassis.dominanceGroup : null,
                lt: typeof chassis.lockTranslations === 'boolean' ? (chassis.lockTranslations ? 1 : 0) : null,
                lr: typeof chassis.lockRotations === 'boolean' ? (chassis.lockRotations ? 1 : 0) : null,
                er: [
                    chassis.enabledRotations?.x ? 1 : 0,
                    chassis.enabledRotations?.y ? 1 : 0,
                    chassis.enabledRotations?.z ? 1 : 0
                ],
                mp: {
                    m: qNum(massProps.mass, 1),
                    com: packVec3(massProps.com, 3),
                    in: packVec3(massProps.inertia, 3),
                    fr: packQuat(massProps.inertiaFrame, 4)
                }
            },
            s: {
                mt: qNum(suspension.maxTravel, 3),
                st: qNum(suspension.stiffness, 1),
                cp: qNum(suspension.compression, 1),
                rl: qNum(suspension.relaxation, 1),
                mf: qNum(suspension.maxForce, 1)
            },
            ti: {
                fs: qNum(tires.frictionSlip, 3),
                ss: qNum(tires.sideFrictionStiffness, 3)
            },
            w: {
                g: packVec3(gravity, 3)
            }
        };
    }

    _packSampleFrame(snapshot, elapsed) {
        const body = snapshot?.body ?? {};
        const contacts = snapshot?.contacts ?? {};
        const wheels = snapshot?.wheelStates ?? [];
        return {
            t: Math.round((elapsed ?? 0) * 1000),
            st: snapshot?.status ?? null,
            p: packVec3(body.position, 3),
            r: packQuat(body.rotation, 4),
            lv: packVec3(body.linvel, 3),
            av: packVec3(body.angvel, 3),
            sp: qNum(snapshot?.speedMps, 3),
            sp2: qNum(snapshot?.speedProjMps, 3),
            y: qNum(snapshot?.yawRad, 4),
            c: [contacts.count ?? 0, contacts.total ?? 0],
            w: wheels.map((w) => [
                w?.index ?? null,
                w?.inContact ? 1 : 0,
                qNum(w?.suspensionLength, 3),
                qNum(w?.suspensionForce, 1),
                qNum(w?.forwardImpulse, 2),
                qNum(w?.sideImpulse, 2),
                qNum(Number.isFinite(w?.steering) ? -w.steering : w?.steering, 3)
            ])
        };
    }

    _startTest(test) {
        if (!test) return;
        this._activeTest = test;
        this._telemetry = [];
        this._telemetryMeta = {
            id: test.id,
            label: test.label,
            startedAt: new Date().toISOString()
        };
        this._testElapsed = 0;
        this._stepElapsed = 0;
        this._testStepIndex = 0;
        if (this._copyButton) this._copyButton.style.display = 'none';
        if (this._statusText) this._statusText.textContent = '';
        this._openTestPopup(test);

        this.setEnabled(this._enabled);
    }

    _advanceTest(dt) {
        if (!this._activeTest) return;

        const steps = this._activeTest.steps ?? [];
        const curStep = steps[this._testStepIndex];
        if (!curStep) {
            this._finishTest();
            return;
        }

        this._testElapsed += dt;
        this._stepElapsed += dt;

        if (this._stepElapsed >= curStep.duration) {
            this._stepElapsed = 0;
            this._testStepIndex += 1;
            if (this._testStepIndex >= steps.length) {
                this._finishTest();
                return;
            }
        }

        const active = steps[this._testStepIndex];
        if (active?.input) {
            for (const [k, v] of Object.entries(active.input)) {
                if (Number.isFinite(v)) this._setInputValue(k, v);
            }
        }
    }

    _finishTest() {
        this._activeTest = null;
        if (this._statusText) this._statusText.textContent = '';
        if (this._copyButton) this._copyButton.style.display = 'none';
        this._setTestPopupState('done');
        this.setEnabled(this._enabled);
    }

    _recordTelemetry(snapshot) {
        if (!this._telemetry) return;
        this._telemetry.push({
            t: this._testElapsed,
            input: { ...this._inputs },
            output: snapshot
        });
    }

    async _copyTelemetry() {
        if (!this._telemetry || !this._telemetryMeta) return false;
        const payload = JSON.stringify({ meta: this._telemetryMeta, frames: this._telemetry }, null, 2);
        try {
            await navigator.clipboard.writeText(payload);
            if (this._statusText) this._statusText.textContent = '';
            return true;
        } catch {
            if (this._statusText) this._statusText.textContent = '';
            return false;
        }
    }

    _resetInitialPosition() {
        this._activeTest = null;
        this._testElapsed = 0;
        this._stepElapsed = 0;
        this._testStepIndex = 0;
        this._telemetry = null;
        this._telemetryMeta = null;
        if (this._copyButton) this._copyButton.style.display = 'none';
        this._sampleRecording = false;
        this._sampleElapsed = 0;
        this._sampleFrames = null;
        this._sampleConfig = null;
        if (this._recordButton) {
            this._recordButton.disabled = !this._enabled || !!this._activeTest || this._sampleRecording;
        }

        this._setInputValue('engineForce', 0);
        this._setInputValue('brakeForce', 0);
        this._setInputValue('handbrakeForce', 0);
        this._setInputValue('steerAngle', 0);

        this.onResetForces?.();
        this._setForceLogEntry('const-force', null);
        this._clearForceEventLog({ category: 'force', keepConstants: true });
        this.onResetTorques?.();
        this._setForceLogEntry('const-torque', null);
        this._clearForceEventLog({ category: 'torque', keepConstants: true });

        if (this._statusText) this._statusText.textContent = '';
        this.setEnabled(this._enabled);
        this.onReset?.();
    }
}
