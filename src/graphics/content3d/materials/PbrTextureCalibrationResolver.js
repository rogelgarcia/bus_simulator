// src/graphics/content3d/materials/PbrTextureCalibrationResolver.js
// Shared resolver for per-material calibration overrides generated by the texture correction pipeline.

import { getPbrMaterialTileMeters } from '../catalogs/PbrMaterialCatalog.js';

const PBR_ID_PREFIX = 'pbr.';
const DEFAULT_PRESET_ID = 'aces';
const CORRECTION_CONFIG_FILE = 'pbr.material.correction.config.js';
const PBR_CORRECTION_BASE_URL = new URL('../../../../assets/public/pbr/', import.meta.url);
const EPS = 1e-6;
const EMPTY_OVERRIDES = Object.freeze({});

function clamp(value, min, max) {
    const num = Number(value);
    if (!Number.isFinite(num)) return min;
    return Math.max(min, Math.min(max, num));
}

function toPlainObject(value) {
    return value && typeof value === 'object' ? value : null;
}

function sanitizeMaterialId(value) {
    const id = typeof value === 'string' ? value.trim() : '';
    if (!id) return null;
    if (!id.startsWith(PBR_ID_PREFIX)) return null;
    const slug = id.slice(PBR_ID_PREFIX.length);
    if (!slug || slug.includes('/') || slug.includes('\\')) return null;
    return id;
}

function materialIdToSlug(materialId) {
    const id = sanitizeMaterialId(materialId);
    return id ? id.slice(PBR_ID_PREFIX.length) : null;
}

function normalizeRoughnessRemap(value) {
    const src = toPlainObject(value);
    if (!src) return null;

    const minRaw = Number(src.min);
    const maxRaw = Number(src.max);
    const gammaRaw = Number(src.gamma);
    if (!(Number.isFinite(minRaw) && Number.isFinite(maxRaw) && Number.isFinite(gammaRaw))) return null;

    const out = {
        min: clamp(minRaw, 0, 1),
        max: clamp(Math.max(minRaw, maxRaw), 0, 1),
        gamma: clamp(gammaRaw, 0.1, 4),
        invertInput: src.invertInput === true
    };

    const lowPercentile = Number(src.lowPercentile);
    const highPercentile = Number(src.highPercentile);
    if (Number.isFinite(lowPercentile) && Number.isFinite(highPercentile)) {
        const lo = clamp(lowPercentile, 0, 100);
        const hi = clamp(highPercentile, 0, 100);
        if (hi > lo) {
            out.lowPercentile = lo;
            out.highPercentile = hi;
        }
    }

    return Object.freeze(out);
}

export function sanitizePbrCalibrationOverrides(value) {
    const src = toPlainObject(value);
    if (!src) return EMPTY_OVERRIDES;

    const out = {};
    if (Number.isFinite(Number(src.tileMeters))) out.tileMeters = Math.max(EPS, Number(src.tileMeters));
    if (Number.isFinite(Number(src.normalStrength))) out.normalStrength = clamp(src.normalStrength, 0, 8);
    if (Number.isFinite(Number(src.roughness))) out.roughness = clamp(src.roughness, 0, 1);
    if (Number.isFinite(Number(src.metalness))) out.metalness = clamp(src.metalness, 0, 1);
    if (Number.isFinite(Number(src.aoIntensity))) out.aoIntensity = clamp(src.aoIntensity, 0, 2);
    if (Number.isFinite(Number(src.albedoBrightness))) out.albedoBrightness = clamp(src.albedoBrightness, 0, 4);
    if (Number.isFinite(Number(src.albedoTintStrength))) out.albedoTintStrength = clamp(src.albedoTintStrength, 0, 1);
    if (Number.isFinite(Number(src.albedoHueDegrees))) out.albedoHueDegrees = clamp(src.albedoHueDegrees, -180, 180);
    if (Number.isFinite(Number(src.albedoSaturation))) out.albedoSaturation = clamp(src.albedoSaturation, -1, 1);

    const roughnessRemap = normalizeRoughnessRemap(src.roughnessRemap);
    if (roughnessRemap) out.roughnessRemap = roughnessRemap;

    return Object.freeze(Object.keys(out).length ? out : EMPTY_OVERRIDES);
}

export function mapPbrCorrectionAdjustmentsToOverrides(adjustments) {
    const src = toPlainObject(adjustments);
    if (!src) return null;

    const out = {};

    const albedo = toPlainObject(src.albedo);
    if (albedo) {
        if (Number.isFinite(Number(albedo.brightness))) out.albedoBrightness = clamp(albedo.brightness, 0, 4);
        if (Number.isFinite(Number(albedo.hueDegrees))) out.albedoHueDegrees = clamp(albedo.hueDegrees, -180, 180);
        if (Number.isFinite(Number(albedo.tintStrength))) out.albedoTintStrength = clamp(albedo.tintStrength, 0, 1);
        if (Number.isFinite(Number(albedo.saturation))) out.albedoSaturation = clamp(Number(albedo.saturation) - 1, -1, 1);
    }

    const normal = toPlainObject(src.normal);
    if (normal && Number.isFinite(Number(normal.strength))) out.normalStrength = clamp(normal.strength, 0, 8);

    const roughness = toPlainObject(src.roughness);
    if (roughness) {
        const remap = normalizeRoughnessRemap({
            min: roughness.min,
            max: roughness.max,
            gamma: roughness.gamma,
            invertInput: roughness.invertInput,
            lowPercentile: Array.isArray(roughness.normalizeInputPercentiles) ? roughness.normalizeInputPercentiles[0] : undefined,
            highPercentile: Array.isArray(roughness.normalizeInputPercentiles) ? roughness.normalizeInputPercentiles[1] : undefined
        });
        if (remap) out.roughnessRemap = remap;
        else if (Number.isFinite(Number(roughness.strength))) out.roughness = clamp(roughness.strength, 0, 1);
    }

    const ao = toPlainObject(src.ao);
    if (ao && Number.isFinite(Number(ao.intensity))) out.aoIntensity = clamp(ao.intensity, 0, 2);

    const metalness = toPlainObject(src.metalness);
    if (metalness && Number.isFinite(Number(metalness.value))) out.metalness = clamp(metalness.value, 0, 1);

    return Object.keys(out).length ? sanitizePbrCalibrationOverrides(out) : null;
}

export function getPbrCalibrationDefaultOverrides(materialId) {
    const id = sanitizeMaterialId(materialId);
    if (!id) return Object.freeze({
        tileMeters: 1.0,
        albedoBrightness: 1.0,
        albedoTintStrength: 0.0,
        albedoHueDegrees: 0.0,
        albedoSaturation: 0.0,
        roughness: 1.0,
        normalStrength: 1.0,
        aoIntensity: 1.0,
        metalness: 0.0
    });

    const tileMeters = getPbrMaterialTileMeters(id);
    const tile = Number(tileMeters);
    return Object.freeze({
        tileMeters: (Number.isFinite(tile) && tile > 0) ? tile : 1.0,
        albedoBrightness: 1.0,
        albedoTintStrength: 0.0,
        albedoHueDegrees: 0.0,
        albedoSaturation: 0.0,
        roughness: 1.0,
        normalStrength: 1.0,
        aoIntensity: 1.0,
        metalness: 0.0
    });
}

export class PbrTextureCalibrationResolver {
    constructor({ presetId = DEFAULT_PRESET_ID, logger = console } = {}) {
        this._presetId = typeof presetId === 'string' && presetId.trim() ? presetId.trim() : DEFAULT_PRESET_ID;
        this._logger = logger ?? console;
        this._cache = new Map();
        this._inflight = new Map();
    }

    get presetId() {
        return this._presetId;
    }

    clear() {
        this._cache.clear();
        this._inflight.clear();
    }

    hasCached(materialId) {
        const id = sanitizeMaterialId(materialId);
        if (!id) return false;
        return this._cache.has(id);
    }

    getCachedOverrides(materialId) {
        const id = sanitizeMaterialId(materialId);
        if (!id) return null;
        return this._cache.get(id) ?? null;
    }

    async preloadOverrides(materialIds, { forceReload = false } = {}) {
        const ids = (Array.isArray(materialIds) ? materialIds : [])
            .map((id) => sanitizeMaterialId(id))
            .filter(Boolean);
        const unique = [...new Set(ids)];
        if (!unique.length) return [];

        return Promise.all(unique.map(async (id) => ({
            id,
            overrides: await this.resolveOverrides(id, { forceReload })
        })));
    }

    async resolveOverrides(materialId, { forceReload = false } = {}) {
        const id = sanitizeMaterialId(materialId);
        if (!id) return null;

        if (!forceReload && this._cache.has(id)) {
            return this._cache.get(id);
        }

        if (!forceReload && this._inflight.has(id)) {
            return this._inflight.get(id);
        }

        const request = this._loadOverridesForMaterial(id, { forceReload })
            .then((overrides) => {
                const next = overrides ?? null;
                this._cache.set(id, next);
                return next;
            })
            .catch((err) => {
                this._logger?.warn?.(`[PbrTextureCalibrationResolver] Failed to load calibration for ${id}:`, err);
                this._cache.set(id, null);
                return null;
            })
            .finally(() => {
                this._inflight.delete(id);
            });

        this._inflight.set(id, request);
        return request;
    }

    async _loadOverridesForMaterial(materialId, { forceReload = false } = {}) {
        const moduleUrl = this._getCorrectionConfigUrl(materialId, { forceReload });
        if (!moduleUrl) return null;

        try {
            const mod = await import(moduleUrl);
            const config = toPlainObject(mod?.default ?? mod);
            if (!config) return null;
            if (sanitizeMaterialId(config.materialId) !== materialId) return null;

            const presets = toPlainObject(config.presets);
            const preset = presets ? toPlainObject(presets[this._presetId]) : null;
            const adjustments = preset ? toPlainObject(preset.adjustments) : null;
            return mapPbrCorrectionAdjustmentsToOverrides(adjustments);
        } catch {
            return null;
        }
    }

    _getCorrectionConfigUrl(materialId, { forceReload = false } = {}) {
        const slug = materialIdToSlug(materialId);
        if (!slug) return null;
        const url = new URL(`${slug}/${CORRECTION_CONFIG_FILE}`, PBR_CORRECTION_BASE_URL);
        if (forceReload) {
            // Force a fresh module fetch when callers explicitly request reload.
            url.searchParams.set('v', `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`);
        }
        return url.toString();
    }
}

let _sharedCalibrationResolver = null;

export function getPbrTextureCalibrationResolver() {
    if (_sharedCalibrationResolver) return _sharedCalibrationResolver;
    _sharedCalibrationResolver = new PbrTextureCalibrationResolver();
    return _sharedCalibrationResolver;
}
